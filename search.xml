<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>构建模式：Go是怎么解决包依赖管理问题的？</title>
      <link href="/2022/08/24/gou-jian-mo-shi-go-shi-zen-me-jie-jue-bao-yi-lai-guan-li-wen-ti-de/"/>
      <url>/2022/08/24/gou-jian-mo-shi-go-shi-zen-me-jie-jue-bao-yi-lai-guan-li-wen-ti-de/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-构建模式是怎么演化的？"><a href="#Go-构建模式是怎么演化的？" class="headerlink" title="Go 构建模式是怎么演化的？"></a>Go 构建模式是怎么演化的？</h1><p> <strong>Go 程序由 Go 包组合而成的，Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程。</strong></p><p>Go 语言的构建模式历经了三个迭代和演化过程，分别是最初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module。这里我们就先来介绍一下前面这两个。</p><h2 id="首先我们来看-GOPATH。"><a href="#首先我们来看-GOPATH。" class="headerlink" title="首先我们来看 GOPATH。"></a>首先我们来看 GOPATH。</h2><p>Go 语言在首次开源时，就内置了一种名为 GOPATH 的构建模式。在这种构建模式下，Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><p>我这里给出了一段在 GOPATH 构建模式下编写的代码，你先来感受一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/sirupsen/logrus"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, gopath mode"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这段代码依赖了第三方包 logrus（logrus 是 Go 社区使用最为广泛的第三方 log 包）。</p><p>接下来，这个构建过程演示了 Go 编译器（这里使用 Go 1.10.8）在 GOPATH 环境变量所配置的目录下（这里为 /Users/tonybai/Go），无法找到程序依赖的 logrus 包而报错的情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.gomain.go:3:8: cannot <span class="token function">find</span> package <span class="token string">"github.com/sirupsen/logrus"</span> <span class="token keyword">in</span> any of:  /Users/tonybai/.bin/go1.10.8/src/github.com/sirupsen/logrus <span class="token punctuation">(</span>from <span class="token variable">$GOROOT</span><span class="token punctuation">)</span>  /Users/tonybai/Go/src/github.com/sirupsen/logrus <span class="token punctuation">(</span>from <span class="token variable">$GOPATH</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么 Go 编译器在 GOPATH 构建模式下，究竟怎么在 GOPATH 配置的路径下搜寻第三方依赖包呢？</strong></p><p>为了给你说清楚搜寻规则，我们先假定 Go 程序导入了 github.com/user/repo 这个包，我们也同时假定当前 GOPATH 环境变量配置的值为:</p><p><code>export GOPATH=/usr/local/goprojects:/home/tonybai/go</code></p><p>那么在 GOPATH 构建模式下，Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/goprojects/src/github.com/user/repo/home/tonybai/go/src/github.com/user/repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里注意一下，如果你没有显式设置 GOPATH 环境变量，Go 会将 GOPATH 设置为默认值，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，它的默认值是 $HOME/go。</p><p>那么，当遇到像上面例子一样，没有在本地找到程序的第三方依赖包的情况，我们该如何解决这个问题呢？</p><p>我们可以通过 go get 命令将本地缺失的第三方依赖包下载到本地，比如：</p><p><code>$go get github.com/sirupsen/logrus</code></p><p>这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。</p><p>不过，go get 下载的包只是那个时刻各个依赖包的最新主线版本，这样会给后续 Go 程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，得到不同的结果，也就是不能保证可重现的构建（Reproduceable Build）。又比如，如果依赖包引入了不兼容代码，程序将无法通过编译。</p><p>最后还有一点，如果依赖包因引入新代码而无法正常通过编译，并且该依赖包的作者又没用及时修复这个问题，这种错误也会传导到你的程序，导致你的程序无法通过编译。</p><p>也就是说，在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。</p><p><strong>现在我们就来看看 vendor 机制是怎么解决这个问题的。</strong></p><h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h2><p>Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。</p><p>Go 编译器会优先感知和使用 vendor 目录下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。</p><p>如果你将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。</p><p>下面这个目录结构就是为上面的代码示例添加 vendor 目录后的结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span>├── main<span class="token punctuation">.</span><span class="token keyword">go</span>└── vendor<span class="token operator">/</span>    ├── github<span class="token punctuation">.</span>com<span class="token operator">/</span>    │   └── sirupsen<span class="token operator">/</span>    │       └── logrus<span class="token operator">/</span>    └── golang<span class="token punctuation">.</span>org<span class="token operator">/</span>        └── x<span class="token operator">/</span>            └── sys<span class="token operator">/</span>                └── unix<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在添加完 vendor 后，我们重新编译 main.go，这个时候 Go 编译器就会在 vendor 目录下搜索程序依赖的 logrus 包以及后者依赖的 golang.org/x/sys/unix 包了。</p><p><strong>这里你还要注意一点，要想开启 vendor 机制，你的 Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面</strong>。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的。</p><p>不过 vendor 机制虽然一定程度解决了 Go 程序可重现构建的问题，但对开发者来说，它的体验却不那么好。一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。</p><p>另外，你还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等，最让开发者头疼的就是这一点。</p><p>为了解决这个问题，Go 核心团队与社区将 Go 构建的重点转移到如何解决包依赖管理上。Go 社区先后开发了诸如 gb、glide、dep 等工具，来帮助 Go 开发者对 vendor 下的第三方包进行自动依赖分析和管理，但这些工具也都有自身的问题。</p><p>就在 Go 社区为包依赖管理焦虑并抱怨没有官方工具的时候，Go 核心团队基于社区实践的经验和教训，推出了 Go 官方的解决方案：Go Module。</p><h2 id="创建你的第一个-Go-Module"><a href="#创建你的第一个-Go-Module" class="headerlink" title="创建你的第一个 Go Module"></a>创建你的第一个 Go Module</h2><p>从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。</p><p>在04 讲中，我们曾基于 Go Module 构建模式编写过一个“hello, world”程序，当时是为了讲解 Go 程序结构，这里我再带你回顾一下 Go Module 的基础概念。</p><p>一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。</p><p>go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><p>你可能也意识到了，Go Module 的原理和使用方法其实有点复杂，但“千里之行始于足下”，下面我们先从如何创建一个 Go Module 说起。我们先来将上面的例子改造成为一个基于 Go Module 构建模式的 Go 项目。</p><h2 id="创建一个-Go-Module"><a href="#创建一个-Go-Module" class="headerlink" title="创建一个 Go Module"></a>创建一个 Go Module</h2><p>将基于当前项目创建一个 Go Module，通常有如下几个步骤：</p><p>第一步，通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module；</p><p>第二步，通过 go mod tidy 命令自动更新当前 module 的依赖信息；</p><p>第三步，执行 go build，执行新 module 的构建。</p><p>我们一步一步来详细看一下。</p><p>我们先建立一个新项目 module-mode 用来演示 Go Module 的创建，注意我们可以在任意路径下创建这个项目，不必非要在 GOPATH 环境变量的配置路径下。</p><p>这个项目的 main.go 修改自上面的例子，修改后的 main.go 的代码是这样的，我们依旧依赖外部包 logrus：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/sirupsen/logrus"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这个项目目录下只有 main.go 一个源文件，现在我们就来为这个项目添加 Go Module 支持。我们通过 go mod init 命令为这个项目创建一个 Go Module（这里我们使用的是 Go 版本为 1.16.5，Go 1.16 版本默认采用 Go Module 构建模式）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod init github.com/bigwhite/module-modego: creating new go.mod: module github.com/bigwhite/module-modego: to <span class="token function">add</span> module requirements and sums:  go mod tidy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，go mod init 在当前项目目录下创建了一个 go.mod 文件，这个 go.mod 文件将当前项目变为了一个 Go Module，项目根目录变成了 module 根目录。go.mod 的内容是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/bigwhite/module-modego <span class="token number">1.16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个 go.mod 文件现在处于初始状态，它的第一行内容用于声明 module 路径 (module path)，最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p><p>go mod init 命令还输出了两行日志，提示我们可以使用 go mod tidy 命令，添加 module 依赖以及校验和。go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go.mod 文件。我们按照这个提示执行一下 go mod tidy 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/sirupsen/logrusgo: downloading github.com/sirupsen/logrus v1.8.1go: found github.com/sirupsen/logrus <span class="token keyword">in</span> github.com/sirupsen/logrus v1.8.1go: downloading golang.org/x/sys v0.0.0-20191026070338-33540a1f6037go: downloading github.com/stretchr/testify v1.2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，对于一个处于初始状态的 module 而言，go mod tidy 分析了当前 main module 的所有源文件，找出了当前 main module 的所有第三方依赖，确定第三方依赖的版本，还下载了当前 main module 的直接依赖包（比如 logrus），以及相关间接依赖包（直接依赖包的依赖，比如上面的 golang.org/x/sys 等）。</p><p>Go Module 还支持通过 Go Module 代理服务加速第三方依赖的下载。在03 讲我们讲解 Go 环境安装时，就提到过 GOPROXY 环境变量，这个环境变量的默认值为“https: // proxy.golang.org,direct”，不过我们可以配置更适合于中国大陆地区的 Go Module 代理服务。</p><p>由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]/pkg/mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径。</p><p>执行 go mod tidy 后，我们示例 go.mod 的内容更新如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">module github<span class="token punctuation">.</span>com<span class="token operator">/</span>bigwhite<span class="token operator">/</span>module<span class="token operator">-</span>mode<span class="token keyword">go</span> <span class="token number">1.16</span>require github<span class="token punctuation">.</span>com<span class="token operator">/</span>sirupsen<span class="token operator">/</span>logrus v1<span class="token punctuation">.</span><span class="token number">8.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，当前 module 的直接依赖 logrus，还有它的版本信息都被写到了 go.mod 文件的 require 段中。</p><p>而且，执行完 go mod tidy 后，当前项目除了 go.mod 文件外，还多了一个新文件 go.sum，内容是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c<span class="token operator">=</span>github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38<span class="token operator">=</span>github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM<span class="token operator">=</span>github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4<span class="token operator">=</span>github.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE<span class="token operator">=</span>github.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0<span class="token operator">=</span>github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w<span class="token operator">=</span>github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs<span class="token operator">=</span>golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4<span class="token operator">=</span>golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希值。</p><p>这是 Go Module 的一个安全措施。当将来这里的某个 module 的特定版本被再次下载的时候，go 命令会使用 go.sum 文件中对应的哈希值，和新下载的内容的哈希值进行比对，只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的 module 内容，不会被恶意或意外篡改。因此，我推荐你把 go.mod 和 go.sum 两个文件与源码，一并提交到代码版本控制服务器上</p><p>现在，go mod init 和 go mod tidy 已经为我们当前 Go Module 的构建铺平了道路，接下来，我们只需在当前 module 的根路径下，执行 go build 就可以完成 module 的构建了！</p><p>go build 命令会读取 go.mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。</p><p>整个过程的执行步骤是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build<span class="token variable">$ls</span>go.mod    go.sum    main.go    module-mode*$./module-mode INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> hello, go module mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，到这里，我们已经完成了一个有着多个第三方依赖的项目的构建了。但关于 Go Module 的操作还远不止这些。随着 Go 项目的演进，我们会在代码中导入新的第三方包，删除一些旧的依赖包，更新一些依赖包的版本等。关于这些内容，我会在下一节课再给你详细讲解。</p><p>那么，在看到我们的 Go Module 机制会自动分析项目的依赖包，并选出最适合的版本后，不知道你会不会有这样的疑惑：项目所依赖的包有很多版本，Go Module 是如何选出最适合的那个版本的呢？要想回答这个问题，我们就需要深入到 Go Module 构建模式的工作原理中去。</p><h2 id="深入-Go-Module-构建模式"><a href="#深入-Go-Module-构建模式" class="headerlink" title="深入 Go Module 构建模式"></a>深入 Go Module 构建模式</h2><p> Go 语言设计者在设计 Go Module 构建模式，来解决“包依赖管理”的问题时，进行了几项创新，这其中就包括语义导入版本 (Semantic Import Versioning)，以及和其他主流语言不同的最小版本选择 (Minimal Version Selection) 等机制。只要你深入理解了这些机制，你就能真正掌握 Go Module 构建模式。</p><h3 id="首先我们看一下-Go-Module-的语义导入版本机制。"><a href="#首先我们看一下-Go-Module-的语义导入版本机制。" class="headerlink" title="首先我们看一下 Go Module 的语义导入版本机制。"></a>首先我们看一下 Go Module 的语义导入版本机制。</h3><p>在上面的例子中，我们看到 go.mod 的 require 段中依赖的版本号，都符合 vX.Y.Z 的格式。在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成。</p><p>你可以看看下面这张图，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。例如上面的 logrus module 的版本号是 v1.8.1，这就表示它的主版本号为 1，次版本号为 8，补丁版本号为 1。</p><p><img src="https://static001.geekbang.org/resource/image/46/a2/468323b3294cce2ea7f4c1da3699c5a2.png?wh=1242x670"></p><p>Go 命令和 go.mod 文件都使用上面这种符合语义版本规范的版本号，作为描述 Go Module 版本的标准形式。借助于语义版本规范，Go 命令可以确定同一 module 的两个版本发布的先后次序，而且可以确定它们是否兼容。</p><p>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。</p><p>而且，Go Module 规定：<strong>如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的</strong>。怎么理解呢？我们来举个简单示例。我们就以 logrus 为例，它有很多发布版本，我们从中选出两个版本 v1.7.0 和 v1.8.1.。按照上面的语义版本规则，这两个版本的主版本号相同，新版本 v1.8.1 是兼容老版本 v1.7.0 的。那么，我们就可以知道，如果一个项目依赖 logrus，无论它使用的是 v1.7.0 版本还是 v1.8.1 版本，它都可以使用下面的包导入语句导入 logrus 包：</p><p><code>import "github.com/sirupsen/logrus"</code></p><p>那么问题又来了，假如在未来的某一天，logrus 的作者发布了 logrus v2.0.0 版本。那么根据语义版本规则，该版本的主版本号为 2，已经与 v1.7.0、v1.8.1 的主版本号不同了，那么 v2.0.0 与 v1.7.0、v1.8.1 就是不兼容的包版本。然后我们再按照 Go Module 的规定，如果一个项目依赖 logrus v2.0.0 版本，那么它的包导入路径就不能再与上面的导入方式相同了。那我们应该使用什么方式导入 logrus v2.0.0 版本呢？</p><p>Go Module 创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下面这样导入 logrus v2.0.0 版本依赖包：</p><p><code>import "github.com/sirupsen/logrus/v2"</code></p><p>这就是 Go 的“语义导入版本”机制，也就是说通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"github.com/sirupsen/logrus"</span>    logv2 <span class="token string">"github.com/sirupsen/logrus/v2"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过到这里，你可能会问，v0.y.z 版本应该使用哪种导入路径呢？</p><p>按照语义版本规范的说法，v0.y.z 这样的版本号是用于项目初始开发阶段的版本号。在这个阶段任何事情都有可能发生，其 API 也不应该被认为是稳定的。Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径，这样一定程度降低了 Go 开发人员使用这样版本号包时的心智负担。</p><p>Go 语义导入版本机制是 Go Module 机制的基础规则，同样它也是 Go Module 其他规则的基础。</p><h3 id="接下来，我们再来看一下-Go-Module-的最小版本选择原则。"><a href="#接下来，我们再来看一下-Go-Module-的最小版本选择原则。" class="headerlink" title="接下来，我们再来看一下 Go Module 的最小版本选择原则。"></a>接下来，我们再来看一下 Go Module 的最小版本选择原则。</h3><p>在前面的例子中，Go 命令都是在项目初始状态分析项目的依赖，并且项目中两个依赖包之间没有共同的依赖，这样的包依赖关系解决起来还是比较容易的。但依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？</p><p><img src="https://static001.geekbang.org/resource/image/49/1b/49eb7aa0458d8ec6131d9e5661155f1b.jpeg?wh=1920x1080"></p><p>在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0。这个时候，Go 命令是如何为 myproject 选出间接依赖包 C 的版本呢？选出的究竟是 v1.7.0、v1.1.0 还是 v1.3.0 呢？你可以暂停一两分钟思考一下。</p><p>其实，当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。</p><p>当然了，理想状态下，如果语义版本控制被正确应用，并且这种“社会契约”也得到了很好的遵守，那么这种选择算法是有道理的，而且也可以正常工作。在这样的情况下，依赖项的“最新最大版本”应该是最稳定和安全的版本，并且应该有向后兼容性。至少在相同的主版本 (Major Verion) 依赖树中是这样的。</p><p>但我们这个问题的答案并不是这样的。Go 设计者另辟蹊径，在诸多兼容性版本间，他们不光要考虑最新最大的稳定与安全，还要尊重各个 module 的述求：A 明明说只要求 C v1.1.0，B 明明说只要求 C v1.3.0。<strong>所以 Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”</strong></p><p>这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。并且，Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。</p><p>了解了语义导入版本与最小版本选择两种机制后，你就可以说你已经掌握了 Go Module 的精髓。</p><p>但很多 Go 开发人员的起点，并非是默认开启 Go Module 构建模式的 Go 1.16 版本，多数 Go 开发人使用的环境中都存在着多套 Go 版本，有用于体验最新功能特性的 Go 版本，也有某些遗留项目所使用的老版本 Go 编译器。</p><p>它们工作时采用的构建模式是不一样的，并且即便是引入 Go Module 的 Go 1.11 版本，它的 Go Module 机制，和后续进化后的 Go 版本的 Go Module 构建机制在表现行为上也有所不同。因此 Go 开发人员可能需要经常在各个 Go 版本间切换。而明确具体版本下 Go Module 的实际表现行为对 Go 开发人员是十分必要的。</p><h3 id="Go-各版本构建模式机制和切换"><a href="#Go-各版本构建模式机制和切换" class="headerlink" title="Go 各版本构建模式机制和切换"></a>Go 各版本构建模式机制和切换</h3><p>我们前面说了，在 Go 1.11 版本中，Go 开发团队引入 Go Modules 构建模式。这个时候，GOPATH 构建模式与 Go Modules 构建模式各自独立工作，我们可以通过设置环境变量 GO111MODULE 的值在两种构建模式间切换。</p><p>然后，随着 Go 语言的逐步演进，从 Go 1.11 到 Go 1.16 版本，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式几经变化，直到 Go 1.16 版本，Go Module 构建模式成为了默认模式。</p><p>所以，要分析 Go 各版本的具体构建模式的机制和切换，我们只需要找到这几个代表性的版本就好了。</p><p>我这里将 Go 1.13 版本之前、Go 1.13 版本以及 Go 1.16 版本，在 GO111MODULE 为不同值的情况下的行为做了一下对比，这样我们可以更好地理解不同版本下、不同构建模式下的行为特性，下面我们就来用表格形式做一下比对：</p><p><img src="https://static001.geekbang.org/resource/image/45/d3/45bdecc5fa873e06893d6658e447a8d3.jpeg?wh=1920x1080"></p><p>了解了这些，你就能在工作中游刃有余的在各个 Go 版本间切换了，不用再担心切换后模式变化，导致构建失败了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Go 语言最初发布时内置的构建模式为 GOPATH 构建模式。在这种构建模式下，所有构建都离不开 GOPATH 环境变量。在这个模式下，Go 编译器并没有关注依赖包的版本，开发者也无法控制第三方依赖的版本，导致开发者无法实现可重现的构建。</p><p>那么，为了支持可重现构建，Go 1.5 版本引入了 vendor 机制，开发者可以在项目目录下缓存项目的所有依赖，实现可重现构建。但 vendor 机制依旧不够完善，开发者还需要手工管理 vendor 下的依赖包，这就给开发者带来了不小的心智负担。</p><p>后来，Go 1.11 版本中，Go 核心团队推出了新一代构建模式：Go Module 以及一系列创新机制，包括语义导入版本机制、最小版本选择机制等。语义导入版本机制是 Go Moudle 其他机制的基础，它是通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本。而且，Go 命令使用最小版本选择机制进行包依赖版本选择，这和当前主流编程语言，以及 Go 社区之前的包依赖管理工具使用的算法都有点不同。</p><p>外，Go 命令还可以通过 GO111MODULE 环境变量进行 Go 构建模式的切换。但你要注意，从 Go 1.11 到 Go 1.16，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式以及具体表现行为也几经变化，这里你重点看一下前面总结的表格。</p><p>现在，Go 核心团队已经考虑在后续版本中彻底移除 GOPATH 构建模式，Go Module 构建模式将成为 Go 语言唯一的标准构建模式。所以，学完这一课之后，我建议你从现在开始就彻底抛弃 GOPATH 构建模式，全面使用 Go Module 构建模式。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day01</title>
      <link href="/2022/08/24/yi-yuan-ji-lu-day01/"/>
      <url>/2022/08/24/yi-yuan-ji-lu-day01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天去了县医院陪妈妈做检查，明天妈妈就要做手术了。</p><p>妈妈得了子宫肌瘤，虽然大家都说这是一个很常见的病，而且也是个小手术，但是还是很担心，害怕出现意外。而且妈妈也很害怕，因为她也很少住医院，而且也没有做过什么手术，希望明天一切都好。</p><p>每次到了这种时候，我都会想自己的长大跟不上父母衰老的速度，感觉自己现在还是个孩子，很多事情都做不好。而且最重要的就是自己还没有能力赚钱，这样就会感觉自己很没用。所以我有时候会想着不去上研究生，而选择直接就业，这样自己就能早点挣到钱了。</p><p>希望自己以后真的能够挣到差不多的钱，然后给父母一个安稳的晚年。</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准先行: Go项目的布局标准是什么?</title>
      <link href="/2022/08/23/biao-zhun-xian-xing-go-xiang-mu-de-bu-ju-biao-zhun-shi-shi-me/"/>
      <url>/2022/08/23/biao-zhun-xian-xing-go-xiang-mu-de-bu-ju-biao-zhun-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="现在的-Go-项目的典型结构布局是怎样的"><a href="#现在的-Go-项目的典型结构布局是怎样的" class="headerlink" title="现在的 Go 项目的典型结构布局是怎样的?"></a>现在的 Go 项目的典型结构布局是怎样的?</h1><p>一个 Go 项目通常分为可执行程序项目和库项目，现在我们就来分析一下这两类 Go 项目的典型结构布局分别是怎样的。</p><p><strong>首先我们先来看 Go 可执行程序项目的典型结构布局。</strong></p><p>可执行程序项目是以构建可执行程序为目的的项目，Go 社区针对这类 Go 项目所形成的典型结构布局是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -F exe-layout exe-layout├── cmd/│   ├── app1/│   │   └── main.go│   └── app2/│       └── main.go├── go.mod├── go.sum├── internal/│   ├── pkga/│   │   └── pkg_a.go│   └── pkgb/│       └── pkg_b.go├── pkg1/│   └── pkg1.go├── pkg2/│   └── pkg2.go└── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的一个 Go 项目典型布局就是“脱胎”于 Go 创世项目的最新结构布局，我现在跟你解释一下这里面的几个要点。</p><p>我们从上往下按顺序来，先来看 cmd 目录。cmd 目录就是存放项目要编译构建的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。</p><p>而且通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但它的功能其实并没有变。</p><p>接着我们来看 pkgN 目录，这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用。</p><p>然后是 go.mod 和 go.sum，它们是 Go 语言包依赖管理使用的配置文件。我们前面说过，Go 1.11 版本引入了 Go Module 构建机制，这里我建议你所有新项目都基于 Go Module 来进行包依赖管理，因为这是目前 Go 官方推荐的标准构建模式。</p><p>对于还没有使用 Go Module 进行包依赖管理的遗留项目，比如之前采用 dep、glide 等作为包依赖管理工具的，建议尽快迁移到 Go Module 模式。Go 命令支持直接将 dep 的 Gopkg.toml/Gopkg.lock 或 glide 的 glide.yaml/glide.lock 转换为 go.mod。</p><p>最后我们再来看看 vendor 目录。vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定版本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的。</p><p>不过呢，我们这里将 vendor 目录视为一个可选目录。原因在于，Go Module 本身就支持可再现构建，而无需使用 vendor。 当然 Go Module 机制也保留了 vendor 目录（通过 go mod vendor 可以生成 vendor 下的依赖包，通过 go build -mod=vendor 可以实现基于 vendor 的构建）。一般我们仅保留项目根目录下的 vendor 目录，否则会造成不必要的依赖选择的复杂性。</p><p>当然了，有些开发者喜欢借助一些第三方的构建工具辅助构建，比如：make、bazel 等。你可以将这类外部辅助构建工具涉及的诸多脚本文件（比如 Makefile）放置在项目的顶层目录下，就像 Go 创世项目中的 all.bash 那样。</p><p>另外，这里只要说明一下的是，Go 1.11 引入的 module 是一组同属于一个版本管理单元的包的集合。并且 Go 支持在一个项目 / 仓库中存在多个 module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。 因此，如果项目结构中存在版本管理的“分歧”，比如：app1 和 app2 的发布版本并不总是同步的，那么我建议你将项目拆分为多个项目（仓库），每个项目单独作为一个 module 进行单独的版本管理和演进。</p><p>当然如果你非要在一个代码仓库中存放多个 module，那么新版 Go 命令也提供了很好的支持。比如下面代码仓库 multi-modules 下面有三个 module：mainmodule、module1 和 module2：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> multi-modulesmulti-modules├── go.mod // mainmodule├── module1│   └── go.mod // module1└── module2    └── go.mod // module2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过 git tag 名字来区分不同 module 的版本。其中 vX.Y.Z 形式的 tag 名字用于代码仓库下的 mainmodule；而 module1/vX.Y.Z 形式的 tag 名字用于指示 module1 的版本；同理，module2/vX.Y.Z 形式的 tag 名字用于指示 module2 版本。</p><p>如果 Go 可执行程序项目有一个且只有一个可执行程序要构建，那就比较好办了，我们可以将上面项目布局进行简化：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">1</span> -F single-pkg-lib-layoutsingle-pkg-lib-layout├── feature1.go├── feature2.go├── go.mod└── internal/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，我们删除了 cmd 目录，将唯一的可执行程序的 main 包就放置在项目根目录下，而其他布局元素的功用不变。</p><p><strong>好了到这里，我们已经了解了 Go 可执行程序项目的典型布局，现在我们再来看看 Go 库项目的典型结构布局是怎样的。</strong></p><p>Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -F lib-layout lib-layout├── go.mod├── internal/│   ├── pkga/│   │   └── pkg_a.go│   └── pkgb/│       └── pkg_b.go├── pkg1/│   └── pkg1.go└── pkg2/    └── pkg2.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。</p><p>而且，在这里，vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go.mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了。</p><p>Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面。当然 internal 也可以有多个并存在于项目结构中的任一目录层级中，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。</p><p>对于有一个且仅有一个包的 Go 库项目来说，我们也可以将上面的布局做进一步简化，简化的布局如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">1</span> -F single-pkg-lib-layoutsingle-pkg-lib-layout├── feature1.go├── feature2.go├── go.mod└── internal/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化后，我们将这唯一包的所有源文件放置在项目的顶层目录下（比如上面的 feature1.go 和 feature2.go），其他布局元素位置和功用不变。</p><p>好了，现在我们已经了解完目前 Go 项目的典型结构布局了。不过呢，除了这些之外，还要注意一下早期 Go 可执行程序项目的经典布局，这个又有所不同。</p><p><strong>注意早期 Go 可执行程序项目的典型布局</strong></p><p>很多早期接纳 Go 语言的开发者所建立的 Go 可执行程序项目，深受 Go 创世项目 1.4 版本之前的布局影响，这些项目将所有可暴露到外面的 Go 包聚合在 pkg 目录下，就像前面 Go 1.3 版本中的布局那样，它们的典型布局结构是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">3</span> -F early-project-layoutearly-project-layout└── exe-layout/    ├── cmd/    │   ├── app1/    │   └── app2/    ├── go.mod    ├── internal/    │   ├── pkga/    │   └── pkgb/    ├── pkg/    │   ├── pkg1/    │   └── pkg2/    └── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，原本放在项目顶层目录下的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下了。而且，这种早期 Go 可执行程序项目的典型布局在 Go 社区内部也不乏受众，很多新建的 Go 项目依然采用这样的项目布局。</p><p>所以，当你看到这样的布局也不要奇怪，并且在我的讲解后，你应该就明确在这样的布局下 pkg 目录所起到的“聚类”的作用了。不过，在这里还是建议你在创建新的 Go 项目时，优先采用前面的标准项目布局。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们今天这门课就结束了。在这一节课里，我们学习了 Go 创世项目，也就是 Go 语言项目自身的项目源码布局，以及演进情况。在 Go 创世项目的启发下，Go 社区在多年实践中形成了典型的 Go 项目结构布局形式。</p><p>我们将 Go 项目分为可执行程序项目和 Go 库项目两类进行了详细的项目典型布局讲解，这里简单回顾一下。</p><p>首先，对于以生产可执行程序为目的的 Go 项目，它的典型项目结构分为五部分：</p><ul><li><p>放在项目顶层的 Go Module 相关文件，包括 go.mod 和 go.sum；</p></li><li><p>cmd 目录：存放项目要编译构建的可执行文件所对应的 main 包的源码文件；</p></li><li><p>项目包目录：每个项目下的非 main 包都“平铺”在项目的根目录下，每个目录对应一个 Go 包;</p></li><li><p>internal 目录：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；</p></li><li><p>vendor 目录：这是一个可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在的。这个目录下的内容均由 Go 命令自动维护，不需要开发者手工干预。</p></li></ul><p>第二，对于以生产可复用库为目的的 Go 项目，它的典型结构则要简单许多，我们可以直接理解为在 Go 可执行程序项目的基础上去掉 cmd 目录和 vendor 目录。</p><p>最后，早期接纳 Go 语言的开发者所建立的项目的布局深受 Go 创世项目 1.4 版本之前布局的影响，将可导出的公共包放入单独的 pkg 目录下，我们了解这种情况即可。对于新建 Go 项目，我依旧建议你采用前面介绍的标准布局形式。</p><p>现在，如果你要再面对一个要用于生产环境的 Go 应用项目的布局问题，是不是胸有成竹了呢？</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland 使用中的错误</title>
      <link href="/2022/08/23/goland-shi-yong-zhong-de-cuo-wu/"/>
      <url>/2022/08/23/goland-shi-yong-zhong-de-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>遇到问题</li></ul><p><img src="https://img-blog.csdnimg.cn/8c53af32c3b64a37b25f609af5977194.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>解决办法<ul><li>方案一</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/a0aeb21fb7844d788b3afa091a1085d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>删除go.mod</strong></p><p><img src="https://img-blog.csdnimg.cn/3fe3d3c764d54cffa9d8e7805a7ea111.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>产生原因</li></ul><p><strong>开启 Go module 模块支持后，并不能与 GOPATH 共存，所以需要删除其中一个</strong></p><p>现在基本开始使用 Go module ，所以可以将 GOPATH 删除</p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初窥门径: 一个Go程序的结构是怎样的?</title>
      <link href="/2022/08/23/chu-kui-men-jing-yi-ge-go-cheng-xu-de-jie-gou-shi-zen-yang-de/"/>
      <url>/2022/08/23/chu-kui-men-jing-yi-ge-go-cheng-xu-de-jie-gou-shi-zen-yang-de/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编写并运行第一个-Go-程序"><a href="#编写并运行第一个-Go-程序" class="headerlink" title="编写并运行第一个 Go 程序"></a>编写并运行第一个 Go 程序</h1><p><strong>Go 源文件总是用全小写字母形式的短小单词命名，并且以.go扩展名结尾</strong></p><p>如果要在源文件的名字中使用多个单词，我们通常是将多个单词连接起来作为源文件名，而不是使用其他分隔符，比如下划线。比如 hello_world.go</p><p><strong>下划线这种分隔符，在 Go 源文件命名中有特殊作用</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>终端运行</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token variable">$go</span> build main.go$./mainhello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">window<span class="token operator">&gt;</span>go build main.go<span class="token operator">&gt;</span>.<span class="token punctuation">\</span>main.exehello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="示例程序的结构"><a href="#示例程序的结构" class="headerlink" title="示例程序的结构"></a>示例程序的结构</h1><p><code>package main</code></p><p>这一行代码定义了 Go 中的一个包 package。包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属的包，在这里我们的“hello，world”示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。</p><p>main 包中的主要代码是一个名为 main 的函数： </p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>这里的 main 函数会比较特殊：当你运行一个可执行的 Go 程序的时候，所有的代码都会从这个入口函数开始运行</strong>这段代码的第一行声明了一个名为 main 的、没有任何参数和返回值的函数。如果某天你需要给函数声明参数的话，那么就必须把它们放置在圆括号 () 中。</p><p>另外，那对花括号{}被用来标记函数体，Go 要求所有的函数体都要被花括号包裹起来。按照惯例，我们推荐把左花括号与函数声明置于同一行并以空格分隔。Go 语言内置了一套 Go 社区约定俗称的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。</p><p>Gofmt 是 Go 语言在解决规模化（scale）问题上的一个最佳实践，并成为了 Go 语言吸引其他语言开发者的一大卖点。很多其他主流语言也在效仿 Go 语言推出自己的 format 工具，比如：Java formatter、Clang formatter、Dartfmt 等。因此，作为 Go 开发人员，请在提交你的代码前使用 Gofmt 格式化你的 Go 源码。</p><p>好，回到正题，我们再来看一看 main 函数体中的代码：</p><p><code>fmt.Println("hello, world")</code></p><p>注意点 1：标准 Go 代码风格使用 Tab 而不是空格来实现缩进的，当然这个代码风格的格式化工作也可以交由 gofmt 完成</p><p>注意点 2：我们调用了一个名为 Println 的函数，这个函数位于 Go 标准库的 fmt 包中。为了在我们的示例程序中使用 fmt 包定义的 Println 函数，我们其实做了两步操作。</p><ul><li><p>import “fmt” 一行中“fmt”代表的是包的导入路径（Import），它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；</p></li><li><p>fmt.Println 函数调用一行中的“fmt”代表的则是包名</p></li></ul><p>通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的“fmt”指的是包名，其实并不是这样的。</p><p>main 函数体中之所以可以调用 fmt 包的 Println 函数，还有最后一个原因，那就是 Println 函数名的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的（Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅限于在声明它的包内可见。</p><p>另外，在 Go 语言中，main 包是不可以像标准库 fmt 包那样被导入（Import）的，如果导入 main 包，在代码编译阶段你会收到一个 Go 编译器错误：import “xx/main” is a program, not an importable package。</p><p>注意点 3：我们还是回到 main 函数体实现上，把关注点放在传入到 Println 函数的字符串“hello, world”上面。你会发现，我们传入的字符串也就是我们执行程序后在终端的标准输出上看到的字符串。</p><p>这种“所见即所得”得益于 Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式，这与编译后的程序所运行的环境所使用的字符集和字符编码方式是一致的。</p><p>这里，即便我们将代码中的”hello, world”换成中文字符串“你好，世界”，像下面这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好，世界"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最后，不知道你有没有发现，我们整个示例程序源码中，都没有使用过分号来标识语句的结束，这与 C、C++、Java 那些传统编译型语言好像不太一样呀？</strong></p><p>不过，其实 Go 语言的正式语法规范是使用分号“;”来做结尾标识符的。那为什么我们很少在 Go 代码中使用和看到分号呢？这是因为，大多数分号都是可选的，常常被省略，不过在源码编译时，Go 编译器会自动插入这些被省略的分号。</p><p>我们给上面的“hello，world”示例程序加上分号也是完全合法的，是可以直接通过 Go 编译器编译并正常运行的。不过，gofmt 在按约定格式化代码时，会自动删除这些被我们手工加入的分号的。</p><p>在分析完这段代码结构后，我们来讲一下 Go 语言的编译。虽然刚刚你应该已经运行过“hello, world”这个示例程序了，在这过程中，有一个重要的步骤——编译，现在我就带你来看看 Go 语言中程序是怎么进行编译的。</p><h1 id="Go-语言中程序是怎么编译的"><a href="#Go-语言中程序是怎么编译的" class="headerlink" title="Go 语言中程序是怎么编译的?"></a>Go 语言中程序是怎么编译的?</h1><p>你应该也注意到了，刚刚我在运行”hello, world”程序之前，输入了 go build 命令，还有它附带的源文件名参数来编译它：</p><p><code>$go build main.go</code></p><p>假如你曾经有过 C/C++ 语言的开发背景，那么你就会发现这个步骤与 gcc 或 clang 编译十分相似。一旦编译成功，我们就会获得一个二进制的可执行文件。在 Linux 系统、macOS 系统，以及 Windows 系统的 PowerShell 中，我们可以通过输入下面这个 ls 命令看到刚刚生成的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ls</span>main*    main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面显示的文件里面有我们刚刚创建的、以.go 为后缀的源代码文件，还有刚生成的可执行文件（Windows 系统下为 main.exe，其余系统下为 main）。</p><p>如果你之前更熟悉某种类似于 Ruby、Python 或 JavaScript 之类的动态语言，你可能还不太习惯在运行之前需要先进行编译的情况。Go 是一种编译型语言，这意味着只有你编译完 Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境中。</p><p>而如果你交付给其他人的是一份.rb、.py 或.js 的动态语言的源文件，那么他们的目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 实现才能解释执行这些源文件。</p><p>当然，Go 也借鉴了动态语言的一些对开发者体验较好的特性，比如基于源码文件的直接执行，Go 提供了 run 命令可以直接运行 Go 源码文件，比如我们也可以使用下面命令直接基于 main.go 运行：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">$<span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>hello<span class="token punctuation">,</span> world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然像 go run 这类命令更多用于开发调试阶段，真正的交付成果还是需要使用 go build 命令构建的。</p><p>但是在我们的生产环境里，Go 程序的编译往往不会像我们前面，基于单个 Go 源文件构建类似“hello，world”这样的示例程序那么简单。越贴近真实的生产环境，也就意味着项目规模越大、协同人员越多，项目的依赖和依赖的版本都会变得复杂。</p><p>那在我们更复杂的生产环境中，go build 命令也能圆满完成我们的编译任务吗？我们现在就来探讨一下。</p><h1 id="复杂项目下-Go-程序的编译是怎样的"><a href="#复杂项目下-Go-程序的编译是怎样的" class="headerlink" title="复杂项目下 Go 程序的编译是怎样的"></a>复杂项目下 Go 程序的编译是怎样的</h1><p>我们还是直接上项目吧，给 go build 一个机会，看看它的复杂依赖管理到底怎么样。</p><p>现在我们创建一个新项目“hellomodule”，在新项目中我们将使用两个第三方库，zap 和 fasthttp，给 go build 的构建过程增加一些难度。和“hello，world”示例一样，我们通过下面命令创建“hellomodule”项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cd</span> ~/goprojects<span class="token variable">$mkdir</span> hellomodule<span class="token variable">$cd</span> hellomodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着，我们在“hellomodule“下创建并编辑我们的示例源码文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"github.com/valyala/fasthttp"</span>  <span class="token string">"go.uber.org/zap"</span><span class="token punctuation">)</span><span class="token keyword">var</span> logger <span class="token operator">*</span>zap<span class="token punctuation">.</span>Logger<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> zap<span class="token punctuation">.</span><span class="token function">NewProduction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">fastHTTPHandler</span><span class="token punctuation">(</span>ctx <span class="token operator">*</span>fasthttp<span class="token punctuation">.</span>RequestCtx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"hello, go module"</span><span class="token punctuation">,</span> zap<span class="token punctuation">.</span><span class="token function">ByteString</span><span class="token punctuation">(</span><span class="token string">"uri"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">RequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fasthttp<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span> fastHTTPHandler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例创建了一个在 8081 端口监听的 http 服务，当我们向它发起请求后，这个服务会在终端标准输出上输出一段访问日志。</p><p>你会看到，和“hello，world“相比，这个示例显然要复杂许多。但不用担心，你现在大可不必知道每行代码的功用，你只需要我们在这个稍微有点复杂的示例中引入了两个第三方依赖库，zap 和 fasthttp 就可以了。</p><p>我们尝试一下使用编译“hello，world”的方法来编译“hellomodule”中的 main.go 源文件，go 编译器的输出结果是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.gomain.go:4:2: no required module provides package github.com/valyala/fasthttp: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span>main.go:5:2: no required module provides package go.uber.org/zap: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看这结果，这回我们运气似乎不佳，main.go 的编译失败了！</p><p>从编译器的输出来看，go build 似乎在找一个名为 go.mod 的文件，来解决程序对第三方包的依赖决策问题。</p><p><strong>好了，我们也不打哑谜了，是时候让 Go module 登场了！</strong></p><p>Go module 构建模式是在 Go 1.11 版本正式引入的，为的是彻底解决 Go 项目复杂版本依赖的问题，在 Go 1.16 版本中，Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制。</p><p>Go Module 的核心是一个<strong>名为go.mod 的文件</strong>，在这个文件中存储了这个 module 对第三方依赖的全部信息。接下来，我们就通过下面命令为“hello，module”这个示例程序添加 go.mod 文件：</p><p><code>go mod init</code>  <strong>后面的名称，可以自己随意定义，跟本地文件没有关系，使用 github.com/… 作为 module path 是因为多数实用级 module 多是上传到 github 上的。这样是为了便于后续与真实生产接驳。但对于本地开发使用的简单示例程序而言，可以随意命名</strong></p><p><strong>go mod init后面的路径就是go.mod中module后面的路径，代表的是module path。</strong></p><p><strong>go mod init命令的实际行为就是在当前目录下创建一个go.mod，而这个go.mod将当前目录转换为一个go module。</strong></p><p><strong>go module是一个逻辑概念。文中也说了，它更像一个命名空间的概念。它与文件夹名称无关。有了go.mod后，这个文件夹下的各个包就算是这个go module下面的包了。包的导入路径也是以module path为前缀的。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod init github.com/bigwhite/hellomodulego: creating new go.mod: module github.com/bigwhite/hellomodulego: to <span class="token function">add</span> module requirements and sums:  go mod tidy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，go mod init 命令的执行结果是在当前目录下生成了一个 go.mod 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cat</span> go.modmodule github.com/bigwhite/hellomodulego <span class="token number">1.16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。go.mod 所在的目录被我们称为它声明的 module 的根目录。</p><p>不过呢，这个时候的 go.mod 文件内容还比较简单，第一行内容是用于声明 module 路径（module path）的。而且，module 隐含了一个命名空间的概念，module 下每个包的导入路径都是由 module path 和包所在子目录的名字结合在一起构成。</p><p>比如，如果 hellomodule 下有子目录 pkg/pkg1，那么 pkg1 下面的包的导入路径就是由 module path（github.com/bigwhite/hellomodule）和包所在子目录的名字（pkg/pkg1）结合而成，也就是 github.com/bigwhite/hellomodule/pkg/pkg1。</p><p>另外，go.mod 的最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p><p><strong>有了 go.mod 后，是不是我们就可以构建 hellomodule 示例了呢？</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">$<span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> no required module provides <span class="token keyword">package</span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>valyala<span class="token operator">/</span>fasthttp<span class="token punctuation">;</span> to add it<span class="token punctuation">:</span>  <span class="token keyword">go</span> get github<span class="token punctuation">.</span>com<span class="token operator">/</span>valyala<span class="token operator">/</span>fasthttpmain<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> no required module provides <span class="token keyword">package</span> <span class="token keyword">go</span><span class="token punctuation">.</span>uber<span class="token punctuation">.</span>org<span class="token operator">/</span>zap<span class="token punctuation">;</span> to add it<span class="token punctuation">:</span>  <span class="token keyword">go</span> get <span class="token keyword">go</span><span class="token punctuation">.</span>uber<span class="token punctuation">.</span>org<span class="token operator">/</span>zap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，Go 编译器提示源码依赖 fasthttp 和 zap 两个第三方包，但是 go.mod 中没有这两个包的版本信息，我们需要按提示手工添加信息到 go.mod 中。</p><p>这个时候，除了按提示手动添加外，我们也可以使用 go mod tidy 命令，让 Go 工具自动添加：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidy       go: downloading go.uber.org/zap v1.18.1go: downloading github.com/valyala/fasthttp v1.28.0go: downloading github.com/andybalholm/brotli v1.0.2<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果中，我们看到 Go 工具不仅下载并添加了 hellomodule 直接依赖的 zap 和 fasthttp 包的信息，还下载了这两个包的相关依赖包。go mod tidy 执行后，我们 go.mod 的最新内容变成了这个样子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/bigwhite/hellomodulego <span class="token number">1.16</span>require <span class="token punctuation">(</span>  github.com/valyala/fasthttp v1.28.0  go.uber.org/zap v1.18.1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，go.mod 已经记录了 hellomodule 直接依赖的包的信息。不仅如此，hellomodule 目录下还多了一个名为 go.sum 的文件，这个文件记录了 hellomodule 的直接依赖和间接依赖包的相关版本的 hash 值，用来校验本地包的真实性。在构建的时候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建。</p><p>有了 go.mod 以及 hellomodule 依赖的包版本信息后，我们再来执行构建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.go<span class="token variable">$ls</span>go.mod    go.sum    main*    main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这次我们成功构建出了可执行文件 main，运行这个文件，新开一个终端窗口，在新窗口中使用 curl 命令访问该 http 服务：curl localhost:8081/foo/bar，我们就会看到服务端输出如下日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./main<span class="token punctuation">{</span><span class="token string">"level"</span><span class="token builtin class-name">:</span><span class="token string">"info"</span>,<span class="token string">"ts"</span>:1626614126.9899719,<span class="token string">"caller"</span><span class="token builtin class-name">:</span><span class="token string">"hellomodule/main.go:15"</span>,<span class="token string">"msg"</span><span class="token builtin class-name">:</span><span class="token string">"hello, go module"</span>,<span class="token string">"uri"</span><span class="token builtin class-name">:</span><span class="token string">"/foo/bar"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这下，我们的“ hellomodule”程序可算创建成功了。我们也看到使用 Go Module 的构建模式，go build 完全可以承担其构建规模较大、依赖复杂的 Go 项目的重任。还有更多关于 Go Module 的内容，我会在第 7 节课再详细跟你讲解。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们终于亲手编写完成了 Go 语言的第一个程序“hello, world”，我们终于知道一个 Go 程序长成啥样子了，这让我们在自己的 Go 旅程上迈出了坚实的一步！</p><p>在这一节课里，我们通过 helloworld 示例程序，了解了一个 Go 程序的源码结构与代码风格自动格式化的约定。</p><ul><li><p>Go 包是 Go 语言的基本组成单元。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中；</p></li><li><p>Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数；</p></li><li><p>Go 源码需要先编译，再分发和运行。如果是单 Go 源文件的情况，我们可以直接使用 go build 命令 +Go 源文件名的方式编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目的构建。</p></li><li><p>最后，我们结合 hellomodule 示例初步学习了一个基于 Go Module 构建模式编写和构建更大规模 Go 程序的步骤并介绍了 Go Module 涉及到的各种概念。而且，Go Module 机制日渐成熟，我希望你学会基于 Go Module 构建 Go 应用。关于 Go Module 构建模式，我们还会在后面的讲解中详细介绍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cd 命令的使用</title>
      <link href="/2022/08/23/cd-ming-ling-de-shi-yong/"/>
      <url>/2022/08/23/cd-ming-ling-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>cd : Change Directory 切换路径</strong></p><ul><li><p><code>cd /</code> 回到根目录</p></li><li><p><code>cd ..</code> 回到上一层目录</p></li><li><p>进入任意目录</p></li></ul><p>方法一：</p><ol><li><p>直接输入 [该目录所在盘区]:    进入该盘区目录</p></li><li><p>然后输入 cd [在盘区下相对路径]   进入该目录</p><p><img src="https://img-blog.csdnimg.cn/20190806125049779.PNG" alt="在这里插入图片描述"></p></li></ol><p>方法二:</p><p><code>cd /d [对应目录]</code></p><p><img src="https://img-blog.csdnimg.cn/2019080612540499.PNG" alt="在这里插入图片描述"></p><ul><li>显示 cd 帮助及用法</li></ul><p><code>cd/?</code></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 的安装问题</title>
      <link href="/2022/08/23/go-de-an-zhuang-wen-ti/"/>
      <url>/2022/08/23/go-de-an-zhuang-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前安装过 go ，版本为 go1.18</p><p>安装路径设置不正确，没有设置为 Go 文件夹，而是直接安装到了 D:\ 路径下。</p><p>配置环境变量, GOROOT</p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配好环境：选择一种最适合你的Go安装方法</title>
      <link href="/2022/08/23/pei-hao-huan-jing-xuan-ze-yi-chong-zui-gua-he-ni-de-go-an-zhuang-fang-fa/"/>
      <url>/2022/08/23/pei-hao-huan-jing-xuan-ze-yi-chong-zui-gua-he-ni-de-go-an-zhuang-fang-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装-Go"><a href="#安装-Go" class="headerlink" title="安装 Go"></a>安装 Go</h1><h2 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h2><p>Go 几乎支持 Linux 所有的主流发行版操作系统，常见的包括 Ubuntu、CentOS（Redhat 企业版 Linux 的社区开源版）、Fedora、SUSE 等等，Go 在这些主流的 Linux 发行版操作系统上的安装方法都是一样的（当然某个发行版也可能会利用其软件安装管理器提供仅属于其自己的安装方法）。你可以参考下面这样的安装步骤。</p><p>首先，我们需要下载并解压 Go Linux 安装包：</p><p><code>$wget -c https://golang.google.cn/dl/go1.16.5.linux-amd64.tar.gz</code></p><p>这里有个小提醒：虽然 Go 官方下载站点是 golang.org/dl，但我们可以用针对中国大陆的镜像站点 golang.google.cn/dl 来下载，在中国大陆地区使用大陆镜像站点可以大幅缩短下载时间。</p><p>第二步，将下载完毕的 Go 安装包解压到安装目录中：</p><p><code>$tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz</code></p><p>执行完上面解压缩命令后，我们将在 /usr/local 下面看到名为 go 的目录，这个目录就是 Go 的安装目录，也是 Go 官方推荐的 Go 安装目录。我们执行下面命令可以查看该安装目录下的组成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ls</span> -F /usr/local/goAUTHORS          CONTRIBUTORS  PATENTS    SECURITY.md  api/  doc/         lib/   pkg/        src/CONTRIBUTING.md  LICENSE       README.md  VERSION      bin/  favicon.ico  misc/  robots.txt  test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过呢，为了可以在任意路径下使用 go 命令，我们需要将 Go 二进制文件所在路径加入到用户环境变量 PATH 中（以用户使用 bash 为例），具体操作是将下面这行环境变量设置语句添加到 $HOME/.profile 文件的末尾：</p><p><code>export PATH=$PATH:/usr/local/go/bin</code></p><p>然后执行下面命令使上述环境变量的设置立即生效：</p><p><code>$source ~/.profile</code></p><p>最后，我们可以通过下面命令验证此次安装是否成功：</p><p><code>go version</code></p><h2 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h2><p><strong>与linux 几乎没有差别</strong></p><h2 id="Window-安装"><a href="#Window-安装" class="headerlink" title="Window 安装"></a>Window 安装</h2><p>在 Windows 上，我们最好的安装方式就是采用图形界面引导下的 Go 安装方法。</p><p>我们打开Go 包的下载页面&lt;<a href="https://golang.google.cn/dl/">Downloads - The Go Programming Language (google.cn)</a>&gt;，在页面上找到 Go 1.16.5 版本的 Windows msi 安装包（AMD64 架构下的）：go1.16.5.windows-amd64.msi，通过浏览器自带的下载工具它下载到本地任意目录下。</p><p>双击打开已下载的 go1.16.5.windows-amd64.msi 文件，我们就能看到下面这个安装引导界面：</p><p><img src="https://static001.geekbang.org/resource/image/68/2a/686e669aefbbe3ae35e37b0929b9722a.png?wh=618x483"></p><p>和所有使用图形界面方式安装的 Windows 应用程序一样，我们只需一路点击“继续（next）”就可完成 Go 程序的安装了，安装程序默认会把 Go 安装在 C:\Program Files\Go 下面，当然你也可以自己定制你的安装目录。</p><p>除了会将 Go 安装到你的系统中之外，Go 安装程序还会自动为你设置好 Go 使用所需的环境变量，包括在用户环境变量中增加 GOPATH，它的值默认为 C:\Users[用户名]\go，在系统变量中也会为 Path 变量增加一个值：C:\Program Files\Go\bin，这样我们就可以在任意路径下使用 Go 了。</p><h1 id="安装多个-Go-版本"><a href="#安装多个-Go-版本" class="headerlink" title="安装多个 Go 版本"></a>安装多个 Go 版本</h1><h2 id="重新设置-PATH-环境变量"><a href="#重新设置-PATH-环境变量" class="headerlink" title="重新设置 PATH 环境变量"></a>重新设置 PATH 环境变量</h2><p>你只需要将不同版本的 Go 安装在不同路径下，然后将它们的 Go 二进制文件的所在路径加入到 PATH 环境变量中就可以了。</p><p>我们以 Linux 环境为例，在前面介绍 Go 标准安装方法的时候，我们已经将 Go 1.16.5 版本安装到了 /usr/local/go 下面，也将 /usr/local/go/bin 这个路径加入到了 PATH 路径下了，当前状态我们在任意路径下敲入 go，执行的都是 Go 1.16.5 版本对应的 Go 二进制文件。</p><p>那这个时候，如果我们想再安装一个 Go 1.15.13 版本要怎么办呢？首先，你需要按照标准步骤将 Go 1.15.13 安装到事先建好的 /usr/local/go1.15.13 路径下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> /usr/local/go1.15.13<span class="token variable">$wget</span> -c https://golang.google.cn/dl/go1.15.13.linux-amd64.tar.gz<span class="token variable">$tar</span> -C /usr/local/go1.15.13 -xzf go1.15.13.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们来设置 PATH 环境变量，将原先 $HOME/.profile 中的 PATH 变量的值由：</p><p><code>export PATH=$PATH:/usr/local/go/bin</code></p><p>改为:</p><p><code>export PATH=$PATH:/usr/local/go1.15.13/go/bin</code></p><h2 id="go-get-命令"><a href="#go-get-命令" class="headerlink" title="go get 命令"></a>go get 命令</h2><p><strong>这种方法有一个前提，那就是当前系统中已经通过标准方法安装过某个版本的 Go 了。</strong></p><p>我们还以 Linux 环境为例，假设目前环境中已经存在了采用标准方法安装的 Go 1.16.5 版本，我们接下来想再安装一个 Go 1.15.13 版本。按照 Go 官方方法，我们可以这样来做：</p><p>首先，将 $ HOME/go/bin 加入到 PATH 环境变量中并生效，即便这个目录当前不存在也没关系：</p><p><code>export PATH=$PATH:/usr/local/go/bin:~/go/bin</code></p><p>然后，我们要执行下面这个命令安装 Go 1.15.13 版本的下载器：</p><p><code>$go get golang.org/dl/go1.15.13</code></p><p>这个命令会将名为 Go 1.15.13 的可执行文件安装到 $HOME/go/bin 这个目录下，它是 Go 1.15.13 版本的专用下载器，下面我们再来执行 Go 1.15.13 的下载安装命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 downloadDownloaded   <span class="token number">0.0</span>% <span class="token punctuation">(</span>    <span class="token number">16384</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded   <span class="token number">1.8</span>% <span class="token punctuation">(</span>  <span class="token number">2129904</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded  <span class="token number">84.9</span>% <span class="token punctuation">(</span><span class="token number">102792432</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded <span class="token number">100.0</span>% <span class="token punctuation">(</span><span class="token number">121120420</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span>Unpacking /root/sdk/go1.15.13/go1.15.13.linux-amd64.tar.gz <span class="token punctuation">..</span>.Success. You may now run <span class="token string">'go1.15.13'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们看到这个命令下载了 go1.15.13.linux-amd64.tar.gz 安装包，也将它安装到 $HOME/sdk/go1.15.13 下面了。下载安装结束后，我们就可以利用带有版本号的 go 命令来使用特定版本的 Go 了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 versiongo version go1.15.13 linux/amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 <span class="token function">env</span> GOROOT/root/sdk/go1.15.13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="go-get-命令安装非稳定版本"><a href="#go-get-命令安装非稳定版本" class="headerlink" title="go get 命令安装非稳定版本"></a>go get 命令安装非稳定版本</h2><p>其实，除了 Go 团队正式发布的稳定版本 (stable version)，像前面安装的 Go 1.16.5 或 Go 1.15.13，我们还可以通过 go get 的方法安装 Go 团队正在开发的非稳定版本 (Unstable Version)，包括每个稳定版发布前的 beta 版本或当前最新的 tip 版本，这些非稳定版本可以让 Go 开发人员提前体验到即将加入到稳定版本中的新特性。</p><p>但是，通过 go get 安装不同 Go 版本的方法在中国大陆地区会因网络问题而失败。如果你已经克服了网络问题，那安装非稳定版本的步骤其实和上面的步骤一样。现在，我们以 Go 1.17beta1 和 Go Tip 版本为例，带你体验一下它们的安装步骤和验证方法。</p><p>首先我们来看 Go 1.17beta1：</p><h1 id="配置-Go"><a href="#配置-Go" class="headerlink" title="配置 Go"></a>配置 Go</h1><p>其实 Go 在安装后是开箱即用的，这也意味着我们在使用 Go 之前无需做任何配置。但为了更好地了解和学习 Go，我们还是要认识一些 Go 自带的常用配置项。Go 的配置项是以环境变量的形式存在的，我们可以通过下面这个命令查看 Go 的这些配置项：</p><p><code>go env</code></p><p><img src="https://static001.geekbang.org/resource/image/ba/96/ba6990798fb17fc18386749f9cce2c96.jpg?wh=1080x1192"></p><p>如果你还要了解更多关于 Go 配置项的说明，你可以通过 go help environment 命令查看。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，到这里我们的 Go 安装配置方法就讲解完毕了，选好你要使用的 Go 安装方法了吗？在这一节课中我们首先讲解了三种 Go 版本的选择策略：</p><ul><li><p>一种，也是我们推荐的一种，那就是使用 Go 最新的版本，这样你可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能，并且很多老版本中的 bug 在最新版本中都会得到及时修复；</p></li><li><p>如果你还是对最新版本的稳定性有一丝担忧，你也可以选择使用次新版；</p></li><li><p>最后，如果你要考虑现存生产项目或开源项目，那你按照需要选择，与项目策略保持一致就好了。</p></li></ul><p>确定完 Go 版本后，我们就可以来安装这个 Go 版本了。这一节课我们也详细介绍了在三个主流操作系统上安装 Go 稳定版本的方法。</p><p>对于使用 Windows 或 macOS 操作系统的开发者，使用基于图形界面的安装方式显然是最方便、最简洁的；对于使用 Linux 操作系统的开发者，使用自解压的安装包，或者是通过操作系统自带安装工具来进行 Go 安装比较普遍。</p><p>如果你是要在本地开发环境安装多个 Go 版本，或者是要抢先体验新版 Go，我们还讲解了两种在本地安装多个 Go 版本的方法。这里再强调一下，通过 go get 方式安装最新的 Go tip 版本存在失败的可能性哦！</p><p>最后，我们讲解了 Go 的一些常用配置项的功用，对于中国地区的 Go 开发者而言，你在真正使用 Go 构建应用之前，唯一要做的就是配置 GOPROXY 这个 Go 环境变量。</p><p>有了 Go 开发环境，我们就有了编写和构建 Go 代码的基础，在下一讲中我们就将开始学习如何编写 Go 代码。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言的设计哲学是怎么一回事</title>
      <link href="/2022/08/23/go-yu-yan-de-she-ji-zhe-xue-shi-zen-me-yi-hui-shi/"/>
      <url>/2022/08/23/go-yu-yan-de-she-ji-zhe-xue-shi-zen-me-yi-hui-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为</strong></p><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><p>知名 Go 开发者戴维·切尼（Dave Cheney）曾说过：“大多数编程语言创建伊始都致力于成为一门简单的语言，但最终都只是满足于做一个强大的编程语言”。</p><p>而 Go 语言是一个例外。Go 语言的设计者们在语言设计之初，就拒绝了走语言特性融合的道路，选择了“做减法”并致力于打造一门简单的编程语言。</p><p>选择了“简单”，就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。</p><p>其实，Go 语言也没它看起来那么简单，自身实现起来并不容易，但这些复杂性被 Go 语言的设计者们“隐藏”了，所以 Go 语法层面上呈现了这样的状态：</p><ul><li><p>仅有 25 个关键字</p></li><li><p>内置垃圾收集</p></li><li><p>首字母大小写决定可见性，无需通过额外关键字修饰</p></li><li><p>变量初始为类型零值</p></li><li><p>内置数组边界检查</p></li><li><p>内置并发支持，简化并发程序设计</p></li><li><p>内置接口类型，为组合的设计哲学奠定基础</p></li><li><p>原生提供完善的工具链，开箱即用</p></li><li><p>……</p></li></ul><p>看，我说的没错吧，确实挺简单的。当然了，任何的设计都存在着权衡与折中。我们看到 Go 设计者选择的“简单”，其实是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出了自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。</p><p>Go 这种有些“逆潮流”的“简单哲学”并不是一开始就能得到程序员的理解的，但在真正使用 Go 之后，我们才能真正体会到这种简单所带来的收益：简单意味着可以使用更少的代码实现相同的功能；简单意味着代码具有更好的可读性，而可读性好的代码通常意味着更好的可维护性以及可靠性。</p><p>总之，在软件工程化的今天，这些都意味着对生产效率提升的极大促进，<strong>我们可以认为简单的设计哲学是 Go 生产力的源泉。</strong></p><h1 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h1><p>在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，这与 C 语言的“信任程序员”原则完全不同，因此你需要以显式的方式通过转型统一参与计算各个变量的类型。</p><p>除此之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用了显式的基于值比较的错误处理方案，函数 / 方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误的处理。</p><p>这种有悖于“主流语言潮流”的错误处理机制还一度让开发者诟病，社区也提出了多个新错误处理方案，但或多或少都包含隐式的成分，都被 Go 开发团队一一否决了，这也与显式的设计哲学不无关系。</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>这个设计哲学和我们各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中是找不到经典的面向对象语法元素、类型体系和继承机制的，Go 推崇的是组合的设计哲学。</p><p>在诠释组合之前，我们需要先来了解一下 Go 在语法元素设计时，是如何为“组合”哲学的应用奠定基础的。</p><p>在 Go 语言设计层面，Go 设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括：</p><ul><li><p>Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念</p></li><li><p>每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的</p></li><li><p>实现某个接口时，无需想 java 那样采用特定关键字修饰</p></li><li><p>包之间是相对独立的，没有子包的概念</p></li></ul><p>我们可以看到，无论是包、接口还是一个个具体的类型定义，Go 语言其实是为我们呈现了这样的一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。那么现在摆在面前的工作，就是在这些孤岛之间以最适当的方式建立关联，并形成一个整体。<strong>而 Go 选择采用的组合方式，也是最主要的方式。</strong></p><p>Go 语言为支撑组合的设计提供了<strong>类型嵌入（Type Embedding）</strong>。通过类型嵌入，我们可以将已经实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有些类似经典面向对象语言中的“继承”机制，但在原理上却与面向对象中的继承完全不同，这是一种 Go 设计者们精心设计的“语法糖”。</p><p>被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。<strong>这种组合方式，我称之为垂直组合</strong>，即通过类型嵌入，快速让一个新类型“复用”其他类型已经实现的能力，实现功能的垂直扩展。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/sync/pool.go</span><span class="token keyword">type</span> poolLocal <span class="token keyword">struct</span> <span class="token punctuation">{</span>    private <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>       shared  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    Mutex   <span class="token comment">//类型嵌入              </span>    pad     <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口</span><span class="token comment">// $GOROOT/src/io/io.go</span><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>    Reader    Writer<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>垂直组合本质上是一种“能力继承”，采用嵌入方式定义的新类型继承了嵌入类型的能力。Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。</p><p>Go 语言中的接口是一个创新设计，它只是方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间“纽带”。</p><p>水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码段所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/io/ioutil/ioutil.go</span><span class="token keyword">func</span> <span class="token function">ReadAll</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// $GOROOT/src/io/io.go</span><span class="token keyword">func</span> <span class="token function">Copy</span><span class="token punctuation">(</span>dst Writer<span class="token punctuation">,</span> src Reader<span class="token punctuation">)</span><span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起了，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。类似的水平组合“模式”还有点缀器、中间件等，这里我就不展开了，在后面讲到接口类型时再详细叙述。</p><p>此外，我们还可以将 Go 语言内置的并发能力进行灵活组合以实现，比如，通过 goroutine+channel 的组合，可以实现类似 Unix Pipe 的能力。</p><p>总之，组合原则的应用实质上是塑造了 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。并且，组合也让遵循“简单”原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>好，前面我们已经看过 3 个设计哲学了，紧接着我带你看的是第 4 个：并发。</p><p>“并发”这个设计哲学的出现有它的背景，你也知道 CPU 都是靠提高主频来改进性能的，但是现在这个做法已经遇到了瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约了 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。</p><p>在这种大背景下，Go 的设计者在决定去创建一门新语言的时候，果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，<strong>Go 放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程</strong>，Go 将之称为 goroutine。</p><p>goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的栈空间仅 2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。</p><p>在提供了开销较低的 goroutine 的同时，Go 还在语言层面内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。</p><p>此外，并发的设计哲学不仅仅让 Go 在语法层面提供了并发原语支持，其对 Go 应用程序设计的影响更为重要。并发是一种程序结构设计的方法，它使得并行成为可能。采用并发方案设计的程序在单核处理器上也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能。</p><p>而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel+select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言也更适应现代计算环境。</p><h1 id="面向工程"><a href="#面向工程" class="headerlink" title="面向工程"></a>面向工程</h1><p>最后，我们来看一下 Go 的最后一条设计哲学：面向工程。</p><p>Go 语言设计的初衷，就是<strong>面向解决真实世界中 Google 内部大规模软件开发存在的各种问题</strong>，为这些问题提供答案，这些问题包括：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。</p><p>很多编程语言设计者和他们的粉丝们认为这些问题并不是一门编程语言应该去解决的，但 Go 语言的设计者并不这么看，他们在 Go 语言最初设计阶段就将解决工程问题作为 Go 的设计原则之一去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与其他偏学院派、偏研究型的编程语言在设计思路上的一个重大差异。</p><p>语法是编程语言的用户接口，它直接影响开发人员对于这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心的打磨。比如：</p><ul><li><p>重新设计编译单元和目标文件格式，实现 Go 源码快速构建，让大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；</p></li><li><p>如果源文件导入它不使用的包，则程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的。这也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；</p></li><li><p>去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；</p></li><li><p>包路径是唯一的，而包名不必唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的”这个约定，大大降低了开发人员给包起唯一名字的心智负担；</p></li><li><p>故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；</p></li><li><p>增加类型别名（type alias），支持大规模代码库的重构。</p></li></ul><p>在标准库方面，Go 被称为“自带电池”的编程语言。如果说一门编程语言是“自带电池”，则说明这门语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库，Go 语言恰恰就是这类编程语言。</p><p>由于诞生年代较晚，而且目标比较明确，Go 在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto、encoding等包充分迎合了云原生时代的关于 API/RPC Web 服务的构建需求，Go 开发者可以直接基于标准库提供的这些包实现一个满足生产要求的 API 服务，从而减少对外部第三方包或库的依赖，降低工程代码依赖管理的复杂性，也降低了开发人员学习第三方库的心理负担。</p><p>而且，开发人员在工程过程中肯定是需要使用工具的，Go 语言就提供了足以让所有其它主流语言开发人员羡慕的工具链，工具链涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪等方方面面。</p><p>这里值得重点介绍的是 gofmt，它统一了 Go 语言的代码风格，在其他语言开发者还在为代码风格争论不休的时候，Go 开发者可以更加专注于领域业务中。同时，相同的代码风格让以往困扰开发者的代码阅读、理解和评审工作变得容易了很多，至少 Go 开发者再也不会有那种因代码风格的不同而产生的陌生感。Go 的这种统一代码风格思路也在开始影响着后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴 Go 的一些设计。</p><p>在提供丰富的工具链的同时，Go 在标准库中提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> <strong>Go 语言的设计哲学：简单、显式、组合、并发和面向工程</strong></p><ul><li><p>简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；</p></li><li><p>显式是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；</p></li><li><p>组合是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；</p></li><li><p>并发是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；</p></li><li><p>面向工程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前世今生：你不得不了解的Go的历史和现状</title>
      <link href="/2022/08/23/qian-shi-jin-sheng-ni-bu-de-bu-liao-jie-de-go-de-li-shi-he-xian-zhuang/"/>
      <url>/2022/08/23/qian-shi-jin-sheng-ni-bu-de-bu-liao-jie-de-go-de-li-shi-he-xian-zhuang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-语言是怎样诞生的"><a href="#Go-语言是怎样诞生的" class="headerlink" title="Go 语言是怎样诞生的?"></a>Go 语言是怎样诞生的?</h1><p>Go 语言的创始人有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson），Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。</p><p>在罗伯·派克的心目中，“go”这个单词短小、容易输入并且在组合其他字母后便可以用来命名 Go 相关的工具，比如编译器（goc）、汇编器（goa）、链接器（gol）等（go 的早期版本曾如此命名 go 工具链，但后续版本撤销了这种命名方式，仅保留 go 这一统一的工具链名称 ）。</p><p>这里我还想澄清一个误区，很多 Go 语言初学者经常称这门语言为 Golang，其实这是不对的：“Golang”仅应用于命名 Go 语言官方网站，而且当时没有用 go.com 纯粹是这个域名被占用了而已。</p><p>在 Go 语言项目开源后，Go 语言也迎来了自己的“吉祥物”，是一只由罗伯·派克夫人芮妮·弗伦奇（Renee French）设计的地鼠，从此地鼠（gopher）也就成为了世界各地 Go 程序员的象征，Go 程序员也被昵称为 Gopher，在后面的课程中，我会直接使用 Gopher 指代 Go 语言开发者。</p><p><img src="https://static001.geekbang.org/resource/image/75/ab/756c7093c15eb32b5f9476b9fc5fcfab.png?wh=245x300"></p><h1 id="Go-是否值得我们学习？"><a href="#Go-是否值得我们学习？" class="headerlink" title="Go 是否值得我们学习？"></a>Go 是否值得我们学习？</h1><p>时间已经来到了 2021 年。经过了十余年的打磨与优化，如今的 Go 语言已经逐渐成为了云计算时代基础设施的编程语言。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、Istio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等。当然，这个列表还在持续增加，可见 Go 语言的影响力已经十分强大。</p><p>Go 除了在云计算基础设施领域，拥有上面这些杀手级应用之外，Go 语言的用户数量也在近几年快速增加。Go 语言项目技术负责人罗斯·考克斯甚至还专门写过一篇文章，来估算全世界范围的 Gopher 数量。按照他的估算结果，全世界范围的 Gopher 数量从 2017 年年中的最多 100 万，增长到 2019 年 11 月的最多 196 万，大概两年半翻了一番。庞大的 Gopher 基数为 Go 未来的发展提供持续的增长潜力和更大的想象空间。</p><h1 id="Go-语言前景究竟如何，值不值得投入学习呢"><a href="#Go-语言前景究竟如何，值不值得投入学习呢" class="headerlink" title="Go 语言前景究竟如何，值不值得投入学习呢?"></a>Go 语言前景究竟如何，值不值得投入学习呢?</h1><p>从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长的“技术萌芽期”。然后，实现了自举，而且对 GC 延迟进行了大幅优化的 Go 1.5 版本，成为了 Go 语言演化过程中的第一个“引爆点”，推动 Go 语言进入“技术膨胀期”。</p><p>也正是在这段时间内，Go 语言以迅雷不及掩耳盗铃之势推出了以 Docker、Kubernetes 为典型代表的“杀手级应用”，充分展现了实力，在世界范围收获了百万粉丝，迸发出极高的潜力和持续的活力。</p><p>Go 开源于 2009 年末，如果从那时算起，Go 才 11 岁。但在 Go 核心开发团队眼中，Go 的真正诞生年份是 2007 年，距今已 13 个年头有余了。</p><p>回顾一下计算机编程语言的历史，我们会发现，绝大多数主流编程语言，都将在其 15 至 20 年间大步前进。Java、Python、Ruby、JavaScript 和许多其他编程语言都是这样。如今 Go 语言也马上进入自己的黄金 5～10 年，从前面的技术成熟度曲线分析也可以印证这一点：Go 已经重新回到“稳步爬升的光明期”。对于开发人员来说，Go 语言学习的最佳时刻已经到来了！</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言第一课</title>
      <link href="/2022/08/23/go-yu-yan-di-yi-ke/"/>
      <url>/2022/08/23/go-yu-yan-di-yi-ke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择-Go-语言的三大理由"><a href="#选择-Go-语言的三大理由" class="headerlink" title="选择 Go 语言的三大理由"></a>选择 Go 语言的三大理由</h1><ul><li><p>对初学者足够友善，能够快速上手</p><ul><li>Go 是一种非常简单的语言，静态语言</li></ul></li><li><p>生产力与性能的最佳结合</p></li><li><p>快乐又有”钱景“</p><ul><li><p>简单的语法</p></li><li><p>得心应手的工具链</p></li><li><p>丰富和健壮的标准库</p></li></ul></li></ul><h1 id="五个阶段"><a href="#五个阶段" class="headerlink" title="五个阶段"></a>五个阶段</h1><p><img src="https://static001.geekbang.org/resource/image/fc/9d/fcf857acac0ec2512de6f9dd77b1a69d.jpg?wh=1920x1080"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本架构：一个键值数据库包含什么?</title>
      <link href="/2022/08/23/ji-ben-jia-gou-yi-ge-jian-zhi-shu-ju-ku-bao-han-shi-me/"/>
      <url>/2022/08/23/ji-ben-jia-gou-yi-ge-jian-zhi-shu-ju-ku-bao-han-shi-me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>Redis 支持的 value 类型包括了 String、哈希表、列表、集合等</p></li><li><p>数据的基本操作</p><ul><li><p>PUT</p></li><li><p>GET</p></li><li><p>DELETE</p></li><li><p>SCAN，根据一段 key 的范围返回对应的 value 值</p></li></ul></li><li><p>键值对保存在内存</p></li></ul><p><strong>键值数据库的基本结构</strong></p><p><img src="https://static001.geekbang.org/resource/image/ec/d5/ec18bf4b8afef2fa8b99af252d95a2d5.jpg?wh=2360*3791"></p><h2 id="采用什么访问模式"><a href="#采用什么访问模式" class="headerlink" title="采用什么访问模式"></a>采用什么访问模式</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这样学Redis</title>
      <link href="/2022/08/23/zhe-yang-xue-redis/"/>
      <url>/2022/08/23/zhe-yang-xue-redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Reids 知识全景图</strong></p><p><img src="https://static001.geekbang.org/resource/image/79/e7/79da7093ed998a99d9abe91e610b74e7.jpg?wh=2001*1126"></p><p><strong>Redis问题画像图</strong></p><p><img src="https://static001.geekbang.org/resource/image/70/b4/70a5bc1ddc9e3579a2fcb8a5d44118b4.jpeg?wh=2048*1536"></p><p><strong>课程大纲</strong></p><p><img src="https://static001.geekbang.org/resource/image/13/7e/13946f7543f9eea58c9bd2b877826b7e.jpg?wh=750*4458"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习和使用</title>
      <link href="/2022/08/22/git-xue-xi-he-shi-yong/"/>
      <url>/2022/08/22/git-xue-xi-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git分布式版本控制工具</p><p><strong>git 命令总结</strong></p><h2 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h2><ul><li><p>了解 Git 基本概念</p></li><li><p>概述 Git 工作流程</p></li><li><p>使用 Git 常用命令</p></li><li><p>熟悉 Git 代码托管服务</p></li><li><p>能够使用 idea 操作 Git</p></li></ul><h1 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h1><h2 id="2-1、开发中的实际场景"><a href="#2-1、开发中的实际场景" class="headerlink" title="2.1、开发中的实际场景"></a>2.1、开发中的实际场景</h2><ul><li><p>备份，及时进行备份，防止丢失修改</p></li><li><p>代码还原，可以进行代码还原，记录修改记录</p></li><li><p>协同开发，创建分支，可以多人协同开发，进行合并</p></li><li><p>追溯问题代码的编写人和编写时间。可以查看日志，进行问题查看.</p></li></ul><h2 id="2-2、版本控制器的方式"><a href="#2-2、版本控制器的方式" class="headerlink" title="2.2、版本控制器的方式"></a>2.2、版本控制器的方式</h2><ul><li><p>集中式版本控制工具</p><p>集中式版本控制工具，版本库是集中存放在中央服务器中，团队里的成员从中央服务器下载代码，是必须联网才能工作，个人修改后然后提交到中央版本库。</p><p>  举例：SVN和CVS</p></li><li><p>分布式版本控制工具</p><p>分布式版本控制系统没有”中央服务器“，每个人的电脑上都是一个完整的版本库，这样工作的时候，不需要联网。多人协作只需要各自的修改推送给对方，就能相互看到对方的修改了。</p></li></ul><h2 id="2-3、Git工作流程图"><a href="#2-3、Git工作流程图" class="headerlink" title="2.3、Git工作流程图"></a>2.3、Git工作流程图</h2><h1 id="3、Git安装与常用命令"><a href="#3、Git安装与常用命令" class="headerlink" title="3、Git安装与常用命令"></a>3、Git安装与常用命令</h1><h2 id="3-1、Git-环境配置"><a href="#3-1、Git-环境配置" class="headerlink" title="3.1、Git 环境配置"></a>3.1、Git 环境配置</h2><h3 id="3-1-1-下载与安装"><a href="#3-1-1-下载与安装" class="headerlink" title="3.1.1 下载与安装"></a>3.1.1 下载与安装</h3><p>下载地址：<a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p>安装完成后，在桌面或者是文件夹，点击鼠标右键，可以看到两个图标</p><ul><li><p>Git GUI Here: 图形界面工具</p></li><li><p>Git Bash: Git 提供的命令行工具</p></li></ul><h3 id="3-1-2-基本配置"><a href="#3-1-2-基本配置" class="headerlink" title="3.1.2 基本配置"></a>3.1.2 基本配置</h3><ul><li>设置用户名称和email地址<ol><li><p>打开Git Bash</p></li><li><p>设置用户信息</p></li></ol></li></ul><p>git config –global user.name “zzu”</p><p>git config –global user.email “”</p><h3 id="3-1-3-为常用指令配置别名"><a href="#3-1-3-为常用指令配置别名" class="headerlink" title="3.1.3 为常用指令配置别名"></a>3.1.3 为常用指令配置别名</h3><ol><li><p>打开用户目录，创建 .bashrc 文件</p><p><code>touch ~/.bashrc</code></p></li><li><p>在 .bashrc文件中输入你想要设置的命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">一些linux的命令都可以在这里使用<span class="token comment">#用于输出git提交日志</span><span class="token builtin class-name">alias</span> git-log<span class="token operator">=</span><span class="token string">'git log --pretty=online --all --graph --abbrev-commit'</span><span class="token comment">#用于输出当前目录所有文件和基本信息</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ll</span><span class="token operator">=</span><span class="token string">'ls -al'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>打开 gitBash, 执行 source ~/.bashrc</p><p><code>source ~/.bashrc</code></p></li></ol><h3 id="3-1-4-解决-GitBash-乱码问题"><a href="#3-1-4-解决-GitBash-乱码问题" class="headerlink" title="3.1.4 解决 GitBash 乱码问题"></a>3.1.4 解决 GitBash 乱码问题</h3><ol><li><p>打开 GitBash 执行下面命令</p><p><code>git config --global core.quotepath false</code></p></li><li><p>. ${git_home}/etc/bash.bashrc 文件最后加入下面两行</p><p><strong>Linux export 命令用于设置或显示环境变量。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="3-2、获取本地仓库"><a href="#3-2、获取本地仓库" class="headerlink" title="3.2、获取本地仓库"></a>3.2、获取本地仓库</h2><ol><li><p>选择一个空目录作为我们的本地仓库</p></li><li><p>进入这个目录，点击右键打开Git Bash Here窗口</p></li><li><p>执行命令 git init, 初始化仓库</p></li><li><p>创建成功后出现隐藏目录.git</p></li></ol><h2 id="3-3、基础操作命令"><a href="#3-3、基础操作命令" class="headerlink" title="3.3、基础操作命令"></a>3.3、基础操作命令</h2><p><strong>Git 会对仓库中的文件进行状态记录，每一个文件都会有几个状态</strong></p><ol><li><p>git add (工作区 –&gt; 暂存区)</p></li><li><p>git commit (暂存区 –&gt; 本地仓库)</p></li><li><p>git status 查看修改的状态</p></li><li><p>git add . 使用通配符，将工作区的多个文件的修改添加到暂存区</p></li><li><p>git commit -m ‘注释内容’</p></li><li><p>git log [option] 查看提交记录</p><ul><li>options<ul><li><p>-all 显示所有分支</p></li><li><p>–pretty=oneline 将提交信息显示为一行</p></li><li><p>–abbrev-commit 输出结果更加简短</p></li><li><p>–graph 以图的形式显示</p></li></ul></li></ul></li><li><p>git reset –hard commmitID 版本回退，进行版本切换</p><ul><li><p>commmitID 可以使用 git log 指令查看</p></li><li><p>如何查看已经删除的记录</p><ul><li>git reflog</li></ul></li></ul></li></ol><h2 id="3-4、编辑-gitignore文件"><a href="#3-4、编辑-gitignore文件" class="headerlink" title="3.4、编辑 .gitignore文件"></a>3.4、编辑 .gitignore文件</h2><p>并不是所有的文件都需要 git 的管理，比如日志文件，还有编译过程中生成的临时文件等。在这种情况下，我们可以创建一个 .gitignore 文件，列出要忽略的文件模式。</p><pre class="line-numbers language-none"><code class="language-none">HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5、分支"><a href="#3-5、分支" class="headerlink" title="3.5、分支"></a>3.5、分支</h2><p>几乎所有的版本控制系统都已某种形式支持分支。使用分支意味着你可以把你的工作从主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><h3 id="3-5-1、查看本地分支"><a href="#3-5-1、查看本地分支" class="headerlink" title="3.5.1、查看本地分支"></a>3.5.1、查看本地分支</h3><ul><li>git branch</li></ul><h3 id="3-5-2、创建本地分支"><a href="#3-5-2、创建本地分支" class="headerlink" title="3.5.2、创建本地分支"></a>3.5.2、创建本地分支</h3><ul><li>git branch 分支名</li></ul><h3 id="3-5-3、切换分支"><a href="#3-5-3、切换分支" class="headerlink" title="3.5.3、切换分支"></a>3.5.3、切换分支</h3><ul><li><p>git checkout 分支名</p></li><li><p>git checkout -b 分支名 (切换到一个不存在的分支，创建并切换)</p></li></ul><h3 id="3-5-4、合并分支"><a href="#3-5-4、合并分支" class="headerlink" title="3.5.4、合并分支"></a>3.5.4、合并分支</h3><ul><li>git merge 分支名 (合并到当前分支)</li></ul><h3 id="3-5-5、删除分支"><a href="#3-5-5、删除分支" class="headerlink" title="3.5.5、删除分支"></a>3.5.5、删除分支</h3><p><strong>不能删除当前分支，只能删除其他分支</strong></p><ul><li><p>git branch -d 分支名 (删除分支时，需要做各种检查)</p></li><li><p>git branch -D 分支名 (不做任何检查，强制删除)</p></li></ul><h3 id="3-5-6、解决冲突"><a href="#3-5-6、解决冲突" class="headerlink" title="3.5.6、解决冲突"></a>3.5.6、解决冲突</h3><p><strong>不同的分支对同一个文件进行修改，在进行合并时，可能会存在冲突，这个时候需要手动解决冲突</strong></p><ol><li><p>处理文件冲突的地方,进行文件编辑，选择你想要留下的修改</p></li><li><p>将文件加入暂存区(add)</p></li><li><p>提交到仓库(commit)</p></li></ol><h3 id="3-5-7、开发中分支使用的原则和流程"><a href="#3-5-7、开发中分支使用的原则和流程" class="headerlink" title="3.5.7、开发中分支使用的原则和流程"></a>3.5.7、开发中分支使用的原则和流程</h3><ul><li><p>master 生产分支</p></li><li><p>develop 开发分支</p></li><li><p>feature/xxxx分支</p></li><li><p>hotfix/xxxx分支</p></li><li><p>test分支</p></li><li><p>pre分支</p></li></ul><h1 id="4、Git远程仓库"><a href="#4、Git远程仓库" class="headerlink" title="4、Git远程仓库"></a>4、Git远程仓库</h1><h2 id="4-1、常见的远程仓库"><a href="#4-1、常见的远程仓库" class="headerlink" title="4.1、常见的远程仓库"></a>4.1、常见的远程仓库</h2><ul><li><p>github <a href="https://github.com/">https://github.com/</a>是一个面向开源及私有软件项目的托管平台，只支持 Git 作为唯一的版本库格式进行托管。服务器在国外，访问不稳定。</p></li><li><p>码云 <a href="https://gitee.com/">https://gitee.com/</a> 是国内的一个代码托管平台，由于服务器在国内，访问快，稳定。</p></li><li><p>GitLab <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> 是一个用于仓库管理系统的开源项目， 一般用于在企业、学校等内部网络搭建 git 私服。</p></li></ul><h2 id="4-2、注册码云"><a href="#4-2、注册码云" class="headerlink" title="4.2、注册码云"></a>4.2、注册码云</h2><ul><li>注册码云账号 <a href="https://gitee.com/signup">注册 - Gitee.com</a></li></ul><h2 id="4-3、创建远程仓库"><a href="#4-3、创建远程仓库" class="headerlink" title="4.3、创建远程仓库"></a>4.3、创建远程仓库</h2><p><strong>仓库创建后可以查看仓库的地址</strong></p><h2 id="4-4、配置SSH公钥"><a href="#4-4、配置SSH公钥" class="headerlink" title="4.4、配置SSH公钥"></a>4.4、配置SSH公钥</h2><ol><li><p>打开 Git Bash Here ，生成 SSH 公钥</p><ul><li><p>ssh-keygen -t rsa</p></li><li><p>不断回车</p><ul><li>如果公钥已经存在，则自动覆盖</li></ul></li></ul></li><li><p>Gitee 设置账户公钥</p><ul><li>获取公钥<ul><li>cat ~/.ssh/id_rsa.pub</li></ul></li></ul></li><li><p>验证是否配置成功</p><ul><li>ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a></li></ul></li></ol><h2 id="4-5、操作远程仓库"><a href="#4-5、操作远程仓库" class="headerlink" title="4.5、操作远程仓库"></a>4.5、操作远程仓库</h2><h3 id="4-5-1、添加远程仓库"><a href="#4-5-1、添加远程仓库" class="headerlink" title="4.5.1、添加远程仓库"></a>4.5.1、添加远程仓库</h3><p><strong>需要先创建一个本地仓库，然后与远程仓库进行连接</strong></p><ul><li>命令：git remote add &lt;远端名称&gt; &lt;仓库路径&gt;<ul><li><p>远端名称，默认是 origin,取决于远端服务器设置</p></li><li><p>仓库路径，从远端服务器获取此 URL</p></li><li><p><code>git remote add origin https://gitee.com/z1397543194/reggie_take_out.git</code></p></li></ul></li></ul><h3 id="4-5-2、查看远程仓库"><a href="#4-5-2、查看远程仓库" class="headerlink" title="4.5.2、查看远程仓库"></a>4.5.2、查看远程仓库</h3><ul><li>命令：git remote</li></ul><h3 id="4-5-3、推送到远程仓库"><a href="#4-5-3、推送到远程仓库" class="headerlink" title="4.5.3、推送到远程仓库"></a>4.5.3、推送到远程仓库</h3><ul><li>命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名]]<ul><li><p><code>git push origin master</code> 如果远程分支名和本地分支名称统统，则可以只写本地分支</p></li><li><p>-f 表示强制覆盖</p></li><li><p>–set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</p><ul><li><code>git push --set-upstream origin master</code></li></ul></li><li><p>如果当前分支已经和远端分支关联,则可以省略分支名和远端名</p><ul><li>git push 将master分支推送到已关联的远端分支</li></ul></li></ul></li></ul><h3 id="4-5-4、查看本地分支与远程分支的关联关系"><a href="#4-5-4、查看本地分支与远程分支的关联关系" class="headerlink" title="4.5.4、查看本地分支与远程分支的关联关系"></a>4.5.4、查看本地分支与远程分支的关联关系</h3><ul><li>命令：<code>git branch -vv</code></li></ul><h3 id="4-5-5、从远程仓库克隆"><a href="#4-5-5、从远程仓库克隆" class="headerlink" title="4.5.5、从远程仓库克隆"></a>4.5.5、从远程仓库克隆</h3><ul><li>命令： git clone &lt;仓库路径&gt; [本地目录]<ul><li>本地目录可以省略，会自动生成一个目录</li></ul></li></ul><h3 id="4-5-6、从远程仓库中抓取和拉取"><a href="#4-5-6、从远程仓库中抓取和拉取" class="headerlink" title="4.5.6、从远程仓库中抓取和拉取"></a>4.5.6、从远程仓库中抓取和拉取</h3><ul><li><p>抓取命令：<code>git fetch [remote name] [branch name]</code></p><ul><li><p>将仓库里的更新都抓取到本地，不会进行合并</p></li><li><p>如果不指定远端名称和分支名，则抓取所有分支</p></li></ul></li><li><p>拉取命令：<code>git pull [remote name] [branch name]</code></p><ul><li><p>将远端仓库的修改拉到本地并自动进行合并，==&gt;fetch + merge</p></li><li><p>如果不指定远端名称和分支名，则抓取并更新所有分支</p></li></ul></li></ul><h3 id="4-5-7、解决合并冲突"><a href="#4-5-7、解决合并冲突" class="headerlink" title="4.5.7、解决合并冲突"></a>4.5.7、解决合并冲突</h3><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。<br>A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。</p><h1 id="5、在-Idea-中使用-Git"><a href="#5、在-Idea-中使用-Git" class="headerlink" title="5、在 Idea 中使用 Git"></a>5、在 Idea 中使用 Git</h1><h2 id="5-1、在-Idea-中配置-Git"><a href="#5-1、在-Idea-中配置-Git" class="headerlink" title="5.1、在 Idea 中配置 Git"></a>5.1、在 Idea 中配置 Git</h2><h2 id="5-2、操作-Git"><a href="#5-2、操作-Git" class="headerlink" title="5.2、操作 Git"></a>5.2、操作 Git</h2><h3 id="5-2-1、创建远程仓库，使用码云"><a href="#5-2-1、创建远程仓库，使用码云" class="headerlink" title="5.2.1、创建远程仓库，使用码云"></a>5.2.1、创建远程仓库，使用码云</h3><h3 id="5-2-2、初始化本地仓库"><a href="#5-2-2、初始化本地仓库" class="headerlink" title="5.2.2、初始化本地仓库"></a>5.2.2、初始化本地仓库</h3><ul><li><p>在 idea 中创建</p></li><li><p>在目录中，执行 git init</p></li></ul><h3 id="5-2-3、设置远程仓库-或者克隆仓库"><a href="#5-2-3、设置远程仓库-或者克隆仓库" class="headerlink" title="5.2.3、设置远程仓库,或者克隆仓库"></a>5.2.3、设置远程仓库,或者克隆仓库</h3><h3 id="5-2-4、Git-的操作"><a href="#5-2-4、Git-的操作" class="headerlink" title="5.2.4、Git 的操作"></a>5.2.4、Git 的操作</h3><p><strong>git pull + merge / git add + commit / git push</strong></p><ul><li><p>更新项目 Ctrl + T</p></li><li><p>提交 Ctrl + K</p></li><li><p>推送 Ctrl + Shift + K</p></li></ul><h3 id="5-2-5、分支操作"><a href="#5-2-5、分支操作" class="headerlink" title="5.2.5、分支操作"></a>5.2.5、分支操作</h3><h3 id="5-2-6、解决冲突"><a href="#5-2-6、解决冲突" class="headerlink" title="5.2.6、解决冲突"></a>5.2.6、解决冲突</h3><ol><li><p>修改出现冲突的文件</p></li><li><p>add</p></li><li><p>commit</p></li><li><p>git push</p></li></ol><h2 id="5-3、IDEA常用-Git-操作入口"><a href="#5-3、IDEA常用-Git-操作入口" class="headerlink" title="5.3、IDEA常用 Git 操作入口"></a>5.3、IDEA常用 Git 操作入口</h2><h1 id="6、注意事项"><a href="#6、注意事项" class="headerlink" title="6、注意事项"></a>6、注意事项</h1><ul><li><p>切换分支前先提交本地的修改</p></li><li><p>代码写完后，要及时提交</p></li></ul><h2 id="6-1、window-查看隐藏文件-bashrc、-gitignore"><a href="#6-1、window-查看隐藏文件-bashrc、-gitignore" class="headerlink" title="6.1、window 查看隐藏文件(.bashrc、.gitignore)"></a>6.1、window 查看隐藏文件(.bashrc、.gitignore)</h2><h2 id="6-2、window-下创建-bashrc、-gitignore文件"><a href="#6-2、window-下创建-bashrc、-gitignore文件" class="headerlink" title="6.2、window 下创建.bashrc、.gitignore文件"></a>6.2、window 下创建.bashrc、.gitignore文件</h2><ul><li><p>打开git bash here</p></li><li><p><code>touch .gitignore</code></p></li></ul><h2 id="6-3、IDEA集成-GitBash-作为-Terminal"><a href="#6-3、IDEA集成-GitBash-作为-Terminal" class="headerlink" title="6.3、IDEA集成 GitBash 作为 Terminal"></a>6.3、IDEA集成 GitBash 作为 Terminal</h2><p><strong>可以作为git 的命令行，直接输入命令进行操作</strong></p><h1 id="7、学习资源推荐"><a href="#7、学习资源推荐" class="headerlink" title="7、学习资源推荐"></a>7、学习资源推荐</h1><ul><li><p>菜鸟教程 [菜鸟教程](<a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程 (runoob.com)</a>)</p></li><li><p>在线练习网站 [Git](<a href="https://oschina.gitee.io/learn-git-branching/">Learn Git Branching (gitee.io)</a>)</p></li><li><p>廖雪峰教程 [Git](<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window 如何打开终端</title>
      <link href="/2022/08/22/window-ru-he-da-kai-zhong-duan/"/>
      <url>/2022/08/22/window-ru-he-da-kai-zhong-duan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Window 如何打开命令行</strong></p><p>命令行工具有两种 cmd 和 powershell。老一代命令行工具cmd.exe及Windows新一代命令行工具Windows powershell工具，允许管理人员通过命令行的方式来管理计算机。只是相对cmd.exe，powershell的功能要强大的多，可以让管理员更容易地控制系统管理和加速自动化。powershell 是 cmd 的升级版、补充版,增加了很多命令。</p><h2 id="1-通过运行对话框打开"><a href="#1-通过运行对话框打开" class="headerlink" title="1. 通过运行对话框打开"></a>1. 通过运行对话框打开</h2><ul><li><p>win + R 打开运行对话框</p></li><li><p>输入 cmd / powershell</p></li></ul><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-20-58-image.png"></p><h2 id="2-通过开始菜单打开"><a href="#2-通过开始菜单打开" class="headerlink" title="2.通过开始菜单打开"></a>2.通过开始菜单打开</h2><ul><li><p>win + x ，或者在“开始”菜单上右键</p></li><li><p>选择命令提示符 / powershell</p></li></ul><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-21-16-image.png"></p><h1 id="3-在指定目录下打开"><a href="#3-在指定目录下打开" class="headerlink" title="3.在指定目录下打开"></a>3.在指定目录下打开</h1><h3 id="3-1-输入-cmd"><a href="#3-1-输入-cmd" class="headerlink" title="3.1 输入 cmd"></a>3.1 输入 cmd</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-26-52-image.png"></p><h3 id="3-2-shift-鼠标右键"><a href="#3-2-shift-鼠标右键" class="headerlink" title="3.2 shift + 鼠标右键"></a>3.2 shift + 鼠标右键</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-28-03-image.png"></p><h2 id="4-以管理员的身份打开"><a href="#4-以管理员的身份打开" class="headerlink" title="4.以管理员的身份打开"></a>4.以管理员的身份打开</h2><h3 id="4-1-搜索"><a href="#4-1-搜索" class="headerlink" title="4.1 搜索"></a>4.1 搜索</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-29-53-image.png"></p><h3 id="4-2-win-x"><a href="#4-2-win-x" class="headerlink" title="4.2 win + x"></a>4.2 win + x</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-30-24-image.png"></p><h3 id="4-3-在开始菜单中查找-cmd"><a href="#4-3-在开始菜单中查找-cmd" class="headerlink" title="4.3 在开始菜单中查找 cmd"></a>4.3 在开始菜单中查找 cmd</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-33-25-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Window </tag>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 学习</title>
      <link href="/2022/08/22/markdown-xue-xi/"/>
      <url>/2022/08/22/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1.语法</strong><br>**1.1 标题 **<br># 一级标题<br>## 二级标题<br>**1.2 列表 **</p><ul><li>无序列表使用 * 或 + 或 -</li><li>有序列表使用数字加.标识，例如：1.</li><li>无序列表<ul><li>二级列表项</li><li>二级列表项<ul><li>三级列表项，按TAB缩进即可</li></ul></li></ul></li><li>有序列表<ol><li>第一项</li><li>第二项<br><strong>1.3 链接</strong><br><strong>快捷键 Ctrl + k</strong><br><strong>1.3.1 文字超链接</strong><br>[显示的名字](网站)<br><a href="http://www.baidu.com/" title="百度一下">百度</a><br><strong>1.3.2 图像超链接</strong><br>![找不到图像文件时显示的文本](图像路径）<br><strong>1.3.3 索引超链接</strong><br>[显示名称][索引]<br>[索引]:对应的网站<br><a href="http://www.baudu.com/">百度官网</a></li></ol></li></ul><p><strong>1.3.4 自动链接</strong><br>直接用一对尖括号包围即可<br>&lt;网站&gt;<br>电子邮件地址也可以这样做<br><a href="mailto:1397543199@qq.com">1397543199@qq.com</a><br><strong>1.4 代码</strong><br><strong>1.4.1 代码片段</strong><br><strong>段落上的一个函数或片段的代码可以用反引号(<code>切换为英文输入法，在键盘的左上角) 把它包起来，例如：**</code>print(“你好”)`<br>**1.4.2 代码区块**<br>**用三个```或者三个~~~都可以定义代码区块，还可以选择语言种类，对代码进行高亮显示，不过应该不能补全提示，所以建议在ide中编写完成后，复制粘贴</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>1.5 文本</strong></p><pre class="line-numbers language-none"><code class="language-none">文本分段，前后至少保留一个空行即可。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1.5.1 加粗或斜体</strong><br><strong>加粗</strong> ** **<br><em>斜体</em> _ _<br><em><strong>粗斜体</strong></em> *** ***<br><em><strong>粗斜体</strong></em> ___ ___</p><ul><li><p>快捷键：Ctrl + B,可以快速添加加粗效果<br><strong>1.5.2 线条</strong></p></li><li><p>水平线：三个—,在这里不知道为什么加载不出来，别的编辑器可以<br>你好</p></li><li><p>删除线：前后各两个~~ ~~</p><p><del>原价:100</del></p></li><li><p>下划线：和HTML的标签相同，，在这里不知道为什么加载不出来，别的编辑器可以</p><p><u>你好</u></p></li></ul><p><strong>1.5.3 符号或图标</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c168c88c2a94b6fbd6761bc91a7fc62~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8256891606e4821a28dd7a244d1381c~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9506a3b069cb4cf48d98fc1f1a60cf15~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14bca78a45b64fc28bd8059be12b9b36~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbd904891c74d9299d542c9a2fb9b7d~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p>更多图标写法可参考: <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><p><strong>1.5.4 转义字符</strong></p><p>使用反斜杠\插入语法中用到的特殊符号。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d6fafb83a74ff5919539f4aa5dc8d2~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p>例如，如果你需要插入反斜杠，就连续输入两个\即可。<br>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p><p><strong>1.5.5 数学公式</strong></p><p>这个我平时很少使用，就不在这记录了，需要的时候在网上查找</p><p><strong>1.5.6 脚注</strong></p><p>脚注是对文本的补充说明<br>Markdown 脚注的格式如下:</p><p>[^要说明的文本]</p><p><strong>eg</strong></p><p>创建脚注格式类似这样<a href="%E4%BD%A0%E5%A5%BD%EF%BC%81%EF%BC%81%EF%BC%81">^hello</a>。</p><p><strong>1.6 引用</strong></p><p>区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号</p><blockquote><p>冬天来了，春天还会远吗?</p></blockquote><p><strong>1.7 表格</strong></p><p>表格使用 | 来分割不同的单元格，使用 - 来分割表头和其他行</p><table><thead><tr><th>姓名</th><th>年龄</th><th>性别</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>男</td></tr><tr><td>李四</td><td>18</td><td>女</td></tr></tbody></table><p><strong>1.8 样式</strong></p><p>  Markdown 标记语言出现的目的不是替代 HTML，也不是发明一种更便捷的插入HTML标签的方式。它对应的只是HTML标签的一个很小的子集。</p><p><strong>1.8.1 空格标记</strong></p><p>HTML提供好几种空格实体，它们拥有不同的宽度，非断行空格(&nbsp;)是常规空格的宽度，可运行于所有的主流浏览器。</p><ul><li>&nbsp; 不换行空格，全称No-Break Space。</li><li>  半角空格，全称En Space,占据的宽度正好是1/2个中文宽度，而且基本上不受字体的影响。</li><li>  全角空格，全称Em Space,占据的宽度正好是1个中文宽度，而且基本上不受字体的影响。</li><li>&amp;thsisp; 窄空格，全称Thin Space。占据的宽度比较小。</li><li>‌ 零宽不连字，全称Zero Width Non Joiner,是一个不打印字符,抑制本来会发生的连字。</li><li>‍ 零宽连字，全称Zero Width Joiner,产生连字的效果。</li></ul><p><strong>1.8.2 特殊样式，颜色</strong></p><p>【样式的写法】</p><p>不知道为什么，这里也没有效果</p><p>红色的文字</p><p><strong>1.10 图形</strong></p><p><strong>1.10.1 流程图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDStart <span class="token arrow operator">--&gt;</span> Stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDA<span class="token text string">[模块A]</span> <span class="token arrow operator">--&gt;</span><span class="token label property">|A1|</span> B<span class="token text string">(模块B)</span>B <span class="token arrow operator">--&gt;</span> C<span class="token text string">{判断条件C}</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C1|</span> D<span class="token text string">&gt;模块D]</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C2|</span> E<span class="token text string">((模块E))</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C3|</span> F<span class="token text string">["模块F(引号可转义特殊字符)"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.10.2 时序图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">sequenceDiagram</span>Alice<span class="token arrow operator">-&gt;&gt;</span>John<span class="token operator">:</span> Hello John, how are you?John<span class="token arrow operator">--&gt;&gt;</span>Alice<span class="token operator">:</span> Great!Alice<span class="token arrow operator">-)</span>John<span class="token operator">:</span> See you later!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.10.3 甘特图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">gantt</span>title A Gantt DiagramdateFormat  YYYY-MM-DDsection SectionA task           <span class="token operator">:</span>a1, 2014-01-01, 30dAnother task     <span class="token operator">:</span>after a1  , 20dsection AnotherTask in sec      <span class="token operator">:</span>2014-01-12  , 12danother task      <span class="token operator">:</span> 24d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13292f82dd1d45f59c1138fe1bd34dc0~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><strong>2 使用的软件</strong></p><p><strong>2.1 Typora</strong></p><p>之前是免费的，界面简洁，功能强大，现在是收费的。</p><p><strong>2.2 MarkText</strong></p><p>开源免费，支持多个平台。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cd9a9cb609241cbba108653769e7959~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><strong>2.3 ide插件</strong></p><p>VS Code, idea 等软件可以安装Markdown的插件。</p><p>学习使用Markdown<br>草稿箱<br>theme: juejin</p><hr>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 常用命令和命令别名快捷设置</title>
      <link href="/2022/08/22/hexo-chang-yong-ming-ling-he-ming-ling-bie-ming-kuai-jie-she-zhi/"/>
      <url>/2022/08/22/hexo-chang-yong-ming-ling-he-ming-ling-bie-ming-kuai-jie-she-zhi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>每次更新完博客后，都需要执行更新操作，命令较多，所以可以使用别名来减少输入</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><p><code>hexo clean </code>清理缓存</p></li><li><p><code>hexo g</code>  生成静态网页    hexo generate</p></li><li><p><code>hexo s</code>  本地预览            hexo server  默认为4000端口 -p 端口号</p></li><li><p><code>hexo d </code> 部署到 Github, 或者是服务器   hexo deploy</p></li><li><p><code>hexo n "postname"</code>  新建文章   hexo new “”</p></li><li><p><code>hexo n [layout] &lt;title&gt;</code> </p><ul><li>layout 不同，文件保存位置不同</li></ul></li></ul><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><ul><li><p><code>hexo init</code> 文件夹名称  初始化 hexo</p></li><li><p><code>npm update hexo -g</code>  升级</p></li><li><p><code>npm install hexo -g</code>   安装</p></li><li><p><code>node -v</code></p></li><li><p><code>npm -v</code></p></li><li><p><code>git --version</code></p></li><li><p><code>hexo -v</code></p></li><li><p><code>hexo publish [layout] &lt;title&gt;</code> 将草稿移动到 _posts 文件夹中</p><ul><li>草稿默认不会显示在页面中，您可在执行时加上&nbsp;<code>--draft</code>&nbsp;参数，或是把&nbsp;<code>render_drafts</code>&nbsp;参数设为&nbsp;<code>true</code>&nbsp;来预览草稿。</li></ul></li></ul><h1 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h1><p><code>$ hexo new photo "My Gallery"</code></p><p>在执行这行指令时，Hexo 会尝试在&nbsp;<code>scaffolds</code>&nbsp;文件夹中寻找&nbsp;<code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td></tr><tr><td><code>title</code></td><td>标题</td></tr><tr><td><code>date</code></td><td>文件建立日期</td></tr></tbody></table><h1 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h1><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了&nbsp;<code>hexo-renderer-marked</code>&nbsp;和&nbsp;<code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了&nbsp;<code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从&nbsp;<code>md</code>&nbsp;改成&nbsp;<code>ejs</code>，Hexo 就会使用&nbsp;<code>hexo-renderer-ejs</code>&nbsp;渲染这个文件，其他格式同理。</p><p><strong>参考链接：</strong>&lt;<a href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a>&gt;</p><h1 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h1><ol><li><p>打开 Git 的文件夹</p></li><li><p>找到 \Git\etc\bash.bashrc 文件,添加别名</p></li><li><pre><code class="bash">alias hs='hexo clean &amp;&amp; hexo g &amp;&amp; hexo s'alias hd='hexo clean &amp;&amp; hexo g &amp;&amp; hexo d'alias gp='git add . &amp;&amp; git commit -m "update" &amp;&amp; git push -f'</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github、Git 设置代理</title>
      <link href="/2022/08/22/github-git-she-zhi-dai-li/"/>
      <url>/2022/08/22/github-git-she-zhi-dai-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitHub-、Git设置和取消代理"><a href="#GitHub-、Git设置和取消代理" class="headerlink" title="GitHub 、Git设置和取消代理"></a>GitHub 、Git设置和取消代理</h1><h2 id="主要是加速-git-clone-操作"><a href="#主要是加速-git-clone-操作" class="headerlink" title="主要是加速 git clone 操作"></a>主要是加速 git clone 操作</h2><ul><li>git 设置代理</li></ul><p><code>git config --global http.proxy http:127.0.0.1:[10810 这里面是你代理的端口号]</code></p><ul><li>git 取消代理</li></ul><p><code>git config --global --unset http.proxy</code></p><ul><li>针对 github.com 设置代理</li></ul><p><code>git config --global http.https://github.com.proxy http://127.0.0.1:[端口号]</code></p><ul><li>取消 github.com 代理</li></ul><p><code>git config --global --unset http.https://github.com.proxy</code></p><p><strong>注意</strong>：设置代理需要科学上网，可以在软件上查看，也可以在设置里查看</p><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-21-09-36-20-image.png"></p><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-21-09-36-29-image.png"></p><h2 id="ssh-连接-github-失败问题"><a href="#ssh-连接-github-失败问题" class="headerlink" title="ssh 连接 github 失败问题"></a>ssh 连接 github 失败问题</h2><p>设置公钥后，连接失败，显示22端口拒绝,更换为 443 端口</p><p><code>ssh git@github.com</code></p><p><code>ssh: connect to host github.com port 22: Connection refused</code></p><ol><li><p>在任意位置打开 Git Bash Here</p></li><li><p>创建 config 文件</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.ssh/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在里面添加</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com Hostname ssh.github.com Port <span class="token number">443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
