<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图解网络</title>
      <link href="/2022/09/05/tu-jie-wang-luo/"/>
      <url>/2022/09/05/tu-jie-wang-luo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="1-1-TCP-IP-网络模型有哪几层？"><a href="#1-1-TCP-IP-网络模型有哪几层？" class="headerlink" title="1.1 TCP/IP 网络模型有哪几层？"></a>1.1 TCP/IP 网络模型有哪几层？</h2><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套<strong>通用的网络协议</strong>。</p><p>这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP/IP 网络模型」分别对每一层进行介绍。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>（<em>Application Layer</em>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。</p><p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" title="" alt="" data-align="inline"><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个&nbsp;<strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png"></p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p><p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p><p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。</p><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p><p>举个例子，比如 10.100.122.0/24，后面的<code>/24</code>表示就是&nbsp;<code>255.255.255.0</code>&nbsp;子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。</p><p>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</p><p>将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="img"></p><p>将 255.255.255.0 取反后与IP地址进行进行<strong>按位与运算</strong>，就可以得到主机号。</p><p>大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="子网掩码计算器"></p><p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p><p>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号"></p><p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png"></p><p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。</p><p>什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java格式化输出</title>
      <link href="/2022/09/04/java-ge-shi-hua-shu-chu/"/>
      <url>/2022/09/04/java-ge-shi-hua-shu-chu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、System-out-printf"><a href="#一、System-out-printf" class="headerlink" title="一、System.out.printf()"></a>一、System.out.printf()</h1><p>Java SE5推出了C语言printf()风格的<a href="https://so.csdn.net/so/search?q=%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA&amp;spm=1001.2101.3001.7020">格式化输出</a>功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%o\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"一个字符串：%s，一个浮点数：%f，一个整数：%d"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以一次输出多个变量，注意顺序即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、System-out-format"><a href="#二、System-out-format" class="headerlink" title="二、System.out.format()"></a>二、System.out.format()</h1><p>Java SE5引入的format()方法模仿C的printf()方法，可用于PrintStream或者PrintWriter对象，包括System.out对象。用法基本上和System.out.printf()类似。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%o\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"一个字符串：%s，一个浮点数：%f，一个整数：%d"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以一次输出多个变量，注意顺序即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、Fomatter类"><a href="#三、Fomatter类" class="headerlink" title="三、Fomatter类"></a>三、Fomatter类</h1><p>Java中所有的格式化功能都由java.util.Formatter类处理。当你创建一个Formatter对象时 ，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Formatter</span></span><span class="token punctuation">;</span><span class="token comment">//使用Formatter类时需要导入java.util.Formatter</span><span class="token class-name">Formatter</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个Formatter对象，指定输出为System.out</span><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%o\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"一个字符串：%s，一个浮点数：%f，一个整数：%d"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以一次输出多个变量，注意顺序即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、String-format"><a href="#四、String-format" class="headerlink" title="四、String.format()"></a>四、String.format()</h1><p>String.format()是一个static方法，接收与Formatter.format()一样的参数，其返回值：String对象，适用于一次输出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%o"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化输出 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用中的问题</title>
      <link href="/2022/09/03/markdown-shi-yong-zhong-de-wen-ti/"/>
      <url>/2022/09/03/markdown-shi-yong-zhong-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>因为使用了GitHub作为图床，需要将图片上传，所以不可以插入截图，必须将图片保存下来。</p><p>复制网页上的图片时，可以插入，因为复制的是图片的链接，所以可以使用。</p><p><strong>注意</strong>：</p><ul><li>插入图片的路径不可以出现中文</li></ul><h1 id="快捷键使用"><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h1><p>现在还没有解决。感觉快捷键出现了冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vpn软件的推荐</title>
      <link href="/2022/09/03/vpn-ruan-jian-de-tui-jian/"/>
      <url>/2022/09/03/vpn-ruan-jian-de-tui-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="白鲸加速器"><a href="#白鲸加速器" class="headerlink" title="白鲸加速器"></a>白鲸加速器</h1><p><a href="https://m.bjch110.com/">白鲸加速器 - 永远能连上的VPN (bjch110.com)</a></p><p>这个加速器其实也还可以，平时如果是访问 GitHub 的话，基本可以满足，然后可以看看推特，但是网速有些慢，看不了电报里面的东西。</p><p><strong>最重要的是现在是免费的，而且一个设备可以注册两个账号，然后一个账号可以使用一个月，邀请人可以增加时长，所以我现在已经可以免费使用一年了。</strong></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-09-57-Snipaste_2022-09-03_21-09-34.png"></p><h1 id="安易加速器"><a href="#安易加速器" class="headerlink" title="安易加速器"></a>安易加速器</h1><p><a href="https://www.anyi8.com/#feature">安易加速器 - 最稳定安全易用的高速VPN (anyi8.com)</a></p><p>这个加速器速度快，但是只能免费使用 10 天，但是不知道一个设备可以创建几个账号。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-10-28-Snipaste_2022-09-03_21-10-21.png"></p><h1 id="快连vpn"><a href="#快连vpn" class="headerlink" title="快连vpn"></a>快连vpn</h1><p>  <a href="https://letsvpn.world/?hl=zh">快连VPN 官方网站</a></p><p>这个加速器，感觉速度很快，但是之前有免费使用的机会，现在没有了。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-48-00-1.jpg"></p><h1 id="V2云加速"><a href="#V2云加速" class="headerlink" title="V2云加速"></a>V2云加速</h1><p>  <a href="https://www.v2board.co/#/dashboard">首页 | V2云加速 (v2board.co)</a></p><p>这个没有使用过，所以不知道速度怎么样，但是感觉应该还不错，而且价格也不是很贵。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-55-45-Snipaste_2022-09-03_21-55-36.png"></p><h1 id="Rrabits-Cloudgeek"><a href="#Rrabits-Cloudgeek" class="headerlink" title="Rrabits Cloudgeek"></a>Rrabits Cloudgeek</h1><p><a href="https://cloud.rrabits.com/">Rrabits Cloudgeek</a></p><p>这个VPN价格也不是很贵，而且它的特点是可以按照流量进行购买。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-59-10-Snipaste_2022-09-03_21-59-01.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-59-48-Snipaste_2022-09-03_21-59-37.png"></p><h1 id="起飞VPN"><a href="#起飞VPN" class="headerlink" title="起飞VPN"></a>起飞VPN</h1><h1 id="老王VPN"><a href="#老王VPN" class="headerlink" title="老王VPN"></a>老王VPN</h1><h1 id="推荐的几个VPN"><a href="#推荐的几个VPN" class="headerlink" title="推荐的几个VPN"></a>推荐的几个VPN</h1><p><a href="https://zh.vpnmentor.com/greatvpn/?keyword=+vpn&amp;geo=200&amp;device=&amp;ad=&amp;cq_src=google_ads&amp;cq_cmp=335155063&amp;cq_term=+vpn&amp;cq_plac=&amp;cq_net=o&amp;cq_plt=gp&amp;adid=75728921972514&amp;msclkid=08220a974afd180ab6bd6984182ccdf5&amp;utm_source=bing&amp;utm_medium=cpc&amp;utm_campaign=B_ROW_ZH_ZH_VPN&amp;utm_term=+vpn&amp;utm_content=vpn%20%5Bphrase%5D">九月 2022年5月5大实至名归的最佳 VPN</a></p><p>这几个 VPN 应该都是国外的，速度比较快，但是价格比较高，但是支持30天退款，所以之后如果想使用的话，可以试试。</p><h1 id="连接VPN的几个常用软件"><a href="#连接VPN的几个常用软件" class="headerlink" title="连接VPN的几个常用软件"></a>连接VPN的几个常用软件</h1><ul><li><p>Clash</p></li><li><p>Shadowrocket</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window10设置开机自启应用</title>
      <link href="/2022/09/03/window10-she-zhi-kai-ji-zi-qi-ying-yong/"/>
      <url>/2022/09/03/window10-she-zhi-kai-ji-zi-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-设置软件开机禁止自启动"><a href="#1-设置软件开机禁止自启动" class="headerlink" title="1. 设置软件开机禁止自启动"></a>1. 设置软件开机禁止自启动</h1><p>1.1 右键开始按钮，在弹出的窗口中，选择 “任务管理器”；</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-20-32-54-Snipaste_2022-09-03_20-32-12.png"></p><p>1.2 如果是精简窗口，点击<strong>详细信息</strong></p><p><img src="https://pic4.zhimg.com/80/v2-61514e608199a8c66a7645f724a33343_1440w.jpg"></p><p>1.3 点击&nbsp;<strong>启动</strong></p><p><img src="https://pic1.zhimg.com/80/v2-760f72c04b58a013052260556f470534_1440w.jpg"></p><p>1.4 在启动标签，选中要启动或者禁止启动的应用。</p><p><img src="https://pic3.zhimg.com/80/v2-9dd9a99536e532868f05e0745fdbd86a_1440w.jpg"></p><h1 id="2-设置未在任务管理器中的软件开机自启动"><a href="#2-设置未在任务管理器中的软件开机自启动" class="headerlink" title="2.设置未在任务管理器中的软件开机自启动"></a>2.设置未在任务管理器中的软件开机自启动</h1><p>2.1 win+R 调出<strong>运行</strong>窗口，然后输入&nbsp;<em>shell:startup</em>，按enter键</p><img src="https://pic2.zhimg.com/80/v2-93590ace5d265d54d5e7069a3070d13d_1440w.jpg" title="" alt="" data-align="inline"><p>2.2 将要开机启动的程序快捷方式拖到弹出的文件夹中</p><p><img src="https://pic2.zhimg.com/80/v2-8c0a1c7c2aafa9ff3228a1f129fe40f5_1440w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java小知识</title>
      <link href="/2022/09/02/java-xiao-zhi-shi/"/>
      <url>/2022/09/02/java-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h1><p>在学习 Lambda 表达式时，我们提到如果接口中只有一个抽象方法（可以包含多个默认方法或多个 static 方法），那么该接口就是函数式接口。@FunctionalInterface 就是用来指定某个接口必须是函数式接口，所以 @FunInterface 只能修饰接口，不能修饰其它程序元素。</p><h2 id="函数式接口就是为-Java-8-的-Lambda-表达式准备的，Java-8-允许使用-Lambda-表达式创建函数式接口的实例，因此-Java-8-专门增加了-FunctionalInterface。"><a href="#函数式接口就是为-Java-8-的-Lambda-表达式准备的，Java-8-允许使用-Lambda-表达式创建函数式接口的实例，因此-Java-8-专门增加了-FunctionalInterface。" class="headerlink" title="函数式接口就是为&nbsp;Java&nbsp;8 的 Lambda 表达式准备的，Java 8 允许使用 Lambda 表达式创建函数式接口的实例，因此 Java 8 专门增加了 @FunctionalInterface。"></a>函数式接口就是为&nbsp;<a href="http://c.biancheng.net/java/">Java</a>&nbsp;8 的 Lambda 表达式准备的，Java 8 允许使用 Lambda 表达式创建函数式接口的实例，因此 Java 8 专门增加了 @FunctionalInterface。</h2><p>例如，如下程序使用 @FunctionalInterface 修饰了函数式接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FunInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C语言中文网"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我正在学习C语言中文网Java教程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只定义一个抽象方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译上面程序，可能丝毫看不出程序中的 @FunctionalInterface 有何作用，因为 @FunctionalInterface 注解的作用只是告诉编译器检查这个接口，保证该接口只能包含一个抽象方法，否则就会编译出错。  </p><p>@FunctionalInterface 注解主要是帮助程序员避免一些低级错误，例如，在上面的 FunInterface 接口中再增加一个抽象方法 abc()，编译程序时将出现如下错误提示：</p><p><code>“@FunctionInterface”批注无效；FunInterface不是functional接口</code></p><h2 id="Runnable-接口为函数式接口"><a href="#Runnable-接口为函数式接口" class="headerlink" title="Runnable 接口为函数式接口"></a>Runnable 接口为函数式接口</h2><p>使用 lambda 创建线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 零碎知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发学习</title>
      <link href="/2022/09/02/java-bing-fa-xue-xi/"/>
      <url>/2022/09/02/java-bing-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-并发编程"><a href="#java-并发编程" class="headerlink" title="java 并发编程"></a>java 并发编程</h1><h2 id="1-1-进程和线程"><a href="#1-1-进程和线程" class="headerlink" title="1.1 进程和线程"></a>1.1 进程和线程</h2><p><strong>进程</strong></p><ul><li><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</p></li><li><p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。<br>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p></li></ul><p><strong>线程</strong></p><ul><li><p>一个进程之内可以分为一到多个线程。</p></li><li><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p></li><li><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</p></li></ul><p><strong>对比</strong></p><ul><li><p>进程是相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p></li><li><p>进程间通信复杂</p><ul><li><p>同一台计算机的进程通信成为 IPC (Inter-process communication)</p></li><li><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</p></li></ul></li><li><p>线程通信相对简单，因为他们共享进程内的内存，多个线程可以访问同一个共享变量</p></li><li><p>线程更轻量，线程上下文切换成本一般要比进程上下文低</p></li></ul><h2 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h2><ul><li><p>并发 (concurrent) 是同一时间应对多件事情的能力</p></li><li><p>并行 (paraller) 是同一时间动手做多件事情的能力</p></li></ul><h2 id="1-3-同步与异步"><a href="#1-3-同步与异步" class="headerlink" title="1.3 同步与异步"></a>1.3 同步与异步</h2><p><strong>从方法调用的角度来讲</strong></p><ul><li><p>同步：需要等待结果返回</p></li><li><p>异步：不需要等待结果返回</p></li></ul><p>注意：同步在多线程中还有另外一层意思，是让多个线程步调一致</p><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p></li></ol><ul><li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</p></li><li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p></li></ul><ol start="3"><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="2-1-创建和运行线程"><a href="#2-1-创建和运行线程" class="headerlink" title="2.1 创建和运行线程"></a>2.1 创建和运行线程</h2><p><strong>方法一，直接使用 Thread</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建线程对象</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 要执行的任务</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 启动线程</span>t<span class="token punctuation">.</span>start<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 构造方法的参数是给线程指定名字，推荐</span><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token comment">// run 方法内实现了要执行的任务</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法二，使用 Runnable 配合 Thread</strong></p><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li><p>Thread 代表线程</p></li><li><p>Runnable 可运行的任务（线程要执行的代码）</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 要执行的任务</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 创建线程对象</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> runnable <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动线程</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建任务对象</span><span class="token class-name">Runnable</span> task2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task2<span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Java 8 以后可以使用 lambda 精简代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建任务对象</span><span class="token class-name">Runnable</span> task2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task2<span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>原理之 Thread 与 Runnable 的关系<br>分析 Thread 的源码，理清它与 Runnable 的关系</li><li>小结<br>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><p><strong>方法三，FutureTask 配合 Thread</strong></p><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建任务对象</span><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> task3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task3<span class="token punctuation">,</span> <span class="token string">"t3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><span class="token class-name">Integer</span> result <span class="token operator">=</span> task3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"结果是:{}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">19:22:27 [t3] c.ThreadStarter - hello19:22:27 [main] c.ThreadStarter - 结果是:100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-观察多个线程同时运行"><a href="#2-2-观察多个线程同时运行" class="headerlink" title="2.2 观察多个线程同时运行"></a>2.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li><p>交替执行</p></li><li><p>谁先谁后，不由我们控制</p></li></ul><h2 id="2-3-查看进程线程的方法"><a href="#2-3-查看进程线程的方法" class="headerlink" title="2.3 查看进程线程的方法"></a>2.3 查看进程线程的方法</h2><p>windows</p><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><p>linux</p><ul><li><p>ps -fe 查看所有进程</p></li><li><p>ps -fT -p 查看某个进程（PID）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p 查看某个进程（PID）的所有线程</p></li></ul><p>Java</p><ul><li><p>jps 命令查看所有 Java 进程</p></li><li><p>jstack 查看某个 Java 进程（PID）的所有线程状态</p></li><li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p></li></ul><p>jconsole 远程监控配置</p><ul><li>需要以如下方式运行你的 java 类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">java <span class="token operator">-</span><span class="token class-name">Djava</span><span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span>hostname<span class="token operator">=</span>`ip地址` <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote<span class="token punctuation">.</span>port<span class="token operator">=</span>`连接端口` <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote<span class="token punctuation">.</span>ssl<span class="token operator">=</span>是否安全连接 <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote<span class="token punctuation">.</span>authenticate<span class="token operator">=</span>是否认证 java类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>修改 /etc/hosts 文件将 127.0.0.1 映射至主机名</li></ul><p>如果要认证访问，还需要做如下步骤</p><ul><li><p>复制 jmxremote.password 文件</p></li><li><p>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</p></li><li><p>连接时填入 controlRole（用户名），R&amp;D（密码）</p></li></ul><h2 id="2-4-原理–线程运行"><a href="#2-4-原理–线程运行" class="headerlink" title="2.4 原理–线程运行"></a>2.4 原理–线程运行</h2><p><strong>栈与栈帧</strong></p><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p><strong>线程上下文切换（Thread Context Switch）</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li><p>线程的 cpu 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p></li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），<strong>它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</strong>。</p><h1 id="Java线程常用方法"><a href="#Java线程常用方法" class="headerlink" title="Java线程常用方法"></a>Java线程常用方法</h1><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th><th>注意</th></tr></thead><tbody><tr><td>start()</td><td></td><td>启动一个新线程，在新的线程中运行 run 方法中的代码</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻&nbsp;运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现&nbsp;IllegalThreadStateException</td></tr><tr><td>run()</td><td></td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象,来覆盖默认行为</td></tr><tr><td>join()</td><td></td><td>等待线程运行结束</td><td>用于进行线程的同步操作</td></tr><tr><td>join(long n)</td><td></td><td>等待线程运行结束,最多等待 n</td><td></td></tr><tr><td>getId()</td><td></td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>getName()</td><td></td><td>获取线程名</td><td></td></tr><tr><td>setName(String)</td><td></td><td>修改线程名</td><td></td></tr><tr><td>getPriority()</td><td></td><td>获取线程优先级</td><td>默认为 5 ，java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率。但不代表线程优先级高的一定能优先执行，具体看操作系统的调度。</td></tr><tr><td>getState()</td><td></td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：</td></tr><tr><td><br>NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td><td></td><td></td><td></td></tr><tr><td>isInterrupted()</td><td></td><td>判断是否被打&nbsp;断</td><td>不会清除 打断标记</td></tr><tr><td>isAlive()</td><td></td><td>线程是否存活&nbsp;（还没有运行完毕）</td><td></td></tr><tr><td>interrupt()</td><td></td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置打断标记</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是否被打断</td><td>否被打断 会清除 打断标记</td></tr><tr><td>currentThread()</td><td>static</td><td>获取当前正在执行的线程</td><td></td></tr><tr><td>sleep(long n)</td><td>static</td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu的时间片给其它线程</td><td></td></tr><tr><td>yield()</td><td>static</td><td>提示线程调度器让出当前线程对CPU的使用</td><td>主要是为了测试和调试</td></tr></tbody></table><h2 id="常用方法说明"><a href="#常用方法说明" class="headerlink" title="常用方法说明"></a>常用方法说明</h2><h3 id="start-run"><a href="#start-run" class="headerlink" title="start / run"></a>start / run</h3><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><h3 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep / yield"></a>sleep / yield</h3><p><strong>sleep</strong></p><ul><li><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p></li><li><p>. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ul><p><strong>yield</strong></p><ul><li><p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li></ul><p><strong>线程优先级</strong></p><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><strong>为什么需要 join</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"结果为: %d \n"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ul><li><p>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10</p></li><li><p>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</p></li></ul><p>添加 <strong>t1.join()</strong> 后，输出 10</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li><p>需要等待结果返回，才能继续运行就是同步</p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-14-34-54-Snipaste_2022-09-04_14-34-37.png"></p><h3 id="有时效的-join"><a href="#有时效的-join" class="headerlink" title="有时效的 join"></a>有时效的 join</h3><p>可以设置等待的时间，时间结束后，不再等待。</p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p><strong>打断 sleep，wait，join 的线程</strong></p><p>这几个方法都会让线程进入阻塞状态</p><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> test1 <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出： False</p><p><strong>打断正常运行的线程</strong></p><p>打断正常运行的线程, 不会清空打断状态</p><p>输出： True</p><h3 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a>模式之两阶段终止</h3><h3 id="打断-park-线程"><a href="#打断-park-线程" class="headerlink" title="打断 park 线程"></a>打断 park 线程</h3><p>打断 park 线程, 不会清空打断状态</p><p>可以使用 Thread.interrupted() 清除打断状态</p><h2 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h2><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>stop()</td><td></td><td>停止线程运行</td></tr><tr><td>suspend()</td><td></td><td>挂起（暂停）线程运行</td></tr><tr><td>resume()</td><td></td><td>恢复线程运行</td></tr></tbody></table><h2 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"开始运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"开始运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"运行结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"daemon"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置该线程为守护线程</span>t1<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"运行结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出<br>&nbsp;&nbsp;&nbsp;&nbsp;08:26:38.123 [main] c.TestDaemon - 开始运行…<br>&nbsp;&nbsp;&nbsp;&nbsp;08:26:38.213 [daemon] c.TestDaemon - 开始运行…<br>&nbsp;&nbsp;&nbsp;&nbsp;08:26:39.215 [main] c.TestDaemon - 运行结束…</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>垃圾回收器线程就是一种守护线程</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></li></ul><h1 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h1><p>这是从 操作系统 层面来描述的</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-14-52-58-Snipaste_2022-09-04_14-52-48.png"></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li><p>【阻塞状态】</p><ul><li><p>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</p></li><li><p>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</p></li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h1 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h1><p>这是从 Java API 层面来描述的</p><p>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-15-00-09-Snipaste_2022-09-04_15-00-02.png"></p><ul><li><p>NEW 线程刚被创建，但是还没有调用 start() 方法</p></li><li><p>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线阻塞，在 Java 里无法区分，仍然认为是可运行）</p></li><li><p>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</p></li><li><p>TERMINATED 当线程代码运行结束</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-15-08-29-Snipaste_2022-09-04_15-08-12.png"></p><h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-15-10-48-Snipaste_2022-09-04_15-10-39.png"></p><h2 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span> <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题分析：</p><p>java 中对静态变量的自增、自减并不是原子操作。</p><p><strong>i++</strong>:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getstatic i <span class="token comment">// 获取静态变量i的值</span>iconst_1 <span class="token comment">// 准备常量1</span>iadd <span class="token comment">// 自增</span>putstatic i <span class="token comment">// 将修改后的值存入静态变量i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>i–</strong>:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getstatic i <span class="token comment">// 获取静态变量i的值</span>iconst_1 <span class="token comment">// 准备常量1</span>isub <span class="token comment">// 自减</span>putstatic i <span class="token comment">// 将修改后的值存入静态变量i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><h2 id="临界区-Ctitical-Section"><a href="#临界区-Ctitical-Section" class="headerlink" title="临界区 Ctitical Section"></a>临界区 Ctitical Section</h2><ul><li><p>一个程序运行多个线程本身是没有问题的</p></li><li><p>问题出在多个线程访问共享资源</p><ul><li><p>多个线程读共享资源其实也没有问题</p></li><li><p>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p></li></ul></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 临界区</span><span class="token punctuation">{</span> counter<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 临界区</span><span class="token punctuation">{</span> counter<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h2><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><h2 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h2><p>应用之互斥</p><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li><p>阻塞式的解决方案：synchronized，Lock</p></li><li><p>非阻塞式的解决方案：原子变量</p></li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p><strong>注意</strong></p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p></li><li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span> <span class="token comment">// 线程1， 线程2(blocked)</span><span class="token punctuation">{</span> 临界区<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> room <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span> <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类比 房间 和 锁</strong></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-16-13-45-Snipaste_2022-09-04_16-12-49.png"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p><p>为了加深理解，请思考下面的问题</p><ul><li><p>如果把 synchronized(obj) 放在 for 循环的外面，如何理解？– 原子性</p></li><li><p>如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？– 锁对象</p></li><li><p>如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？– 锁对象</p></li></ul><h2 id="面对对象改进"><a href="#面对对象改进" class="headerlink" title="面对对象改进"></a>面对对象改进</h2><p><strong>将进行改变的变量和操作封装为一个对象，对对象的方法添加 synchronized</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Room</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> value<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> value<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法上的-synchronized"><a href="#方法上的-synchronized" class="headerlink" title="方法上的 synchronized"></a>方法上的 synchronized</h2><p><strong>成员方法：</strong></p><ul><li>相当于锁住了 这个实例对象 this</li></ul><p><strong>类方法：</strong></p><ul><li>锁住了 这个类对象 ，Test.class</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 等价于</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 等价于</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线程“八锁”"><a href="#线程“八锁”" class="headerlink" title="线程“八锁”"></a>线程“八锁”</h1><p>观察到底锁住的到底是 this 还是 class， 判断线程启动的顺序。</p><h1 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h1><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><p><strong>局部变量是否线程安全？</strong></p><ul><li><p>局部变量是线程安全的</p></li><li><p>但局部变量引用的对象则未必</p><ul><li><p>如果该对象没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果该对象逃离方法的作用范围，需要考虑线程安全</p></li></ul></li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>每一个线程都会有自己的栈帧，都会复制一份局部变量，所以不存在共享。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/05-11-21-08-Snipaste_2022-09-05_11-19-58.png"></p><h2 id="局部变量的引用"><a href="#局部变量的引用" class="headerlink" title="局部变量的引用"></a>局部变量的引用</h2><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/05-11-20-25-Snipaste_2022-09-05_11-19-48.png"></p><p>可以通过添加 private 或 final 提供对外的封闭</p><p><strong>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</strong></p><h1 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h1><ul><li><p>String</p></li><li><p>Integer</p></li><li><p>StringBuffer</p></li><li><p>Random</p></li><li><p>Vector</p></li><li><p>Hashtable</p></li><li><p>java.util.concurrent 包下的类</p></li></ul><p>这里说他们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。</p><ul><li><p>它们的每个方法是原子的</p></li><li><p>但注意它们多个方法的组合不是原子的</p></li></ul><h2 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h2><p>String / Integer</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pop.xml文件出现错误</title>
      <link href="/2022/09/02/pop-xml-wen-jian-chu-xian-cuo-wu/"/>
      <url>/2022/09/02/pop-xml-wen-jian-chu-xian-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-Idea-创建-maven-项目时，"><a href="#使用-Idea-创建-maven-项目时，" class="headerlink" title="使用 Idea 创建 maven 项目时，"></a>使用 Idea 创建 maven 项目时，</h1><h2 id="出现‘artifactId‘-with-value-‘xxx‘-does-not-match-a-valid-id-pattern的解决方法"><a href="#出现‘artifactId‘-with-value-‘xxx‘-does-not-match-a-valid-id-pattern的解决方法" class="headerlink" title="出现‘artifactId‘ with value ‘xxx‘ does not match a valid id pattern的解决方法"></a>出现‘artifactId‘ with value ‘xxx‘ does not match a valid id pattern的解决方法</h2><p><img src="https://img-blog.csdnimg.cn/8a155171d5c4487cba9e22e2edc490fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56CB5Yac56CU56m25YOn,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>查看pom.xml文件下的配置<br>显示其<code>artifictid</code>这一行出了错误</p><p>错误原因是含有中文或者空格，因为识别不到</p><p>artifictid的正则表达式为<code>[A-Za-z0-9_\-.]</code></p><p>所以只需要改掉其中文或者空格就可成功</p><p><img src="https://img-blog.csdnimg.cn/09eecf7b960c42ac9c0f5b8ced5e7f67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56CB5Yac56CU56m25YOn,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript运算符</title>
      <link href="/2022/09/02/javascript-yun-suan-fu/"/>
      <url>/2022/09/02/javascript-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-运算符"><a href="#JavaScript-运算符" class="headerlink" title="JavaScript&nbsp;运算符"></a>JavaScript&nbsp;运算符</h1><hr><p><strong>运算符 = 用于赋值。</strong></p><p><strong>运算符 + 用于加值。</strong></p><hr><p>运算符 = 用于给 JavaScript 变量赋值。</p><p>算术运算符&nbsp;+&nbsp;用于把值加起来。</p><h2 id="JavaScript-算术运算符"><a href="#JavaScript-算术运算符" class="headerlink" title="JavaScript 算术运算符"></a>JavaScript 算术运算符</h2><p>+</p><p>-</p><p>*</p><p>/</p><p>%</p><p>++</p><p>–</p><h2 id="JavaScript-赋值运算符"><a href="#JavaScript-赋值运算符" class="headerlink" title="JavaScript 赋值运算符"></a>JavaScript 赋值运算符</h2><p>=</p><p>+=</p><p>-=</p><p>*=</p><p>/=</p><p>%=</p><h2 id="用于字符串的-运算符"><a href="#用于字符串的-运算符" class="headerlink" title="用于字符串的 + 运算符"></a>用于字符串的 + 运算符</h2><p>+运算符用于把文本值或字符串变量加起来（连接起来）。</p><p>如需把两个或多个字符串变量连接起来，请使用&nbsp;+&nbsp;运算符。</p><p><strong>规则</strong>:如果把数字与字符串相加，结果将成为字符串！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>1、字符串一个很能强大的数据类型；在执行加&nbsp;+&nbsp;时,将被加的对象统一处理为字符串。</p><p>2、bool 类型在与数字类型进行相加时，视为 0 或者 1 处理。</p><p>3、null 类型与数字类型进行累加时，视为 0 处理。</p><p>4、bool 类型与 null 类型进行累加时，视为其与整数类型累加处理。</p><p>5、undefined 除了与字符串进行累加时有效（undefined 视为字符串”undefined”处理），其他情况皆返回 NaN。</p><p>6、求模&nbsp;%&nbsp;运算，运算结果只取决于第一个数字的正负。</p><p>-12 % -8 = -4;<br>12 % -8 =  4;<br>-12 % 8 = -4;</p><p>7、查看 String 数据类型支持的方法和属性：</p><p>打开网页后 F12 进行开发调试环境，找到 console 标签页面，执行：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   str <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>点开列表下拉箭头即可:</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/12/30994114-FE40-416F-A993-F49210EF0374.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript字符串</title>
      <link href="/2022/09/01/javascript-zi-fu-chuan/"/>
      <url>/2022/09/01/javascript-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-字符串"><a href="#JavaScript-字符串" class="headerlink" title="JavaScript&nbsp;字符串"></a>JavaScript&nbsp;字符串</h1><hr><p>JavaScript 字符串用于存储和处理文本。</p><p>字符串可以是插入到引号中的任何字符。你可以使用单引号或双引号：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> carname <span class="token operator">=</span> <span class="token string">"Volvo XC60"</span><span class="token punctuation">;</span><span class="token keyword">var</span> carname <span class="token operator">=</span> <span class="token string">'Volvo XC60'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你可以使用索引位置来访问字符串中的每个字符：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> character <span class="token operator">=</span> carname<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>可以使用内置属性&nbsp;<strong>length</strong>&nbsp;来计算字符串的长度：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> txt <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sln <span class="token operator">=</span> txt<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>反斜杠是一个<strong>转义字符</strong>。 转义字符将特殊字符转换为字符串字符：</p><p>转义字符 () 可以用于转义撇号，换行，引号，等其他特殊字符。</p><p>下表中列举了在字符串中可以使用转义字符转义的特殊字符：</p><table><thead><tr><th>代码</th><th>输出</th></tr></thead><tbody><tr><td>'</td><td>单引号</td></tr><tr><td>"</td><td>双引号</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>tab(制表符)</td></tr><tr><td>\b</td><td>退格符</td></tr><tr><td>\f</td><td>换页符</td></tr></tbody></table><h2 id="字符串可以是对象"><a href="#字符串可以是对象" class="headerlink" title="字符串可以是对象"></a>字符串可以是对象</h2><p>通常， JavaScript 字符串是原始值，可以使用字符创建：&nbsp;<strong>var firstName = “John”</strong></p><p>但我们也可以使用 new 关键字将字符串定义为一个对象：&nbsp;<strong>var firstName = new String(“John”)</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> x <span class="token comment">// 返回 String</span><span class="token keyword">typeof</span> y <span class="token comment">// 返回 Object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span>             <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token comment">// 结果为 false，因为 x 是字符串，y 是对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>=== 为绝对相等，即数据类型与值都必须相等。</p><h2 id="字符串属性和方法"><a href="#字符串属性和方法" class="headerlink" title="字符串属性和方法"></a>字符串属性和方法</h2><p>原始值字符串，如 “John”, 没有属性和方法(因为他们不是对象)。</p><p>原始值可以使用 JavaScript 的属性和方法，因为 JavaScript 在执行方法和属性时可以把原始值当作对象。</p><p><strong>字符串方法我们将在下一章节中介绍。</strong></p><h2 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>返回创建字符串属性的函数</td></tr><tr><td>length</td><td>返回字符串的长度</td></tr><tr><td>prototype</td><td>允许您向对象添加属性和方法</td></tr></tbody></table><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>更多方法实例可以参见：<a href="https://www.runoob.com/jsref/jsref-obj-string.html">JavaScript String 对象</a>。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt()</td><td>返回指定索引位置的字符</td></tr><tr><td>charCodeAt()</td><td>返回指定索引位置字符的 Unicode 值</td></tr><tr><td>concat()</td><td>连接两个或多个字符串，返回连接后的字符串</td></tr><tr><td>fromCharCode()</td><td>将 Unicode 转换为字符串</td></tr><tr><td>indexOf()</td><td>返回字符串中检索指定字符第一次出现的位置</td></tr><tr><td>lastIndexOf()</td><td>返回字符串中检索指定字符最后一次出现的位置</td></tr><tr><td>localeCompare()</td><td>用本地特定的顺序来比较两个字符串</td></tr><tr><td>match()</td><td>找到一个或多个正则表达式的匹配</td></tr><tr><td>replace()</td><td>替换与正则表达式匹配的子串</td></tr><tr><td>search()</td><td>检索与正则表达式相匹配的值</td></tr><tr><td>slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分</td></tr><tr><td>split()</td><td>把字符串分割为子字符串数组</td></tr><tr><td>substr()</td><td>从起始索引号提取字符串中指定数目的字符</td></tr><tr><td>substring()</td><td>提取字符串中两个指定的索引号之间的字符</td></tr><tr><td>toLocaleLowerCase()</td><td>根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td></tr><tr><td>toLocaleUpperCase()</td><td>根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td></tr><tr><td>toLowerCase()</td><td>把字符串转换为小写</td></tr><tr><td>toString()</td><td>返回字符串对象值</td></tr><tr><td>toUpperCase()</td><td>把字符串转换为大写</td></tr><tr><td>trim()</td><td>移除字符串首尾空白</td></tr><tr><td>valueOf()</td><td>返回某个字符串对象的原始值</td></tr></tbody></table><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="JavaScript-与-区别"><a href="#JavaScript-与-区别" class="headerlink" title="JavaScript == 与 === 区别"></a>JavaScript == 与 === 区别</h2><p>1、对于 string、number 等基础类型，== 和 === 是有区别的</p><ul><li>a）不同类型间比较，== 之比较 “转化成同一类型后的值” 看 “值” 是否相等，=== 如果类型不同，其结果就是不等。</li><li>&nbsp;b）同类型比较，直接进行 “值” 比较，两者结果一样。</li></ul><p>2、对于 Array,Object 等高级类型，== 和 === 是没有区别的</p><p>进行 “指针地址” 比较</p><p>3、基础类型与高级类型，== 和 === 是有区别的</p><ul><li>a）对于 ==，将高级转化为基础类型，进行 “值” 比较</li><li>&nbsp;b）因为类型不同，=== 结果为 false</li></ul><p>4、!= 为 == 的非运算，!== 为 === 的非运算</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num<span class="token operator">=</span><span class="token number">1</span>；<span class="token keyword">var</span> str<span class="token operator">=</span><span class="token string">"1"</span>；<span class="token keyword">var</span> test<span class="token operator">=</span><span class="token number">1</span>；test <span class="token operator">==</span> num   <span class="token comment">//true　相同类型　相同值 </span>test <span class="token operator">===</span> num  <span class="token comment">//true　相同类型　相同值 </span>test <span class="token operator">!==</span> num  <span class="token comment">//false test与num类型相同，其值也相同,　非运算肯定是false </span>num <span class="token operator">==</span> str   <span class="token comment">//true 　把str转换为数字，检查其是否相等。 </span>num <span class="token operator">!=</span> str   <span class="token comment">//false  == 的 非运算 </span>num <span class="token operator">===</span> str  <span class="token comment">//false  类型不同，直接返回false </span>num <span class="token operator">!==</span> str  <span class="token comment">//true   num 与 str类型不同 意味着其两者不等　非运算自然是true啦</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件</title>
      <link href="/2022/09/01/javascript-shi-jian/"/>
      <url>/2022/09/01/javascript-shi-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-事件"><a href="#JavaScript-事件" class="headerlink" title="JavaScript&nbsp;事件"></a>JavaScript&nbsp;事件</h1><hr><p>HTML 事件是发生在 HTML 元素上的事情。</p><p>当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。</p><h2 id="HTML-事件"><a href="#HTML-事件" class="headerlink" title="HTML 事件"></a>HTML 事件</h2><p>HTML 事件可以是浏览器行为，也可以是用户行为。</p><p>以下是 HTML 事件的实例：</p><ul><li>HTML 页面完成加载</li><li>HTML input 字段改变时</li><li>HTML 按钮被点击</li></ul><p>通常，当事件发生时，你可以做些事情。</p><p>在事件触发时 JavaScript 可以执行一些代码。</p><p>HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加 HTML 元素。</p><p>单引号:</p><p>&lt;*some-HTML-element*&nbsp;*some-event*=**’*****JavaScript 代码*****’**&gt;</p><p>双引号:</p><p>&lt;*some-HTML-element*&nbsp;*some-event*=**”*****JavaScript 代码*****”**&gt;</p><p>在以下实例中，按钮元素中添加了 onclick 属性 (并加上代码):</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>现在的时间是?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常见的HTML事件"><a href="#常见的HTML事件" class="headerlink" title="常见的HTML事件"></a>常见的HTML事件</h2><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onchange</td><td>HTML 元素改变</td></tr><tr><td>onclick</td><td>用户点击 HTML 元素</td></tr><tr><td>onmouseover</td><td>鼠标指针移动到指定的元素上时发生</td></tr><tr><td>onmouseout</td><td>用户从一个 HTML 元素上移开鼠标时发生</td></tr><tr><td>onkeydown</td><td>用户按下键盘按键</td></tr><tr><td>onload</td><td>浏览器已完成页面的加载</td></tr></tbody></table><p>更多事件列表:&nbsp;<a href="https://www.runoob.com/jsref/dom-obj-event.html">JavaScript 参考手册 - HTML DOM 事件</a>。</p><h2 id="JavaScript-可以做什么"><a href="#JavaScript-可以做什么" class="headerlink" title="JavaScript 可以做什么?"></a>JavaScript 可以做什么?</h2><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p><ul><li>页面加载时触发事件</li><li>页面关闭时触发事件</li><li>用户点击按钮执行动作</li><li>验证用户输入内容的合法性</li><li>等等 …</li></ul><p>可以使用多种方法来执行 JavaScript 事件代码：</p><ul><li>HTML 事件属性可以直接执行 JavaScript 代码</li><li>HTML 事件属性可以调用 JavaScript 函数</li><li>你可以为 HTML 元素指定自己的事件处理程序</li><li>你可以阻止事件的发生。</li><li>等等 …</li></ul><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>注意，当在 JS 文件中为相关元素设置事件时，其写法与 HTML 事件属性写法相同，例如：</p><p><code>&lt;button id="test" onclick="changeContent()"&gt;更换内容&lt;/button&gt;</code></p><p>在 JS 中则需要这样写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> test <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">changeContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：在为元素添加事件句柄或者删除元素事件句柄的过程中，不要将 event 参数设置为 onclick，而必须写成 click，去掉事件名称中的 on 即可。</p><p>添加事件句柄函数原型:</p><p>element.addEventListener(event, function, [useCapture])</p><p>删除事件句柄的函数原型:</p><p>element.removeEventListener(event, function, [useCapture])</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"test"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"提交"</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> test <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       test<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span>myfun2<span class="token punctuation">)</span><span class="token punctuation">;</span>       test<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span>myfun1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">myfun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你好1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">myfun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"你好2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不推荐使用 HTML 元素中可以添加事件属性 的方式来添加属性。</p><p>例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token string">"getElementById('demo').innerHTML=Date()"</span><span class="token operator">&gt;</span>现在的时间是<span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为遵从<strong>“高内聚，低耦合”</strong>的编程原则。</p><p>高内聚是说模块内部要高度聚合，低耦合是说模块与模块之间的藕合度要尽量低。前者是说模块内部的关系，后者是说模块与模块间的关系。</p><p>很形象的比拟：<strong>严于律己，宽以待人。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript作用域</title>
      <link href="/2022/09/01/javascript-zuo-yong-yu/"/>
      <url>/2022/09/01/javascript-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-作用域"><a href="#JavaScript-作用域" class="headerlink" title="JavaScript&nbsp;作用域"></a>JavaScript&nbsp;作用域</h1><p>作用域是可访问变量的集合。</p><p>在 JavaScript 中, 对象和函数同样也是变量。</p><p><strong>在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。</strong></p><p>JavaScript 函数作用域: 作用域在函数内修改。</p><h2 id="JavaScript-局部作用域"><a href="#JavaScript-局部作用域" class="headerlink" title="JavaScript 局部作用域"></a>JavaScript 局部作用域</h2><p>变量在函数内声明，变量为局部变量，具有局部作用域。</p><p>局部变量：只能在函数内部访问。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 此处不能调用 carName 变量</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> carName <span class="token operator">=</span> <span class="token string">"Volvo"</span><span class="token punctuation">;</span>    <span class="token comment">// 函数内可调用 carName 变量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。</p><p>局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。</p><h2 id="JavaScript-全局变量"><a href="#JavaScript-全局变量" class="headerlink" title="JavaScript 全局变量"></a>JavaScript 全局变量</h2><p>变量在函数外定义，即为全局变量。</p><p>全局变量有&nbsp;<strong>全局作用域</strong>: 网页中所有脚本和函数均可使用。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> carName <span class="token operator">=</span> <span class="token string">" Volvo"</span><span class="token punctuation">;</span> <span class="token comment">// 此处可调用 carName 变量</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 函数内可调用 carName 变量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</p><p>以下实例中 carName 在函数内，但是为全局变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 此处可调用 carName 变量</span> <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    carName <span class="token operator">=</span> <span class="token string">"Volvo"</span><span class="token punctuation">;</span>    <span class="token comment">// 此处可调用 carName 变量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JavaScript-变量生命周期"><a href="#JavaScript-变量生命周期" class="headerlink" title="JavaScript 变量生命周期"></a>JavaScript 变量生命周期</h2><p>JavaScript 变量生命周期在它声明时初始化。</p><p>局部变量在函数执行完毕后销毁。</p><p>全局变量在页面关闭后销毁。</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数参数只在函数内起作用，是局部变量。</p><h2 id="HTML-中的全局变量"><a href="#HTML-中的全局变量" class="headerlink" title="HTML 中的全局变量"></a>HTML 中的全局变量</h2><p>在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//此处可使用 window.carName</span> <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    carName <span class="token operator">=</span> <span class="token string">"Volvo"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你的全局变量，或者函数，可以覆盖 window 对象的变量或者函数。<br>局部变量，包括 window 对象可以覆盖全局变量和函数。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>局部变量：在函数中通过var声明的变量。</p><p>全局变量：在函数外通过var声明的变量。</p><p>没有声明就使用的变量，默认为全局变量，不论这个变量在哪被使用。</p><p>在 ES6 中，提供了&nbsp;let&nbsp;关键字和&nbsp;const&nbsp;关键字。</p><p>let 的声明方式与 var 相同，用 let 来代替 var 来声明变量，就可以把变量限制在当前代码块中。</p><p>使用 const 声明的是常量，其值一旦被设定便不可被更改。</p><p>let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。</p><p>let 和 var 的区别代码实例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">varTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 同样的变量!</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>  <span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">letTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 不同的变量</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>  <span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript函数</title>
      <link href="/2022/09/01/javascript-han-shu/"/>
      <url>/2022/09/01/javascript-han-shu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript&nbsp;函数"></a>JavaScript&nbsp;函数</h1><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>测试实例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>点我<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JavaScript-函数语法"><a href="#JavaScript-函数语法" class="headerlink" title="JavaScript 函数语法"></a>JavaScript 函数语法</h2><p>函数就是包裹在花括号中的代码块，前面使用了关键词 function：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">functionname</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 执行代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当调用该函数时，会执行函数内的代码。</p><p>可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。</p><p><strong>JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。</strong></p><h2 id="调用带参数的函数"><a href="#调用带参数的函数" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h2><p>在调用函数时，您可以向其传递值，这些值被称为参数。</p><p>这些参数可以在函数中使用。</p><p>您可以发送任意多的参数，由逗号 (,) 分隔：</p><blockquote><p>myFunction(<em>argument1,argument2</em>)</p></blockquote><p>当您声明函数时，请把参数作为变量来声明：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token parameter">var1<span class="token punctuation">,</span>var2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>变量和参数必须以一致的顺序出现。第一个变量就是第一个被传递的参数的给定的值，以此类推。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>点击这个按钮，来调用带参数的函数。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token string">'Harry Potter'</span><span class="token punctuation">,</span><span class="token string">'Wizard'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>点击这里<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>job</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Welcome "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", the "</span> <span class="token operator">+</span> job<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="带有返回值的函数"><a href="#带有返回值的函数" class="headerlink" title="带有返回值的函数"></a>带有返回值的函数</h2><p>有时，我们会希望函数将值返回调用它的地方。</p><p>通过使用 return 语句就可以实现。</p><p>在使用 return 语句时，函数会停止执行，并返回指定的值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> x<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>&nbsp;整个 JavaScript 并不会停止执行，仅仅是函数。JavaScript 将继续执行代码，从调用函数的地方。</p><p>函数调用将被返回值取代：</p><blockquote><p>var myVar=myFunction();</p></blockquote><h2 id="局部-JavaScript-变量"><a href="#局部-JavaScript-变量" class="headerlink" title="局部 JavaScript 变量"></a>局部 JavaScript 变量</h2><p>在 JavaScript 函数内部声明的变量（使用 var）是<em>局部</em>变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。</p><p>您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。</p><p>只要函数运行完毕，本地变量就会被删除。</p><h2 id="全局-JavaScript-变量"><a href="#全局-JavaScript-变量" class="headerlink" title="全局 JavaScript 变量"></a>全局 JavaScript 变量</h2><p>在函数外声明的变量是<em>全局</em>变量，网页上的所有脚本和函数都能访问它。</p><h2 id="JavaScript-变量的生存期"><a href="#JavaScript-变量的生存期" class="headerlink" title="JavaScript 变量的生存期"></a>JavaScript 变量的生存期</h2><p>JavaScript 变量的生命期从它们被声明的时间开始。</p><p>局部变量会在函数运行以后被删除。</p><p>全局变量会在页面关闭后被删除。</p><h2 id="向未声明的-JavaScript-变量分配值"><a href="#向未声明的-JavaScript-变量分配值" class="headerlink" title="向未声明的 JavaScript 变量分配值"></a>向未声明的 JavaScript 变量分配值</h2><p>如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。</p><p>这条语句：</p><blockquote><p>carname=”Volvo”;</p></blockquote><p>将声明 window 的一个属性 carname。</p><p>非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> var1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 不可配置全局属性</span>var2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 没有使用 var 声明，可配置全局属性</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><span class="token keyword">delete</span> var1<span class="token punctuation">;</span> <span class="token comment">// false 无法删除</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1</span><span class="token keyword">delete</span> var2<span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">delete</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 已经删除 报错变量未定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript对象</title>
      <link href="/2022/09/01/javascript-dui-xiang/"/>
      <url>/2022/09/01/javascript-dui-xiang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript&nbsp;对象"></a>JavaScript&nbsp;对象</h1><p>JavaScript 对象是拥有属性和方法的数据。</p><h2 id="真实生活中的对象，属性和方法"><a href="#真实生活中的对象，属性和方法" class="headerlink" title="真实生活中的对象，属性和方法"></a>真实生活中的对象，属性和方法</h2><p>真实生活中，一辆汽车是一个对象。</p><p>对象有它的属性，如重量和颜色等，方法有启动停止等:</p><h2 id="JavaScript-对象-1"><a href="#JavaScript-对象-1" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>在 JavaScript中，几乎所有的事物都是对象。</p><p>JavaScript 对象是变量的容器。</p><h2 id="对象定义"><a href="#对象定义" class="headerlink" title="对象定义"></a>对象定义</h2><p>你可以使用字符来定义和创建 JavaScript 对象:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span>    <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span>    <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><p>可以说 “JavaScript 对象是变量的容器”。</p><p>但是，我们通常认为 “JavaScript 对象是键值对的容器”。</p><p>键值对通常写法为&nbsp;<strong>name : value</strong>&nbsp;(键与值以冒号分割)。</p><p>键值对在 JavaScript 对象通常称为&nbsp;<strong>对象属性</strong>。</p><h2 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h2><p>你可以通过两种方式访问对象属性:</p><blockquote><p>person.lastName;</p><p>person[“lastName”];</p></blockquote><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><p>对象的方法定义了一个函数，并作为对象的属性存储。</p><p>对象方法通过添加 () 调用 (作为一个函数)。</p><h2 id="访问对象方法"><a href="#访问对象方法" class="headerlink" title="访问对象方法"></a>访问对象方法</h2><p>你可以使用以下语法创建对象方法：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function-variable function">methodName</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 代码 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你可以使用以下语法访问对象方法：</p><blockquote><p>objectName.methodName()</p></blockquote><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>菜鸟教程(runoob.com)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>创建 JavaScript 对象。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">firstName</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastName</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token literal-property property">eyeColor</span><span class="token operator">:</span><span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span>    person<span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" 现在 "</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token string">" 岁."</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数属性作为一个方法访问，属性访问"><a href="#函数属性作为一个方法访问，属性访问" class="headerlink" title="函数属性作为一个方法访问，属性访问"></a>函数属性作为一个方法访问，属性访问</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>菜鸟教程(runoob.com)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>创建和使用对象方法。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>对象方法是一个函数定义,并作为一个属性值存储。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token literal-property property">firstName</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>    <span class="token literal-property property">lastName</span> <span class="token operator">:</span> <span class="token string">"Doe"</span><span class="token punctuation">,</span>    <span class="token literal-property property">id</span> <span class="token operator">:</span> <span class="token number">5566</span><span class="token punctuation">,</span>    <span class="token function-variable function">fullName</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"不加括号输出函数表达式："</span>  <span class="token operator">+</span> person<span class="token punctuation">.</span>fullName<span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"加括号输出函数执行结果："</span>  <span class="token operator">+</span>  person<span class="token punctuation">.</span><span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据类型</title>
      <link href="/2022/09/01/javascript-shu-ju-lei-xing/"/>
      <url>/2022/09/01/javascript-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript&nbsp;数据类型"></a>JavaScript&nbsp;数据类型</h1><p>**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</p><p><strong>注</strong>：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p><p><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/08/Javascript-DataType.png"></p><h2 id="JavaScript-拥有动态类型"><a href="#JavaScript-拥有动态类型" class="headerlink" title="JavaScript 拥有动态类型"></a>JavaScript 拥有动态类型</h2><p>JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型：</p><blockquote><p>var x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // x 为 undefined<br>var x = 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 现在 x 为数字<br>var x = “John”;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 现在 x 为字符串</p></blockquote><p>变量的数据类型可以使用&nbsp;typeof&nbsp;操作符来查看：</p><blockquote><p>typeof&nbsp;“John”&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 返回 string<br>typeof&nbsp;3.14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 返回 number<br>typeof&nbsp;false&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 返回 boolean<br>typeof&nbsp;[1,2,3,4]&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 返回 object<br>typeof&nbsp;{name:’John’,&nbsp;age:34}&nbsp;// 返回 object</p></blockquote><h2 id="JavaScript-字符串"><a href="#JavaScript-字符串" class="headerlink" title="JavaScript 字符串"></a>JavaScript 字符串</h2><p>字符串是存储字符（比如 “Bill Gates”）的变量。</p><p>字符串可以是引号中的任意文本。您可以使用单引号或双引号：</p><blockquote><p>var carname=”Volvo XC60”;<br>var carname=’Volvo XC60’;</p></blockquote><h2 id="JavaScript-数字"><a href="#JavaScript-数字" class="headerlink" title="JavaScript 数字"></a>JavaScript 数字</h2><p>JavaScript 只有一种数字类型。数字可以带小数点，也可以不带：</p><blockquote><p>var x1=34.00;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使用小数点来写<br>var x2=34;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //不使用小数点来写</p></blockquote><p>极大或极小的数字可以通过科学（指数）计数法来书写：</p><blockquote><p>var y=123e5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 12300000<br>var z=123e-5;&nbsp;&nbsp;&nbsp;&nbsp; // 0.00123</p></blockquote><h2 id="JavaScript-布尔"><a href="#JavaScript-布尔" class="headerlink" title="JavaScript 布尔"></a>JavaScript 布尔</h2><p>布尔（逻辑）只能有两个值：true 或 false。</p><h2 id="JavaScript-数组"><a href="#JavaScript-数组" class="headerlink" title="JavaScript 数组"></a>JavaScript 数组</h2><p>下面的代码创建名为 cars 的数组：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> cars<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Saab"</span><span class="token punctuation">;</span>cars<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Volvo"</span><span class="token punctuation">;</span>cars<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"BMW"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者 (condensed array):</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> cars<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"Saab"</span><span class="token punctuation">,</span><span class="token string">"Volvo"</span><span class="token punctuation">,</span><span class="token string">"BMW"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者 (literal array):</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> cars<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"Saab"</span><span class="token punctuation">,</span><span class="token string">"Volvo"</span><span class="token punctuation">,</span><span class="token string">"BMW"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h2><p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> person<span class="token operator">=</span><span class="token punctuation">{</span><span class="token literal-property property">firstname</span><span class="token operator">:</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token literal-property property">lastname</span><span class="token operator">:</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> <span class="token literal-property property">id</span><span class="token operator">:</span><span class="token number">5566</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> person<span class="token operator">=</span><span class="token punctuation">{</span><span class="token literal-property property">firstname</span> <span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span><span class="token literal-property property">lastname</span>  <span class="token operator">:</span> <span class="token string">"Doe"</span><span class="token punctuation">,</span><span class="token literal-property property">id</span>        <span class="token operator">:</span>  <span class="token number">5566</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象属性有两种寻址方式：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">name<span class="token operator">=</span>person<span class="token punctuation">.</span>lastname<span class="token punctuation">;</span>name<span class="token operator">=</span>person<span class="token punctuation">[</span><span class="token string">"lastname"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h2><p>Undefined 这个值表示变量不含有值。</p><p>可以通过将变量的值设置为 null 来清空变量。</p><h2 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h2><p>当您声明新变量时，可以使用关键词 “new” 来声明其类型：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> carname<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">;</span><span class="token keyword">var</span> x<span class="token operator">=</span>      <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">;</span><span class="token keyword">var</span> y<span class="token operator">=</span>      <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">;</span><span class="token keyword">var</span> cars<span class="token operator">=</span>   <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">;</span><span class="token keyword">var</span> person<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="最常用的对象创建方式"><a href="#最常用的对象创建方式" class="headerlink" title="最常用的对象创建方式"></a>最常用的对象创建方式</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"张思"</span><span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>    obj<span class="token punctuation">.</span><span class="token function-variable function">firstF</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    obj<span class="token punctuation">.</span><span class="token function-variable function">secondF</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> one<span class="token operator">=</span><span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用输出</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"张思"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">firstF</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">secondF</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> one<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token comment">// 调用输出</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>one<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基本类型的变量是存放在栈内存（Stack）里的</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/3834493100-57c3ff4a5dac7_articlex.png"></p><p><strong>引用类型的值是保存在堆内存（Heap）中的对象（Object）</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/05/3309698956-57c41a89cddc7_articlex.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript变量</title>
      <link href="/2022/08/31/javascript-bian-liang/"/>
      <url>/2022/08/31/javascript-bian-liang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript&nbsp;变量"></a>JavaScript&nbsp;变量</h1><p>变量是用于存储信息的”容器”。</p><h2 id="JavaScript-变量-1"><a href="#JavaScript-变量-1" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h2><p>与代数一样，JavaScript 变量可用于存放值（比如 x=5）和表达式（比如 z=x+y）。</p><p>变量可以使用短名称（比如 x 和 y），也可以使用描述性更好的名称（比如 age, sum, totalvolume）。</p><ul><li>变量必须以字母开头</li><li>变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）</li><li>变量名称对大小写敏感（y 和 Y 是不同的变量）</li></ul><h2 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><p>JavaScript 变量还能保存其他数据类型，比如文本值 (name=”Bill Gates”)。</p><p>在 JavaScript 中，类似 “Bill Gates” 这样一条文本被称为字符串。</p><p>JavaScript 变量有很多种类型，但是现在，我们只关注数字和字符串。</p><p>当您向变量分配文本值时，应该用双引号或单引号包围这个值。</p><p>当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</p><h2 id="声明（创建）-JavaScript-变量"><a href="#声明（创建）-JavaScript-变量" class="headerlink" title="声明（创建） JavaScript 变量"></a>声明（创建） JavaScript 变量</h2><p>在 JavaScript 中创建变量通常称为”声明”变量。</p><p>我们使用 var 关键词来声明变量：</p><blockquote><p>var carname;</p></blockquote><p>变量声明之后，该变量是空的（它没有值）。</p><p>如需向变量赋值，请使用等号：</p><blockquote><p>carname=”Volvo”;</p></blockquote><p>不过，您也可以在声明变量时对其赋值：</p><blockquote><p>var carname=”Volvo”;</p></blockquote><p><strong>一个好的编程习惯是，在代码开始处，统一对需要的变量进行声明。</strong></p><h2 id="一条语句，多个变量"><a href="#一条语句，多个变量" class="headerlink" title="一条语句，多个变量"></a>一条语句，多个变量</h2><p>您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可：</p><blockquote><p>var lastname=”Doe”, age=30, job=”carpenter”;</p></blockquote><p>声明也可横跨多行：</p><blockquote><p>var lastname=”Doe”,<br>age=30,<br>job=”carpenter”;</p></blockquote><p>一条语句中声明的多个变量不可以同时赋同一个值:</p><blockquote><p>var x,y,z=1;</p></blockquote><p>x,y 为 undefined， z 为 1。</p><h2 id="Value-undefined"><a href="#Value-undefined" class="headerlink" title="Value = undefined"></a>Value = undefined</h2><p>在计算机程序中，经常会声明无值的变量。未使用值来声明的变量，其值实际上是 undefined。</p><p>在执行过以下语句后，变量 carname 的值将是 undefined：</p><blockquote><p>var carname;</p></blockquote><h2 id="重新声明-JavaScript-变量"><a href="#重新声明-JavaScript-变量" class="headerlink" title="重新声明 JavaScript 变量"></a>重新声明 JavaScript 变量</h2><p>如果重新声明 JavaScript 变量，该变量的值不会丢失：</p><p>在以下两条语句执行后，变量 carname 的值依然是 “Volvo”：</p><blockquote><p>var carname=”Volvo”;<br>var carname;</p></blockquote><h2 id="JavaScript-算数"><a href="#JavaScript-算数" class="headerlink" title="JavaScript 算数"></a>JavaScript 算数</h2><p>您可以通过 JavaScript 变量来做算数，使用的是 = 和 + 这类运算符：</p><blockquote><p>y=5; </p></blockquote><blockquote><p>x=y+2;</p></blockquote><h2 id="使用-let-和-const-ES6"><a href="#使用-let-和-const-ES6" class="headerlink" title="使用 let 和 const (ES6)"></a>使用 let 和 const (ES6)</h2><p>在 2015 年以前，我们使用 var 关键字来声明 JavaScript 变量。</p><p>在 2015 后的 JavaScript 版本 (ES6) 允许我们使用 const 关键字来定义一个常量，使用 let 关键字定义的限定范围内作用域的变量。e.</p><p>更多 const 和 let 内容可以参阅：<a href="https://www.runoob.com/js/js-let-const.html">JavaScript let 和 const。</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript语句</title>
      <link href="/2022/08/31/javascript-yu-ju/"/>
      <url>/2022/08/31/javascript-yu-ju/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript-语句"><a href="#JavaScript-语句" class="headerlink" title="JavaScript&nbsp;语句"></a>JavaScript&nbsp;语句</h1><p>JavaScript 语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号 ;"></a>分号 ;</h2><p>分号用于分隔 JavaScript 语句。</p><p>通常我们在每条可执行的语句结尾添加分号。</p><p>使用分号的另一用处是在一行中编写多条语句。</p><p>您也可能看到不带有分号的案例。<br><strong>在 JavaScript 中，用分号来结束语句是可选的。</strong></p><h2 id="JavaScript-代码"><a href="#JavaScript-代码" class="headerlink" title="JavaScript 代码"></a>JavaScript 代码</h2><p>JavaScript 代码是 JavaScript 语句的序列。</p><p>浏览器按照编写顺序依次执行每条语句。</p><h2 id="JavaScript-代码块"><a href="#JavaScript-代码块" class="headerlink" title="JavaScript 代码块"></a>JavaScript 代码块</h2><p>JavaScript 可以分批地组合起来。</p><p>代码块以左花括号开始，以右花括号结束。</p><p>代码块的作用是一并地执行语句序列。</p><h2 id="JavaScript-语句标识符"><a href="#JavaScript-语句标识符" class="headerlink" title="JavaScript 语句标识符"></a>JavaScript 语句标识符</h2><p>JavaScript 语句通常以一个&nbsp;<strong>语句标识符</strong>&nbsp;为开始，并执行该语句。</p><p>语句标识符是保留关键字不能作为变量名使用。</p><p>下表列出了 JavaScript 语句标识符 (关键字) ：</p><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td>break</td><td>用于跳出循环。</td></tr><tr><td>catch</td><td>语句块，在 try 语句块执行出错时执行 catch 语句块。</td></tr><tr><td>continue</td><td>跳过循环中的一个迭代。</td></tr><tr><td>do … while</td><td>执行一个语句块，在条件语句为 true 时继续执行该语句块。</td></tr><tr><td>for</td><td>在条件语句为 true 时，可以将代码块执行指定的次数。</td></tr><tr><td>for … in</td><td>用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。</td></tr><tr><td>function</td><td>定义一个函数</td></tr><tr><td>if … else</td><td>用于基于不同的条件来执行不同的动作。</td></tr><tr><td>return</td><td>退出函数</td></tr><tr><td>switch</td><td>用于基于不同的条件来执行不同的动作。</td></tr><tr><td>throw</td><td>抛出（生成）错误 。</td></tr><tr><td>try</td><td>实现错误处理，与 catch 一同使用。</td></tr><tr><td>var</td><td>声明一个变量。</td></tr><tr><td>while</td><td>当条件语句为 true 时，执行语句块。</td></tr></tbody></table><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性。下面的两行代码是等效的：</p><blockquote><p>var person=”runoob”;<br>var person = “runoob”;</p></blockquote><h2 id="对代码行进行折行"><a href="#对代码行进行折行" class="headerlink" title="对代码行进行折行"></a>对代码行进行折行</h2><p>您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：</p><blockquote><p>document.write(“你好 <br>世界!”);</p></blockquote><p><strong>知识点</strong>：JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript语法</title>
      <link href="/2022/08/31/javascript-yu-fa/"/>
      <url>/2022/08/31/javascript-yu-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JavaScript-语法"><a href="#JavaScript-语法" class="headerlink" title="JavaScript 语法"></a>JavaScript 语法</h2><p>JavaScript 是一个脚本语言。</p><p>它是一个轻量级，但功能强大的编程语言。</p><h2 id="JavaScript-字面量"><a href="#JavaScript-字面量" class="headerlink" title="JavaScript 字面量"></a>JavaScript 字面量</h2><p>在编程语言中，一般固定值称为字面量，如 3.14。</p><p><strong>数字（Number）字面量</strong>&nbsp;可以是整数或者是小数，或者是科学计数(e)。</p><blockquote><p>3.14</p><p>100</p><p>123e5</p></blockquote><p><strong>字符串（String）字面量</strong>&nbsp;可以使用单引号或双引号:</p><blockquote><p>“zhr”</p><p>‘zhr’</p></blockquote><p><strong>表达式字面量</strong>&nbsp;用于计算：</p><blockquote><p>1 + 2</p></blockquote><p><strong>数组（Array）字面量</strong>&nbsp;定义一个数组：</p><blockquote><p>[1, 2, 3, 4]</p></blockquote><p><strong>对象（Object）字面量</strong>&nbsp;定义一个对象：</p><blockquote><p>{firstName:”John”, lastName:”Doe”, age:50, eyeColor:”blue”}</p></blockquote><p><strong>函数（Function）字面量</strong>&nbsp;定义一个函数：</p><blockquote><p>function myFunction(a, b) { return a * b;}</p></blockquote><h2 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h2><p>在编程语言中，变量用于存储数据值。</p><p>JavaScript 使用关键字&nbsp;<strong>var</strong>&nbsp;来定义变量， 使用等号来为变量赋值：</p><blockquote><p>var x, length</p><p>x = 5</p><p>length</p></blockquote><p>变量可以通过变量名访问。在指令式语言中，变量通常是可变的。字面量是一个恒定的值。</p><p>变量是一个<strong>名称</strong>。字面量是一个<strong>值</strong>。</p><h2 id="JavaScript-操作符"><a href="#JavaScript-操作符" class="headerlink" title="JavaScript 操作符"></a>JavaScript 操作符</h2><p>JavaScript使用&nbsp;<strong>算术运算符</strong>&nbsp;来计算值:</p><blockquote><p>(1 + 2) * 3</p></blockquote><p>JavaScript使用<strong>赋值运算符</strong>给变量赋值：</p><blockquote><p>x = 5  </p><p>y = 6  </p><p>z = (x + y) * 10</p></blockquote><p>JavaScript语言有多种类型的运算符：</p><table><thead><tr><th>类型</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>赋值，算术和位运算符</td><td>=  +  -  *  /</td><td>在 JS 运算符中描述</td></tr><tr><td>条件，比较及逻辑运算符</td><td>==  != &lt;  &gt;</td><td>在 JS 比较运算符中描述</td></tr></tbody></table><h2 id="JavaScript-语句"><a href="#JavaScript-语句" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h2><p>在 HTML 中，JavaScript 语句用于向浏览器发出命令。</p><p>语句是用分号分隔：</p><blockquote><p>x = 5 + 6;  </p><p>y = x * 10;</p></blockquote><h2 id="JavaScript-关键字"><a href="#JavaScript-关键字" class="headerlink" title="JavaScript 关键字"></a>JavaScript 关键字</h2><p>JavaScript 关键字用于标识要执行的操作。</p><p>和其他任何编程语言一样，JavaScript 保留了一些关键字为自己所用。</p><p><strong>var</strong>&nbsp;关键字告诉浏览器创建一个新的变量：</p><p>JavaScript 同样保留了一些关键字，这些关键字在当前的语言版本中并没有使用，但在以后 JavaScript 扩展中会用到。</p><p>以下是 JavaScript 中最​​重要的保留关键字（按字母顺序）：</p><table><thead><tr><th>abstract</th><th>else</th><th>instanceof</th><th>super</th></tr></thead><tbody><tr><td>boolean</td><td>enum</td><td>int</td><td>switch</td></tr><tr><td>break</td><td>export</td><td>interface</td><td>synchronized</td></tr><tr><td>byte</td><td>extends</td><td>let</td><td>this</td></tr><tr><td>case</td><td>false</td><td>long</td><td>throw</td></tr><tr><td>catch</td><td>final</td><td>native</td><td>throws</td></tr><tr><td>char</td><td>finally</td><td>new</td><td>transient</td></tr><tr><td>class</td><td>float</td><td>null</td><td>true</td></tr><tr><td>const</td><td>for</td><td>package</td><td>try</td></tr><tr><td>continue</td><td>function</td><td>private</td><td>typeof</td></tr><tr><td>debugger</td><td>goto</td><td>protected</td><td>var</td></tr><tr><td>default</td><td>if</td><td>public</td><td>void</td></tr><tr><td>delete</td><td>implements</td><td>return</td><td>volatile</td></tr><tr><td>do</td><td>import</td><td>short</td><td>while</td></tr><tr><td>double</td><td>in</td><td>static</td><td>with</td></tr></tbody></table><h2 id="JavaScript-注释"><a href="#JavaScript-注释" class="headerlink" title="JavaScript 注释"></a>JavaScript 注释</h2><p>不是所有的 JavaScript 语句都是”命令”。双斜杠&nbsp;<strong>//</strong>&nbsp;后的内容将会被浏览器忽略：</p><p>JavaScript 注释可用于提高代码的可读性。</p><blockquote><p>// 我不会执行</p></blockquote><h2 id="JavaScript-多行注释"><a href="#JavaScript-多行注释" class="headerlink" title="JavaScript 多行注释"></a>JavaScript 多行注释</h2><p>多行注释以&nbsp;/*&nbsp;开始，以&nbsp;*/&nbsp;结尾。</p><p>下面的例子使用多行注释来解释代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/*下面的这些代码会输出一个标题和一个段落并将代表主页的开始*/</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myH1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"欢迎来到我的主页"</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myP"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"这是我的第一个段落。"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><p>JavaScript 有多种数据类型：数字，字符串，数组，对象等等：</p><blockquote><p>var length = 16;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// Number 通过数字字面量赋值<br>var points = x * 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Number 通过表达式字面量赋值<br>var lastName = “Johnson”;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // String 通过字符串字面量赋值<br>var cars = [“Saab”, “Volvo”, “BMW”];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Array&nbsp; 通过数组字面量赋值<br>var person = {firstName:”John”, lastName:”Doe”};&nbsp;&nbsp;// Object 通过对象字面量赋值</p></blockquote><h2 id="数据类型的概念"><a href="#数据类型的概念" class="headerlink" title="数据类型的概念"></a>数据类型的概念</h2><p>编程语言中，数据类型是一个非常重要的内容。</p><p>为了可以操作变量，了解数据类型的概念非常重要。</p><p>如果没有使用数据类型，以下实例将无法执行：</p><blockquote><p>16 + “Volvo”</p></blockquote><p>16 加上 “Volvo” 是如何计算呢? 以上会产生一个错误还是输出以下结果呢？</p><blockquote><p>“16Volvo”</p></blockquote><h2 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h2><p>JavaScript 语句可以写在函数内，函数可以重复引用：</p><p><strong>引用一个函数</strong>&nbsp;= 调用函数(执行函数内的语句)。</p><blockquote><p>function myFunction(a, b) {<br>&nbsp;&nbsp;&nbsp; return a * b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回 a 乘以 b 的结果<br>}</p></blockquote><h2 id="JavaScript-字母大小写"><a href="#JavaScript-字母大小写" class="headerlink" title="JavaScript 字母大小写"></a>JavaScript 字母大小写</h2><p>JavaScript 对大小写是敏感的。</p><p>当编写 JavaScript 语句时，请留意是否关闭大小写切换键。</p><p>函数&nbsp;<strong>getElementById</strong>&nbsp;与&nbsp;<strong>getElementbyID</strong>&nbsp;是不同的。</p><p>同样，变量&nbsp;<strong>myVariable</strong>&nbsp;与&nbsp;<strong>MyVariable</strong>&nbsp;也是不同的。</p><h2 id="JavaScript-字符集"><a href="#JavaScript-字符集" class="headerlink" title="JavaScript 字符集"></a>JavaScript 字符集</h2><p>JavaScript 使用 Unicode 字符集。</p><p>Unicode 覆盖了所有的字符，包含标点等字符。</p><p><strong>JavaScript 中，常见的是驼峰法的命名规则，如 lastName (而不是lastname)。</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JavaScript是弱类型编程语言,定义变量都使用 var 定义,与 Java 这种强类型语言有区别.</p><p>在定义后可以通过&nbsp;typeOf()&nbsp;来获取JavaScript中变量的数据类型.</p><p>// Number 通过数字字面量赋值&nbsp;</p><p>&nbsp;// Number 通过表达式字面量赋值</p><p>// String 通过字符串字面量赋值</p><p>// Array&nbsp; 通过数组字面量赋值&nbsp;</p><p>// Object 通过对象字面量赋值</p><p>有个情况需要特别注意:&nbsp;<strong>typeof 不能用来判断是 Array 还是Object</strong></p><p>var arr = [] typeof(arr) === ‘object’ // true</p><p>结果为&nbsp;<strong>true</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript输出</title>
      <link href="/2022/08/31/javascript-shu-chu/"/>
      <url>/2022/08/31/javascript-shu-chu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 没有任何打印或者输出的函数</p><p>JavaScript 可以通过不同的方式来输出数据</p><ul><li><p>window.alert() 弹出警告框</p></li><li><p>document.write() 方法将内容写到 HTML 文档中</p></li><li><p>innerHTML 写入到 HTML 元素</p></li><li><p>console.log() 写入到浏览器的控制台</p></li></ul><h1 id="window-alert"><a href="#window-alert" class="headerlink" title="window.alert()"></a>window.alert()</h1><p>你可以弹出警告框来显示数据：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>我的第一个页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>我的第一个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="操作-HTML-元素"><a href="#操作-HTML-元素" class="headerlink" title="操作 HTML 元素"></a>操作 HTML 元素</h1><p>如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(<em>id</em>) 方法。</p><p>请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>我的第一个 Web 页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>我的第一个段落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"段落已修改。"</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="写到-HTML-文档"><a href="#写到-HTML-文档" class="headerlink" title="写到 HTML 文档"></a>写到 HTML 文档</h1><p>出于测试目的，您可以将JavaScript直接写在HTML 文档中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>我的第一个 Web 页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>我的第一个段落。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请使用 document.write() 仅仅向文档输出写内容。</p><p>如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。</p><h1 id="写到控制台"><a href="#写到控制台" class="headerlink" title="写到控制台"></a>写到控制台</h1><p>如果您的浏览器支持调试，你可以使用&nbsp;<strong>console.log()</strong>&nbsp;方法在浏览器中显示 JavaScript 值。</p><p>浏览器中使用 F12 来启用调试模式， 在调试窗口中点击 “Console” 菜单。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>我的第一个 Web 页面<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2013/08/console-log.jpg"></p><p>程序中调试是测试，查找及减少 bug(错误)的过程。</p><h1 id="console-log-的用处"><a href="#console-log-的用处" class="headerlink" title="console.log()的用处"></a>console.log()的用处</h1><p>主要是方便你调式javascript用的, 你可以看到你在页面中输出的内容。</p><p><strong>相比alert他的优点是：</strong></p><p>他能看到结构化的东西，如果是alert，弹出一个对象就是[object object],但是console能看到对象的内容。</p><p>console不会打断你页面的操作，如果用alert弹出来内容，那么页面就死了，但是console输出内容后你页面还可以正常操作。</p><p>console里面的内容非常丰富，你可以在控制台输入 console，然后就可看到：</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器中执行JavaScript</title>
      <link href="/2022/08/31/chrome-liu-lan-qi-zhong-zhi-xing-javascript/"/>
      <url>/2022/08/31/chrome-liu-lan-qi-zhong-zhi-xing-javascript/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Chrome浏览器中执行JavaScript"><a href="#Chrome浏览器中执行JavaScript" class="headerlink" title="Chrome浏览器中执行JavaScript"></a>Chrome浏览器中执行JavaScript</h1><p>本章节为大家介绍如何在 Chrome 浏览器上进行 JavaScript 代码的运行与调试。</p><p>Chrome 是由 Google 开发的免费网页浏览器，对于前端开发来说（尤其是调试代码）非常方便。</p><p>我们在 Chrome 浏览器中可以通过按下&nbsp;F12&nbsp;按钮或者右击页面，选择**”检查”**来开启开发者工具。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/2FC7724A-4281-41C0-94F5-0DAE2D9D7C14.jpg"></p><p>也可以在右上角菜单栏选择&nbsp;<strong>“更多工具”=》”开发者工具”</strong>&nbsp;来开启：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/62B70027-DD24-4F04-8040-2DB58D1EDCFC.jpg"></p><h1 id="1、Console-窗口调试-JavaScript-代码"><a href="#1、Console-窗口调试-JavaScript-代码" class="headerlink" title="1、Console 窗口调试 JavaScript 代码"></a>1、Console 窗口调试 JavaScript 代码</h1><p>打开开发者工具后，我们可以在 Console 窗口调试 JavaScript代码，如下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/93B1E50A-D2D9-4FB4-B458-D50045FDE599.jpg"></p><p>上图中我们在&nbsp;&gt;&nbsp;符号后输入我们要执行的代码&nbsp;console.log(“runoob”)，按回车后执行。</p><p>我们也可以在其他地方复制一段代码过来执行，比如复制以下代码到 Console 窗口，按回车执行：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/3F6D97EB-2E51-47AA-919D-79EE62DC14DA.jpg"></p><p>清空 Console 窗口到内容可以按以下按钮：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/C1A3FF50-1C1C-463E-B12C-D7D8735F6844.jpg"></p><h1 id="2、Chrome-snippets-小脚本"><a href="#2、Chrome-snippets-小脚本" class="headerlink" title="2、Chrome snippets 小脚本"></a>2、Chrome snippets 小脚本</h1><p>我们也可以在 Chrome 浏览器中创建一个脚本来执行，在开发者工具中点击 Sources 面板，选择 Snippets 选项卡，在导航器中右击鼠标，然后选择 Create new snippet 来新建一个脚本文件：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/8C18C75F-6C15-4B7F-8C66-122D1D23C14E.jpg"></p><p>如果你没看到 Snippets ，可以点下面板上到&nbsp;&gt;&gt;&nbsp;就能看到了。</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/9F5F8D84-9C0D-4F6B-98AF-8B9349118297.jpg"></p><p>点击 Create new snippet 后，会自动创建一个文件，你只需在右侧窗口输入以下代码，然后按 Command+S（Mac）或 Ctrl+S（Windows 和 Linux）保存更改即可。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"runoob-1"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"runoob-2"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存后，右击文件名，选择 “Run” 执行代码：</p><p><img src="https://www.runoob.com/wp-content/uploads/2020/11/0DBBF606-1F97-4861-B690-1DBED83A0E5E.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript用法</title>
      <link href="/2022/08/31/javascript-yong-fa/"/>
      <url>/2022/08/31/javascript-yong-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTML 中的 JavaScript 脚本代码必须位于 <script> 与 </script> 标签之间。</p><p>JavaScript 脚本代码可被放置在 HTML 页面的  和  部分中。</p><h1 id="标签"><a href="#标签" class="headerlink" title=" 标签"></a><script> 标签</h1><p>如需在 HTML 页面中插入 JavaScript，请使用 <script> 标签。</p><script> 和 </script> 会告诉 JavaScript 在何处开始和结束。<script> 和 </script> 之间的代码行包含了 JavaScript:<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"我的第一个 JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></h1><h1 id="中的-JavaScript"><a href="#中的-JavaScript" class="headerlink" title=" 中的 JavaScript"></a> 中的 JavaScript</h1><p>在本例中，JavaScript 会在页面加载时向 HTML 的  写文本：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;h1&gt;这是一个标题&lt;/h1&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;p&gt;这是一个段落&lt;/p&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="JavaScript-函数和事件"><a href="#JavaScript-函数和事件" class="headerlink" title="JavaScript 函数和事件"></a>JavaScript 函数和事件</h1><p>上面例子中的 JavaScript 语句，会在页面加载时执行。</p><p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。</p><p>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。</p><p>您将在稍后的章节学到更多有关 JavaScript 函数和事件的知识。</p><h1 id="在-或者-的JavaScript"><a href="#在-或者-的JavaScript" class="headerlink" title="在  或者  的JavaScript"></a>在  或者  的JavaScript</h1><p>您可以在 HTML 文档中放入不限数量的脚本。</p><p>脚本可位于 HTML 的  或  部分中，或者同时存在于两个部分中。</p><p>通常的做法是把函数放入  部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p><h1 id="中的-JavaScript-函数"><a href="#中的-JavaScript-函数" class="headerlink" title=" 中的 JavaScript 函数"></a> 中的 JavaScript 函数</h1><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"我的第一个 JavaScript 函数"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我的 Web 页面<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">&gt;</span>一个段落<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">"myFunction()"</span><span class="token operator">&gt;</span>尝试一下<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="中的-JavaScript-函数-1"><a href="#中的-JavaScript-函数-1" class="headerlink" title=" 中的 JavaScript 函数"></a> 中的 JavaScript 函数</h1><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我的 Web 页面<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">&gt;</span>一个段落<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">"myFunction()"</span><span class="token operator">&gt;</span>尝试一下<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"我的第一个 JavaScript 函数"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="外部的-JavaScript"><a href="#外部的-JavaScript" class="headerlink" title="外部的 JavaScript"></a>外部的 JavaScript</h1><p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p><p>外部 JavaScript 文件的文件扩展名是 .js。</p><p>如需使用外部文件，请在 <script> 标签的 "src" 属性中设置该 .js 文件：</p><p><strong>外部脚本不能包含 <script> 标签。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"myScript.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></script></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript介绍</title>
      <link href="/2022/08/31/javascript-jie-shao/"/>
      <url>/2022/08/31/javascript-jie-shao/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。<br>Java（由 Sun 发明）是更复杂的编程语言。  </p><p>ECMA-262 是 JavaScript 标准的官方名称。  </p><p>JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。</p><h1 id="为什么学习-JavaScript？"><a href="#为什么学习-JavaScript？" class="headerlink" title="为什么学习 JavaScript？"></a>为什么学习 JavaScript？</h1><ul><li><p>HTML 定义了网页的内容</p></li><li><p>CSS 描述了网页的布局</p></li><li><p>JavaScript 控制了网页的行为</p></li></ul><p><strong>JavaScript 是互联网上最流行的脚本语言，轻量级，可由所有的现代浏览器执行。</strong></p><h1 id="学到的内容"><a href="#学到的内容" class="headerlink" title="学到的内容"></a>学到的内容</h1><h2 id="直接写入-HTML-输出流"><a href="#直接写入-HTML-输出流" class="headerlink" title="直接写入 HTML 输出流"></a>直接写入 HTML 输出流</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;h1&gt;这是一个标题&lt;/h1&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"&lt;p&gt;这是一个段落。&lt;/p&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="改变-HTML-内容"><a href="#改变-HTML-内容" class="headerlink" title="改变 HTML 内容"></a>改变 HTML 内容</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">x<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//查找元素</span>x<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"Hello JavaScript"</span><span class="token punctuation">;</span>    <span class="token comment">//改变内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>您会经常看到&nbsp;document.getElementById(“<em><strong><strong>some id</strong></strong></em>“)。这个方法是 HTML DOM 中定义的。</p><p>**DOM (Document&nbsp;Object&nbsp;Model)**（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p><p>您将在本教程的多个章节中学到有关 HTML DOM 的知识。</p><h2 id="改变-HTML-图像"><a href="#改变-HTML-图像" class="headerlink" title="改变 HTML 图像"></a>改变 HTML 图像</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">changeImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    element<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myimage'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>src<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token string">"bulbon"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        element<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token string">"/images/pic_bulboff.gif"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        element<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token string">"/images/pic_bulbon.gif"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span>img loading<span class="token operator">=</span><span class="token string">"lazy"</span> id<span class="token operator">=</span><span class="token string">"myimage"</span> onclick<span class="token operator">=</span><span class="token string">"changeImage()"</span> src<span class="token operator">=</span><span class="token string">"/images/pic_bulboff.gif"</span> width<span class="token operator">=</span><span class="token string">"100"</span> height<span class="token operator">=</span><span class="token string">"180"</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">x<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span>  <span class="token comment">//找到元素 </span>x<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color<span class="token operator">=</span><span class="token string">"#ff0000"</span><span class="token punctuation">;</span>           <span class="token comment">//改变样式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="验证输入"><a href="#验证输入" class="headerlink" title="验证输入"></a>验证输入</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"不是数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上实例只是普通的验证，如果要在生产环境中使用，需要严格判断，如果输入的空格，或者连续空格 isNaN 是判别不出来的。可以添加正则来判断（后续章节会说明）：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">||</span>x<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(^\s*)|(\s*$)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"不是数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 安装说明</title>
      <link href="/2022/08/31/redis-an-zhuang-shuo-ming/"/>
      <url>/2022/08/31/redis-an-zhuang-shuo-ming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis安装说明"><a href="#Redis安装说明" class="headerlink" title="Redis安装说明"></a>Redis安装说明</h1><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h1 id="1-单机安装Redis"><a href="#1-单机安装Redis" class="headerlink" title="1.单机安装Redis"></a>1.单机安装Redis</h1><h2 id="1-1-安装Redis依赖"><a href="#1-1-安装Redis依赖" class="headerlink" title="1.1.安装Redis依赖"></a>1.1.安装Redis依赖</h2><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum install -y gcc tcl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-上传安装包并解压"><a href="#1-2-上传安装包并解压" class="headerlink" title="1.2.上传安装包并解压"></a>1.2.上传安装包并解压</h2><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p>例如，我放到了/usr/local/src 目录：</p><p><img src="assets/image-20211211071712536.png" alt="image-20211211071712536"></p><p>解压缩：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xzf redis-6.2.6.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压后：</p><p>进入redis目录：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cd redis-6.2.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行编译命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">make &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h2 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3.启动"></a>1.3.启动</h2><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="1-3-1-默认启动"><a href="#1-3-1-默认启动" class="headerlink" title="1.3.1.默认启动"></a>1.3.1.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><pre class="line-numbers language-none"><code class="language-none">redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图：</p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2.指定配置启动"></a>1.3.2.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>我们先将这个配置文件备份一份：</p><pre class="line-numbers language-none"><code class="language-none">cp redis.conf redis.conf.bck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后修改redis.conf文件中的一些配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><span class="token key attr-name">bind</span> <span class="token value attr-value">0.0.0.0</span><span class="token comment"># 守护进程，修改为yes后即可后台运行</span><span class="token key attr-name">daemonize</span> <span class="token value attr-value">yes </span><span class="token comment"># 密码，设置后访问Redis必须输入密码</span><span class="token key attr-name">requirepass</span> <span class="token value attr-value">123321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的其它常见配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 监听的端口</span><span class="token key attr-name">port</span> <span class="token value attr-value">6379</span><span class="token comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><span class="token key attr-name">dir</span> <span class="token value attr-value">.</span><span class="token comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><span class="token key attr-name">databases</span> <span class="token value attr-value">1</span><span class="token comment"># 设置redis能够使用的最大内存</span><span class="token key attr-name">maxmemory</span> <span class="token value attr-value">512mb</span><span class="token comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><span class="token key attr-name">logfile</span> <span class="token value attr-value">"redis.log"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动Redis：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入redis安装目录 cd /usr/local/src/redis-6.2.6# 启动redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 123321 shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-3-开机自启"><a href="#1-3-3-开机自启" class="headerlink" title="1.3.3.开机自启"></a>1.3.3.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vi /etc/systemd/system/redis.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重载系统服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们可以用下面这组命令来操作redis了：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行下面的命令，可以让redis开机自启：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl enable redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-Redis客户端"><a href="#2-Redis客户端" class="headerlink" title="2.Redis客户端"></a>2.Redis客户端</h1><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h2 id="2-1-Redis命令行客户端"><a href="#2-1-Redis命令行客户端" class="headerlink" title="2.1.Redis命令行客户端"></a>2.1.Redis命令行客户端</h2><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli [options] [commonds]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><h2 id="2-2-图形化桌面客户端"><a href="#2-2-图形化桌面客户端" class="headerlink" title="2.2.图形化桌面客户端"></a>2.2.图形化桌面客户端</h2><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">GitHub - uglide/RedisDesktopManager: Cross-platform Developer GUI for Redis</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">Releases · lework/RedisDesktopManager-Windows · GitHub</a></p><h3 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1.安装"></a>2.2.1.安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p>解压缩后，运行安装程序即可安装：</p><p>此处略。</p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p>双击即可运行：</p><h3 id="2-2-2-建立连接"><a href="#2-2-2-建立连接" class="headerlink" title="2.2.2.建立连接"></a>2.2.2.建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p>在弹出的窗口中填写Redis服务信息：</p><p>点击确定后，在左侧菜单会出现这个链接：</p><p>点击即可建立连接了：</p><p>Redis默认有16个仓库，编号从0至15. 通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 选择 0号库select 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装说明 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day07</title>
      <link href="/2022/08/31/yi-yuan-ji-lu-day07/"/>
      <url>/2022/08/31/yi-yuan-ji-lu-day07/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天妈妈出院了，现在基本上没有什么事情了，只是不能工作，然后不能吃一些油腻的东西。今天回来是因为妹妹明天要去上学了，所以今天回来给她收拾收拾东西。妹妹要去郑州西亚斯学院，一个城堡学校。</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量声明：静态语言有别于动态语言的重要特征</title>
      <link href="/2022/08/28/bian-liang-sheng-ming-jing-tai-yu-yan-you-bie-yu-dong-tai-yu-yan-de-chong-yao-te-zheng/"/>
      <url>/2022/08/28/bian-liang-sheng-ming-jing-tai-yu-yan-you-bie-yu-dong-tai-yu-yan-de-chong-yao-te-zheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天我们将深入 Go 语法细节，学习静态语言有别于动态语言的一个重要特征：变量声明。那么变量声明究竟解决的是什么问题呢？我们先从变量这个概念说起。</p><p>在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为变量。</p><p>但这并不代表我们可以通过变量随意引用或修改内存，变量所绑定的内存区域是要有一个明确的边界的。也就是说，通过这样一个变量，我们究竟可以操作 4 个字节内存还是 8 个字节内存，又或是 256 个字节内存，编程语言的编译器或解释器需要明确地知道。</p><p>那么，编程语言的编译器或解释器是如何知道一个变量所能引用的内存区域边界呢？</p><p>其实，动态语言和静态语言有不同的处理方式。动态语言（比如 Python、Ruby 等）的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。</p><p>而静态编程语言在这方面的“体验略差”。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了“变量声明”。通过变量声明，语言使用者可以显式告知编译器一个变量的边界信息。在具体实现层面呢，这个边界信息由变量的类型属性赋予。</p><p>作为身处静态编程语言阵营的 Go 语言，它沿袭了静态语言的这一要求：<strong>使用变量之前需要先进行变量声明。</strong></p><p>首先，让我们先来看看 Go 语言的变量声明方法。</p><h1 id="Go-语言的变量声明方法"><a href="#Go-语言的变量声明方法" class="headerlink" title="Go 语言的变量声明方法"></a>Go 语言的变量声明方法</h1><p>我们前面说过，Go 是静态语言，所有变量在使用前必须先进行声明。声明的意义在于告诉编译器该变量可以操作的内存的边界信息，而这种边界通常又是由变量的类型信息提供的。</p><p>在 Go 语言中，有一个通用的变量声明方法是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/cf/03/cf0a619528dd03893edbb83f3c4dd303.jpg?wh=1487x770"></p><p>这个变量声明分为四个部分：</p><ul><li><p>var 是修饰变量声明的关键字；</p></li><li><p>a 为变量名；</p></li><li><p>int 为该变量的类型；</p></li><li><p>10 是变量的初值。</p></li></ul><p>你看啊，其实 Go 语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型的前面。这样做有什么好处呢？我先不说，我想请你思考一下。这个类型为变量提供了边界信息，在 Go 语言中，无论什么类型的变量，都可以使用这种形式进行变量声明。</p><p>但是，如果你没有显式为变量赋予初值，Go 编译器会为变量赋予这个类型的零值：</p><p><code>var a int // a的初值为int类型的零值: 0</code></p><p>什么是类型的零值呢？Go 语言的每种原生类型都有它的默认值（这些原生类型我们后面再讲），这个默认值就是这个类型的零值。这里我给你写了 Go 规范定义的内置原生类型的默认值（即零值）：</p><p><img src="https://static001.geekbang.org/resource/image/92/23/92242134ff5ccdaed32854d01690ab23.jpg?wh=1920x687"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland 运行错误</title>
      <link href="/2022/08/28/goland-yun-xing-cuo-wu/"/>
      <url>/2022/08/28/goland-yun-xing-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>解决Goland运行Go程序报错：该版本的 %1 与你运行的 Windows 版本不兼容</p><p><code>Error running 'go build awesomeProject (1)': Cannot run program "C:\Users\erbin\AppData\Local\Temp\___go_build_awesomeProject__1_.exe" (in directory "G:\Language Proctice\Goworks\src\awesomeProject"): CreateProcess error=216, 该版本的 %1 与你运行的 Windows 版本不兼容。请查看计算机的系统信息，然后联系软件发布者。</code></p><p>此时代码为</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> awesomeProject<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>在go中，应用程序的入口包要为main，而编译源码没有main包时，将无法编译输出可执行的文件，也就会导致这里的错误</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>将main函数所在的包名改为main，改之后如下</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 Spring Bean 定义常见错误</title>
      <link href="/2022/08/27/03-spring-bean-ding-yi-chang-jian-cuo-wu/"/>
      <url>/2022/08/27/03-spring-bean-ding-yi-chang-jian-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以定义一个 Bean 就变得格外重要了。</p><p>当然，对于这么重要的工作，Spring 自然给我们提供了很多简单易用的方式。然而，这种简单易用得益于 Spring 的“约定大于配置”，但我们往往不见得会对所有的约定都了然于胸，所以仍然会在 Bean 的定义上犯一些经典的错误。</p><p>接下来我们就来了解下那些经典错误以及它们背后的原理，你也可以对照着去看看自己是否也曾犯过，后来又是如何解决的。</p><h1 id="案例-1：隐式扫描不到-Bean-的定义"><a href="#案例-1：隐式扫描不到-Bean-的定义" class="headerlink" title="案例 1：隐式扫描不到 Bean 的定义"></a>案例 1：隐式扫描不到 Bean 的定义</h1><p>在构建 Web 服务时，我们常使用 Spring Boot 来快速构建。例如，使用下面的包结构和相关代码来完成一个简易的 Web 版 HelloWorld：</p><p><img src="https://static001.geekbang.org/resource/image/63/48/63f7d08fb89653e12b9946c4dca31c48.png?wh=375*93"></p><p>其中，负责启动程序的 Application 类定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>puzzle<span class="token punctuation">.</span>class1<span class="token punctuation">.</span>example1<span class="token punctuation">.</span>application</span><span class="token comment">//省略 import</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提供接口的 HelloWorldController 代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>puzzle<span class="token punctuation">.</span>class1<span class="token punctuation">.</span>example1<span class="token punctuation">.</span>application</span><span class="token comment">//省略 import</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"hi"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码即可实现一个简单的功能：访问<a href="http://localhost:8080/hi">http://localhost:8080/hi</a> 返回 helloworld。两个关键类位于同一个包（即 application）中。其中 HelloWorldController 因为添加了 @RestController，最终被识别成一个 Controller 的 Bean。</p><p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次和结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：</p><p><img src="https://static001.geekbang.org/resource/image/f6/30/f6080f4e2b10e7f54e79040b8362c230.png?wh=405*115"></p><p>实际上，我们没有改变任何代码，只是改变了包的结构，但是我们会发现这个 Web 应用失效了，即不能识别出 HelloWorldController 了。也就是说，我们找不到 HelloWorldController 这个 Bean 了。这是为何？</p><h2 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h2><p>要了解 HelloWorldController 为什么会失效，就需要先了解之前是如何生效的。对于 Spring Boot 而言，关键点在于 Application.java 中使用了 SpringBootApplication 注解。而这个注解继承了另外一些注解，具体定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span><span class="token comment">//省略非关键代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从定义可以看出，SpringBootApplication 开启了很多功能，其中一个关键功能就是 ComponentScan，参考其配置如下：</p><p><code>@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)</code></p><p>当 Spring Boot 启动时，ComponentScan 的启用意味着会去扫描出所有定义的 Bean，那么扫描什么位置呢？这是由 ComponentScan 注解的 basePackages 属性指定的，具体可参考如下定义：</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 5分钟轻松了解Spring基础知识</title>
      <link href="/2022/08/27/02-5-fen-zhong-qing-song-liao-jie-spring-ji-chu-zhi-shi/"/>
      <url>/2022/08/27/02-5-fen-zhong-qing-song-liao-jie-spring-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在进行“传统的”Java 编程时，对象与对象之间的关系都是紧密耦合的，例如服务类 Service 使用组件 ComponentA，则可能写出这样的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">ComponentA</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentA</span><span class="token punctuation">(</span><span class="token string">"first component"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在没有 Spring 之前，你应该会觉得这段代码并没有多大问题，毕竟大家都这么写，而且也没有什么更好的方式。就像只有一条大路可走时，大家都朝一个方向走，你大概率不会反思是不是有捷径。</p><p>而随着项目的开发推进，你会发现检验一个方式好不好的硬性标准之一，就是看它有没有拥抱变化的能力。假设有一天，我们的 ComponentA 类的构造器需要更多的参数了，你会发现，上述代码到处充斥着这行需要改进的代码：</p><p><code>private ComponentA component = new ComponentA("first component");</code></p><p>此时你可能会想了，那我用下面这种方式来构造 Service 就可以了吧？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">ComponentA</span> component；    <span class="token keyword">public</span> <span class="token class-name">Service</span><span class="token punctuation">(</span><span class="token class-name">ComponentA</span> component<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然不行，你忽略了一点，你在构建 Service 对象的时候，不还得使用 new 关键字来构建 Component？需要修改的调用处并不少！</p><p>很明显，这是一个噩梦。那么，除了这点，还有没有别的不好的地方呢？上面说的是非单例的情况，如果 ComponentA 本身是一个单例，会不会好些？毕竟我们可能找一个地方 new 一次 ComponentA 实例就足够了，但是你可能会发现另外一些问题。</p><p>下面是一段用“双重检验锁”实现的 CompoentA 类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComponentA</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">ComponentA</span> INSTANCE<span class="token punctuation">;</span>           <span class="token keyword">private</span> <span class="token class-name">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>           <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ComponentA</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">ComponentA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      INSTANCE<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实写了这么多代码，最终我们只是要一个单例而已。而且假设我们有 ComponentB、ComponentC、ComponentD 等，那上面的重复性代码不都得写一遍？也是烦的不行，不是么？</p><p>除了上述两个典型问题，还有不易于测试、不易扩展功能（例如支持 AOP）等缺点。说白了，所有问题的根源（之一）<strong>就是对象与对象之间耦合性太强了。</strong></p><h1 id="所以-Spring-的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？"><a href="#所以-Spring-的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？" class="headerlink" title="所以 Spring 的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？"></a>所以 Spring 的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？</h1><p>这里套用一个租房的场景。我们为什么喜欢通过中介来租房子呢？因为省事呀，只要花点小钱就不用与房东产生直接的“纠缠”了。</p><p>Spring 就是这个思路，它就像一个“中介”公司。当你需要一个依赖的对象（房子）时，你直接把你的需求告诉 Spring（中介）就好了，它会帮你搞定这些依赖对象，按需创建它们，而无需你的任何额外操作。</p><p>不过，在 Spring 中，房东和租房者都是对象实例，只不过换了一个名字叫 Bean 而已。</p><p>可以说，通过一套稳定的生产流程，作为“中介”的 Spring 完成了生产和预装（牵线搭桥）这些 Bean 的任务。此时，你可能想了解更多。例如，如果一个 Bean（租房者）需要用到另外一个 Bean（房子）时，具体是怎么操作呢？</p><p>本质上只能从 Spring“中介”里去找，有时候我们直接根据名称（小区名）去找，有时候则根据类型（户型），各种方式不尽相同。你就把 Spring 理解成一个 Map 型的公司即可，实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Bean</span><span class="token punctuation">&gt;</span></span> beanMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Bean</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> beanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上述代码所示，Bean 所属公司提供了对于 Map 的操作来完成查找，找到 Bean 后装配给其它对象，这就是依赖查找、自动注入的过程。</p><p>那么回过头看，这些 Bean 又是怎么被创建的呢？</p><p>对于一个项目而言，不可避免会出现两种情况：一些对象是需要 Spring 来管理的，另外一些（例如项目中其它的类和依赖的 Jar 中的类）又不需要。所以我们得有一个办法去标识哪些是需要成为 Spring Bean，因此各式各样的注解才应运而生，例如 <strong>Component 注解</strong>等。</p><p>那有了这些注解后，谁又来做“发现”它们的工作呢？直接配置指定自然不成问题，但是很明显“自动发现”更让人省心。此时，我们往往需要一个扫描器，可以模拟写下这样一个扫描器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationScan</span> <span class="token punctuation">{</span>        <span class="token comment">//通过扫描包名来找到Bean</span>    <span class="token keyword">void</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token class-name">String</span> packages<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">//</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了扫描器，我们就知道哪些类是需要成为 Bean。</p><p>那怎么实例化为 Bean（也就是一个对象实例而已）呢？很明显，只能通过反射来做了。不过这里面的方式可能有多种：</p><ul><li><p>java.lang.Class.newInsance()</p></li><li><p>java.lang.reflect.Constructor.newInstance()</p></li><li><p>ReflectionFactory.newConstructorForSerialization()</p></li></ul><p><strong>有了创建，有了装配，一个 Bean 才能成为自己想要的样子。</strong></p><p>而需求总是源源不断的，我们有时候想记录一个方法调用的性能，有时候我们又想在方法调用时输出统一的调用日志。诸如此类，我们肯定不想频繁再来个散弹式的修改。所以我们有了 AOP，帮忙拦截方法调用，进行功能扩展。拦截谁呢？在 Spring 中自然就是 Bean 了。</p><p>其实 AOP 并不神奇，结合刚才的 Bean（中介）公司来讲，假设我们判断出一个 Bean 需要“增强”了，我们直接让它从公司返回的时候，就使用一个代理对象作为返回不就可以了么？示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Bean</span><span class="token punctuation">&gt;</span></span> beanMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Bean</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//查找是否创建过</span>       <span class="token class-name">Bean</span> bean <span class="token operator">=</span> beanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>bean <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> bean<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//创建一个Bean</span>       <span class="token class-name">Bean</span> bean <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//判断要不要AOP</span>       <span class="token keyword">boolean</span> needAop <span class="token operator">=</span> <span class="token function">judgeIfNeedAop</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">try</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>needAop<span class="token punctuation">)</span>              <span class="token comment">//创建代理对象</span>              bean <span class="token operator">=</span> <span class="token function">createProxyObject</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> bean<span class="token punctuation">;</span>           <span class="token keyword">else</span><span class="token operator">:</span>              <span class="token keyword">return</span> bean       <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>           beanMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么怎么知道一个对象要不要 AOP？既然一个对象要 AOP，它肯定被标记了一些“规则”，例如拦截某个类的某某方法，示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.spring.puzzle.ComponentA.execute()) "</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recordPayPerformance</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>      <span class="token comment">//</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，很明显了，假设你的 Bean 名字是 ComponentA，那么就应该返回 ComponentA 类型的代理对象了。至于这些规则是怎么建立起来的呢？你看到它上面使用的各种注解大概就能明白其中的规则了，无非就是扫描注解，根据注解创建规则。</p><p>以上即为 Spring 的一些核心思想，包括 Bean 的构建、自动注入和 AOP，这中间还会掺杂无数的细节，不过这不重要，抓住这个核心思想对你接下来理解各种类型的错误案例才是大有裨益的！</p><p>虽然说 Spring 容器上手简单，可以仅仅通过学习一些有限的注解，即可达到快速使用的目的。但在工程实践中，我们依然会从中发现一些常见的错误。尤其当你对 Spring 的生命周期还没有深入了解时，类初始化及销毁过程中潜在的约定就不会很清楚。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 贴心&quot;保姆&quot;Spring罢工了怎么办</title>
      <link href="/2022/08/27/01-tie-xin-bao-mu-spring-ba-gong-liao-zen-me-ban/"/>
      <url>/2022/08/27/01-tie-xin-bao-mu-spring-ba-gong-liao-zen-me-ban/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring 就是这样，它有很多隐性的约定，而这些约定并不一定是你所熟悉的。所以，当你遇到问题时，很有可能就抓狂了。一方面我们得益于它所带来的轻松，因为不需要了解太多我们也能工作；另一方面也会崩溃于问题来临之时无法快速解决，因为我们平时根本不需要，甚至不觉得要了解更多。</p><p>这个时候就有很多人跳出来跟你说：“你一定要提前把 Spring 吃透啊！”</p><p>可当你翻阅 Spring 源码时，你肯定会望而生畏，真的太多了，不带着问题去学习无异于大海捞针。即使你去通读市场上大多数畅销的 Spring 教程，你可能仍然会感觉到茫然，不知道自己到底掌握得如何。毕竟读完之后，你不一定能预见到未来可能遇到哪些问题，而这些问题的规避和处理往往才是检验你学习成果的标准。</p><h1 id="我如何讲这门课？"><a href="#我如何讲这门课？" class="headerlink" title="我如何讲这门课？"></a>我如何讲这门课？</h1><p>厌倦了遇到问题时的疲于奔命，自然就要寻找高效便捷的学习法门了，所以这几年我一直在整理 Spring 开发中所遇到的各种各样的问题，然后按类划分。</p><p>项目忙的时候，就简单记录一下，忙过去了就深入研究。现在我的 ToDoList 已经非常详实了，对我的团队帮助也非常大。对于新人来说，这是份全面的避坑指南；对于老人来说，这又是个很好的问题备忘录。</p><p>在内容设计上，整个专栏都是以问题驱动的方式来组织知识点的，大概是这样的一个思路：</p><p><img src="https://static001.geekbang.org/resource/image/45/de/45d103389eab48e4d911a7a6f7d4c0de.png?wh=548*195"></p><p>而在问题的选型上，我一共筛选出了 50 多个常见问题，这些问题主要来自：我和同事在生产环境中经常遇到问题，Stack Overflow 网站上的一些高频问题，以及常用搜索引擎检索到的一些高频问题。</p><p>这些问题的选择都遵循这样几个原则：</p><ul><li><p>不难，但是常见，基本每个人都会遇到；</p></li><li><p>不太常见，但是一旦碰见，很容易入坑；</p></li><li><p>在某些场景下可以工作，换一种情况就失效。</p></li></ul><h1 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h1><p>有了关于具体内容的详细说明，我相信你对专栏所能解决的问题已经有了大概的感知。接下来，我再跟你说说整体的课程设计，帮助你进一步了解</p><p>本专栏共分为以下三个部分，你可以对照着下面这张图去理解我的设计思路：</p><p><img src="https://static001.geekbang.org/resource/image/83/fc/834c92d778378859acf4e0e02ee778fc.png?wh=5300*1528"></p><p><strong>Spring Core 篇</strong>：Spring Core 包括 Bean 定义、注入、AOP 等核心功能，可以说它们是 Spring 的基石。不管未来你是做 Spring Web 开发，还是使用 Spring Cloud 技术栈，你都绕不开这些功能。所以这里我会重点介绍在这些功能使用上的常见问题。</p><p><strong>Spring Web 篇</strong>：大多项目使用 Spring 还是为了进行 Web 开发，所以我也梳理了从请求 URL 解析、Header 解析、Body 转化到授权等 Web 开发中绕不开的问题。不难发现，它们正好涵盖了从一个请求到来，到响应回去这一完整流程。</p><p><strong>Spring 补充篇</strong>：作为补充，这部分我会重点介绍 Spring 测试、Spring 事务、Spring Data 相关问题。最后，我还会为你系统总结下 Spring 使用中发生问题的根本原因。</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>不过，有几点我还是要提醒你一下。这门课程需要一定的基础，你要知道最基本的 Spring 使用知识，比如如何自动注入一个 Bean，如何使用 AOP 等；同时，你也需要有一定的耐心，因为涉及源码理解。</p><p>另外，这门课程重在实践与查漏补缺，所以在每个问题的讲解上，我不可能追根溯源地把所有的背景知识、前后调用关系都完整呈现出来，否则你看到的无疑是一门包含大量重复内容的 Spring 教程而已，这也违背了这门课的初衷。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>即学即练：构建一个Web服务</title>
      <link href="/2022/08/27/ji-xue-ji-lian-gou-jian-yi-ge-web-fu-wu/"/>
      <url>/2022/08/27/ji-xue-ji-lian-gou-jian-yi-ge-web-fu-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="预热：最简单的-HTTP-服务"><a href="#预热：最简单的-HTTP-服务" class="headerlink" title="预热：最简单的 HTTP 服务"></a>预热：最简单的 HTTP 服务</h1><p><img src="https://static001.geekbang.org/resource/image/9a/91/9ab73568ef659d75a313f3394a811491.png?wh=1194x1158"></p><p>我们看到，Go 应用的前 4 个领域中，有两个都是 Web 服务相关的。一个是排在第一位的 API/RPC 服务，另一个是排在第四位的 Web 服务（返回 html 页面）。考虑到后续你把 Go 应用于 Web 服务领域的机会比较大，所以，在这节课我们就选择一个 Web 服务项目作为实战小项目。</p><p>不过在真正开始我们的实战小项目前，我们先来预热一下，做一下技术铺垫。我先来给你演示一下<strong>在 Go 中创建一个基于 HTTP 协议的 Web 服务是多么的简单</strong>。</p><p>这种简单又要归功于 Go“面向工程”特性。在 02 讲介绍 Go 的设计哲学时，我们也说过，Go“面向工程”的特性，不仅体现在语言设计方面时刻考虑开发人员的体验，而且它还提供了完善的工具链和“自带电池”的标准库，这就使得 Go 程序大大减少了对外部第三方包的依赖。以开发 Web 服务为例，我们可以基于 Go 标准库提供的 net/http 包，轻松构建一个承载 Web 内容传输的 HTTP 服务。</p><p>下面，我们就来构建一个最简单的 HTTP 服务，这个服务的功能很简单，就是当收到一个 HTTP 请求后，给请求方返回包含“hello, world”数据的响应。</p><p>我们首先按下面步骤建立一个 simple-http-server 目录，并创建一个名为 simple-http-server 的 Go Module：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> simple-http-server<span class="token variable">$cd</span> simple-http-server<span class="token variable">$go</span> mod init simple-http-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于这个 HTTP 服务比较简单，我们采用最简项目布局，也就是在 simple-http-server 目录下创建一个 main.go 源文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token keyword">package</span> main <span class="token keyword">import</span> <span class="token string">"net/http"</span> <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>         w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些代码就是一个最简单的 HTTP 服务的实现了。在这个实现中，我们只使用了 Go 标准库的 http 包。可能你现在对 http 包还不熟悉，但没有关系，你现在只需要大致了解上面代码的结构与原理就可以了。</p><p>这段代码里，你要注意两个重要的函数，一个是 ListenAndServe，另一个是 HandleFunc。</p><p>你会看到，代码的第 9 行，我们通过 http 包提供的 ListenAndServe 函数，建立起一个 HTTP 服务，这个服务监听本地的 8080 端口。客户端通过这个端口与服务建立连接，发送 HTTP 请求就可以得到相应的响应结果。</p><p>那么服务端是如何处理客户端发送的请求的呢？我们看上面代码中的第 6 行。在这一行中，我们为这个服务设置了一个处理函数。这个函数的函数原型是这样的：</p><p><code>func(w http.ResponseWriter, r *http.Request)</code></p><p>这个函数里有两个参数，w 和 r。第二个参数 r 代表来自客户端的 HTTP 请求，第一个参数 w 则是用来操作返回给客户端的应答的，基于 http 包实现的 HTTP 服务的处理函数都要符合这一原型。</p><p>你也发现了，在这个例子中，所有来自客户端的请求，无论请求的 URI 路径（RequestURI）是什么，请求都会被我们设置的处理函数处理。为什么会这样呢？</p><p>这是因为，我们通过 http.HandleFunc 设置这个处理函数时，传入的模式字符串为“/”。HTTP 服务器在收到请求后，会将请求中的 URI 路径与设置的模式字符串进行最长前缀匹配，并执行匹配到的模式字符串所对应的处理函数。在这个例子中，我们仅设置了“/”这一个模式字符串，并且所有请求的 URI 都能与之匹配，自然所有请求都会被我们设置的处理函数处理。</p><p>接着，我们再来编译运行一下这个程序，直观感受一下 HTTP 服务处理请求的过程。我们首先按下面步骤来编译并运行这个程序:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cd</span> simple-http-server<span class="token variable">$go</span> build$./simple-http-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们用 curl 命令行工具模拟客户端，向上述服务建立连接并发送 http 请求：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$curl</span> localhost:8080/hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们看到，curl 成功得到了 http 服务返回的“hello, world”响应数据。到此，我们的 HTTP 服务就构建成功了。</p><p>当然了，真实世界的 Web 服务不可能像上述例子这么简单，这仅仅是一个“预热”。我想让你知道，使用 Go 构建 Web 服务是非常容易的。并且，这样的预热也能让你初步了解实现代码的结构，先有一个技术铺垫。</p><p>下面我们就进入这节课的实战小项目，一个更接近于真实世界情况的<strong>图书管理 API 服务</strong>。</p><h1 id="图书管理-API-服务"><a href="#图书管理-API-服务" class="headerlink" title="图书管理 API 服务"></a>图书管理 API 服务</h1><p>首先，我们先来明确一下我们的业务逻辑。</p><p>在这个实战小项目中，我们模拟的是真实世界的一个书店的图书管理后端服务。这个服务为平台前端以及其他客户端，提供针对图书的 CRUD（创建、检索、更新与删除）的基于 HTTP 协议的 API。API 采用典型的 RESTful 风格设计，这个服务提供的 API 集合如下：</p><p><img src="https://static001.geekbang.org/resource/image/99/51/99717b62f7553e1a5139edcf2ac03b51.jpg?wh=1980x788"></p><p>这个 API 服务的逻辑并不复杂。简单来说，我们通过 id 来唯一标识一本书，对于图书来说，这个 id 通常是 ISBN 号。至于客户端和服务端中请求与响应的数据，我们采用放在 HTTP 协议包体（Body）中的 Json 格式数据来承载。</p><p>业务逻辑是不是很简单啊？下面我们就直接开始创建这个项目。</p><h2 id="项目建立与布局设计"><a href="#项目建立与布局设计" class="headerlink" title="项目建立与布局设计"></a>项目建立与布局设计</h2><p>我们按照下面步骤创建一个名为 bookstore 的 Go 项目并创建对应的 Go Module：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> bookstore<span class="token variable">$cd</span> bookstore<span class="token variable">$go</span> mod init bookstorego: creating new go.mod: module bookstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的业务逻辑说明，我们可以把这个服务大体拆分为两大部分，一部分是 HTTP 服务器，用来对外提供 API 服务；另一部分是图书数据的存储模块，所有的图书数据均存储在这里。</p><p>同时，这是一个以构建可执行程序为目的的 Go 项目，我们参考 Go 项目布局标准一讲中的项目布局，把这个项目的结构布局设计成这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── cmd/│   └── bookstore/         // 放置bookstore main包源码│       └── main.go├── go.mod                 // module bookstore的go.mod├── go.sum├── internal/              // 存放项目内部包的目录│   └── store/│       └── memstore.go     ├── server/                // HTTP服务器模块│   ├── middleware/│   │   └── middleware.go│   └── server.go          └── store/                 // 图书数据存储模块    ├── factory/    │   └── factory.go    └── store.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们既给出了这个项目的结构布局，也给出了这个项目最终实现的源码文件分布情况。下面我们就从 main 包开始，自上而下逐一看看这个项目的模块设计与实现。</p><h2 id="项目-main-包"><a href="#项目-main-包" class="headerlink" title="项目 main 包"></a>项目 main 包</h2><p>main 包是主要包，为了搞清楚各个模块之间的关系，我在这里给出了 main 包的实现逻辑图：</p><p><img src="https://static001.geekbang.org/resource/image/5e/19/5e8ee50b67a4229210b12afb94f55a19.jpg?wh=1980x1080"></p><p>同时，我也列出了 main 包（main.go）的所有代码，你可以先花几分钟看一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token keyword">package</span> main <span class="token keyword">import</span> <span class="token punctuation">(</span>     <span class="token boolean">_</span> <span class="token string">"bookstore/internal/store"</span>     <span class="token string">"bookstore/server"</span>     <span class="token string">"bookstore/store/factory"</span>     <span class="token string">"context"</span>     <span class="token string">"log"</span>     <span class="token string">"os"</span>     <span class="token string">"os/signal"</span>     <span class="token string">"syscall"</span>     <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s<span class="token punctuation">,</span> err <span class="token operator">:=</span> factory<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"mem"</span><span class="token punctuation">)</span> <span class="token comment">// 创建图书数据存储模块实例</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    srv <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">NewBookStoreServer</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// 创建http服务实例</span>    errChan<span class="token punctuation">,</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 运行http服务</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"web server start failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"web server start ok"</span><span class="token punctuation">)</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> os<span class="token punctuation">.</span>Signal<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    signal<span class="token punctuation">.</span><span class="token function">Notify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SIGINT<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SIGTERM<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span> <span class="token comment">// 监视来自errChan以及c的事件</span>    <span class="token keyword">case</span> err <span class="token operator">=</span> <span class="token operator">&lt;-</span>errChan<span class="token punctuation">:</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"web server run failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bookstore program is exiting..."</span><span class="token punctuation">)</span>        ctx<span class="token punctuation">,</span> cf <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        <span class="token keyword">defer</span> <span class="token function">cf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        err <span class="token operator">=</span> srv<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token comment">// 优雅关闭http服务实例</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bookstore program exit error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bookstore program exit ok"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Go 中，main 包不仅包含了整个程序的入口，它还是整个程序中主要模块初始化与组装的场所。那对应在我们这个程序中，主要模块就是第 16 行的创建图书存储模块实例，以及第 21 行创建 HTTP 服务模块实例。而且，你还要注意的是，第 21 行创建 HTTP 服务模块实例的时候，我们把图书数据存储实例 s 作为参数，传递给了 NewBookStoreServer 函数。这两个实例的创建原理，我们等会再来细细探讨。</p><p>这里，我们重点来看 main 函数的后半部分（第 30 行~ 第 42 行），这里表示的是，我们通过监视系统信号实现了 http 服务实例的优雅退出。</p><p>所谓优雅退出，指的就是程序有机会等待其他的事情处理完再退出。比如尚未完成的事务处理、清理资源（比如关闭文件描述符、关闭 socket）、保存必要中间状态、内存数据持久化落盘，等等。如果你经常用 Go 来编写 http 服务，那么 http 服务如何优雅退出，就是你经常要考虑的问题。</p><p>在这个问题的具体实现上，我们通过 signal 包的 Notify 捕获了 SIGINT、SIGTERM 这两个系统信号。这样，当这两个信号中的任何一个触发时，我们的 http 服务实例都有机会在退出前做一些清理工作。</p><p>然后，我们再使用 http 服务实例（srv）自身提供的 Shutdown 方法，来实现 http 服务实例内部的退出清理工作，包括：立即关闭所有 listener、关闭所有空闲的连接、等待处于活动状态的连接处理完毕，等等。当 http 服务实例的清理工作完成后，我们整个程序就可以正常退出了。</p><p>接下来，我们再重点看看构成 bookstore 程序的两个主要模块：图书数据存储模块与 HTTP 服务模块的实现。我们按照 main 函数中的初始化顺序，先来看看图书数据存储模块。</p><h2 id="图书数据存储模块（store"><a href="#图书数据存储模块（store" class="headerlink" title="图书数据存储模块（store)"></a>图书数据存储模块（store)</h2><p>图书数据存储模块的职责很清晰，就是用来存储整个 bookstore 的图书数据的。图书数据存储有很多种实现方式，最简单的方式莫过于在内存中创建一个 map，以图书 id 作为 key，来保存图书信息，我们在这一讲中也会采用这种方式。但如果我们要考虑上生产环境，数据要进行持久化，那么最实际的方式就是通过 Nosql 数据库甚至是关系型数据库，实现对图书数据的存储与管理。</p><p>考虑到对多种存储实现方式的支持，我们将针对图书的有限种存储操作，放置在一个接口类型 Store 中，如下源码所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// store/store.go</span> <span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>     Id      <span class="token builtin">string</span>   <span class="token string">`json:"id"`</span>      <span class="token comment">// 图书ISBN ID</span>     Name    <span class="token builtin">string</span>   <span class="token string">`json:"name"`</span>    <span class="token comment">// 图书名称</span>     Authors <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"authors"`</span> <span class="token comment">// 图书作者</span>     Press   <span class="token builtin">string</span>   <span class="token string">`json:"press"`</span>   <span class="token comment">// 出版社</span> <span class="token punctuation">}</span>  <span class="token keyword">type</span> Store <span class="token keyword">interface</span> <span class="token punctuation">{</span>     <span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token builtin">error</span>        <span class="token comment">// 创建一个新图书条目</span>     <span class="token function">Update</span><span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token builtin">error</span>        <span class="token comment">// 更新某图书条目</span>     <span class="token function">Get</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Book<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>  <span class="token comment">// 获取某图书信息</span>     <span class="token function">GetAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Book<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>   <span class="token comment">// 获取所有图书信息</span>     <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span>       <span class="token comment">// 删除某图书条目</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们建立了一个对应图书条目的抽象数据类型 Book，以及针对 Book 存取的接口类型 Store。这样，对于想要进行图书数据操作的一方来说，他只需要得到一个满足 Store 接口的实例，就可以实现对图书数据的存储操作了，不用再关心图书数据究竟采用了何种存储方式。这就实现了图书存储操作与底层图书数据存储方式的解耦。而且，这种面向接口编程也是 Go 组合设计哲学的一个重要体现。</p><p>那我们具体如何创建一个满足 Store 接口的实例呢？我们可以参考《设计模式》提供的多种创建型模式，选择一种 Go 风格的工厂模式（创建型模式的一种）来实现满足 Store 接口实例的创建。我们看一下 store/factory 包的源码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// store/factory/factory.go</span> <span class="token keyword">var</span> <span class="token punctuation">(</span>     providersMu sync<span class="token punctuation">.</span>RWMutex     providers   <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>store<span class="token punctuation">.</span>Store<span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token keyword">func</span> <span class="token function">Register</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> p store<span class="token punctuation">.</span>Store<span class="token punctuation">)</span> <span class="token punctuation">{</span>     providersMu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> providersMu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"store: Register provider is nil"</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> dup <span class="token operator">:=</span> providers<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> dup <span class="token punctuation">{</span>         <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"store: Register called twice for provider "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span>     <span class="token punctuation">}</span>     providers<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token punctuation">}</span>  <span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>providerName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>Store<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     providersMu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> providers<span class="token punctuation">[</span>providerName<span class="token punctuation">]</span>     providersMu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"store: unknown provider %s"</span><span class="token punctuation">,</span> providerName<span class="token punctuation">)</span>     <span class="token punctuation">}</span>      <span class="token keyword">return</span> p<span class="token punctuation">,</span> <span class="token boolean">nil</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码实际上是效仿了 Go 标准库的 database/sql 包采用的方式，factory 包采用了一个 map 类型数据，对工厂可以“生产”的、满足 Store 接口的实例类型进行管理。factory 包还提供了 Register 函数，让各个实现 Store 接口的类型可以把自己“注册”到工厂中来。</p><p>一旦注册成功，factory 包就可以“生产”出这种满足 Store 接口的类型实例。而依赖 Store 接口的使用方，只需要调用 factory 包的 New 函数，再传入期望使用的图书存储实现的名称，就可以得到对应的类型实例了。</p><p>在项目的 internal/store 目录下，我们还提供了一个基于内存 map 的 Store 接口的实现，我们具体看一下这个实现是怎么自注册到 factory 包中的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// internal/store/memstore.go</span> <span class="token keyword">package</span> store   <span class="token keyword">import</span> <span class="token punctuation">(</span>     mystore <span class="token string">"bookstore/store"</span>     factory <span class="token string">"bookstore/store/factory"</span>     <span class="token string">"sync"</span> <span class="token punctuation">)</span>   <span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     factory<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token string">"mem"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>MemStore<span class="token punctuation">{</span>         books<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>mystore<span class="token punctuation">.</span>Book<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token keyword">type</span> MemStore <span class="token keyword">struct</span> <span class="token punctuation">{</span>     sync<span class="token punctuation">.</span>RWMutex     books <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>mystore<span class="token punctuation">.</span>Book <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 memstore 的代码来看，它是在包的 init 函数中调用 factory 包提供的 Register 函数，把自己的实例以“mem”的名称注册到 factory 中的。这样做有一个好处，依赖 Store 接口进行图书数据管理的一方，只要导入 internal/store 这个包，就可以自动完成注册动作了。</p><p>理解了这个之后，我们再看下面 main 包中，创建图书数据存储模块实例时采用的代码，是不是就豁然开朗了？</p><p>至于 memstore.go 中图书数据存储的具体逻辑，就比较简单了，我这里就不详细分析了，你课后自己阅读一下吧。</p><p>接着，我们再来看看 bookstore 程序的另外一个重要模块：HTTP 服务模块。</p><h2 id="HTTP-服务模块（server）"><a href="#HTTP-服务模块（server）" class="headerlink" title="HTTP 服务模块（server）"></a>HTTP 服务模块（server）</h2><p>HTTP 服务模块的职责是<strong>对外提供 HTTP API 服务，处理来自客户端的各种请求，并通过 Store 接口实例执行针对图书数据的相关操作</strong>。这里，我们抽象处理一个 server 包，这个包中定义了一个 BookStoreServer 类型如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span> <span class="token keyword">type</span> BookStoreServer <span class="token keyword">struct</span> <span class="token punctuation">{</span>     s   store<span class="token punctuation">.</span>Store     srv <span class="token operator">*</span>http<span class="token punctuation">.</span>Server <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，这个类型实质上就是一个标准库的 http.Server，并且组合了来自 store.Store 接口的能力。server 包提供了 NewBookStoreServer 函数，用来创建一个 BookStoreServer 类型实例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span> <span class="token keyword">func</span> <span class="token function">NewBookStoreServer</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> s store<span class="token punctuation">.</span>Store<span class="token punctuation">)</span> <span class="token operator">*</span>BookStoreServer <span class="token punctuation">{</span>     srv <span class="token operator">:=</span> <span class="token operator">&amp;</span>BookStoreServer<span class="token punctuation">{</span>         s<span class="token punctuation">:</span> s<span class="token punctuation">,</span>         srv<span class="token punctuation">:</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>             Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token punctuation">}</span>      router <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">NewRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>createBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>updateBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>getBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>getAllBooksHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>delBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"DELETE"</span><span class="token punctuation">)</span>      srv<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler <span class="token operator">=</span> middleware<span class="token punctuation">.</span><span class="token function">Logging</span><span class="token punctuation">(</span>middleware<span class="token punctuation">.</span><span class="token function">Validating</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> srv <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到函数 NewBookStoreServer 接受两个参数，一个是 HTTP 服务监听的服务地址，另外一个是实现了 store.Store 接口的类型实例。这种函数原型的设计是 Go 语言的一种惯用设计方法，也就是接受一个接口类型参数，返回一个具体类型。返回的具体类型组合了传入的接口类型的能力</p><p>这个时候，和前面预热时实现的简单 http 服务一样，我们还需为 HTTP 服务器设置请求的处理函数。</p><p>由于这个服务请求 URI 的模式字符串比较复杂，标准库 http 包内置的 URI 路径模式匹配器（ServeMux，也称为路由管理器）不能满足我们的需求，因此在这里，我们需要借助一个第三方包 github.com/gorilla/mux 来实现我们的需求。</p><p>在上面代码的第 11 行到第 16 行，我们针对不同 URI 路径模式设置了不同的处理函数。我们以 createBookHandler 和 getBookHandler 为例来看看这些处理函数的实现:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span>  <span class="token keyword">func</span> <span class="token punctuation">(</span>bs <span class="token operator">*</span>BookStoreServer<span class="token punctuation">)</span> <span class="token function">createBookHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      dec <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>      <span class="token keyword">var</span> book store<span class="token punctuation">.</span>Book      <span class="token keyword">if</span> err <span class="token operator">:=</span> dec<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>          http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>        <span class="token keyword">if</span> err <span class="token operator">:=</span> bs<span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>          http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">func</span> <span class="token punctuation">(</span>bs <span class="token operator">*</span>BookStoreServer<span class="token punctuation">)</span> <span class="token function">getBookHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      id<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Vars</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span>      <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>          http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"no id found in request"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>       book<span class="token punctuation">,</span> err <span class="token operator">:=</span> bs<span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>     <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>         <span class="token keyword">return</span>     <span class="token punctuation">}</span>      <span class="token function">response</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> book<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">func</span> <span class="token function">response</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     data<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>     <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusInternalServerError<span class="token punctuation">)</span>         <span class="token keyword">return</span>     <span class="token punctuation">}</span>     w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>     w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些处理函数的实现都大同小异，都是先获取 http 请求包体数据，然后通过标准库 json 包将这些数据，解码（decode）为我们需要的 store.Book 结构体实例，再通过 Store 接口对图书数据进行存储操作。如果我们是获取图书数据的请求，那么处理函数将通过 response 函数，把取出的图书数据编码到 http 响应的包体中，并返回给客户端。</p><p>然后，在 NewBookStoreServer 函数实现的尾部，我们还看到了这样一行代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">srv<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler <span class="token operator">=</span> middleware<span class="token punctuation">.</span><span class="token function">Logging</span><span class="token punctuation">(</span>middleware<span class="token punctuation">.</span><span class="token function">Validating</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这行代码的意思是说，我们在 router 的外围包裹了两层 middleware。什么是 middleware 呢？对于我们的上下文来说，这些 middleware 就是一些通用的 http 处理函数。我们看一下这里的两个 middleware，也就是 Logging 与 Validating 函数的实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/middleware/middleware.go</span>  <span class="token keyword">func</span> <span class="token function">Logging</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> http<span class="token punctuation">.</span>Handler <span class="token punctuation">{</span>     <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>         log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recv a %s request from %s"</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> req<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>         next<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> req<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token keyword">func</span> <span class="token function">Validating</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> http<span class="token punctuation">.</span>Handler <span class="token punctuation">{</span>     <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>         contentType <span class="token operator">:=</span> req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">)</span>         mediatype<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> mime<span class="token punctuation">.</span><span class="token function">ParseMediaType</span><span class="token punctuation">(</span>contentType<span class="token punctuation">)</span>         <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>             http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>             <span class="token keyword">return</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span> mediatype <span class="token operator">!=</span> <span class="token string">"application/json"</span> <span class="token punctuation">{</span>             http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"invalid Content-Type"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnsupportedMediaType<span class="token punctuation">)</span>             <span class="token keyword">return</span>         <span class="token punctuation">}</span>         next<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> req<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，Logging 函数主要用来输出每个到达的 HTTP 请求的一些概要信息，而 Validating 则会对每个 http 请求的头部进行检查，检查 Content-Type 头字段所表示的媒体类型是否为 application/json。这些通用的 middleware 函数，会被串联到每个真正的处理函数之前，避免我们在每个处理函数中重复实现这些逻辑。</p><p>创建完 BookStoreServer 实例后，我们就可以调用其 ListenAndServe 方法运行这个 http 服务了，显然这个方法的名字是仿效 http.Server 类型的同名方法，我们的实现是这样的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>bs <span class="token operator">*</span>BookStoreServer<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> err <span class="token builtin">error</span>     errChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">)</span>     <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         err <span class="token operator">=</span> bs<span class="token punctuation">.</span>srv<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         errChan <span class="token operator">&lt;-</span> err     <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">select</span> <span class="token punctuation">{</span>     <span class="token keyword">case</span> err <span class="token operator">=</span> <span class="token operator">&lt;-</span>errChan<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err     <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">return</span> errChan<span class="token punctuation">,</span> <span class="token boolean">nil</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，这个函数把 BookStoreServer 内部的 http.Server 的运行，放置到一个单独的轻量级线程 Goroutine 中。这是因为，http.Server.ListenAndServe 会阻塞代码的继续运行，如果不把它放在单独的 Goroutine 中，后面的代码将无法得到执行。</p><p>为了检测到 http.Server.ListenAndServe 的运行状态，我们再通过一个 channel（位于第 5 行的 errChan），在新创建的 Goroutine 与主 Goroutine 之间建立的通信渠道。通过这个渠道，这样我们能及时得到 http server 的运行状态。</p><h2 id="编译、运行与验证"><a href="#编译、运行与验证" class="headerlink" title="编译、运行与验证"></a>编译、运行与验证</h2><p>到这里，bookstore 项目的大部分重要代码我们都分析了一遍，是时候将程序跑起来看看了。</p><p>不过，因为我们在程序中引入了一个第三方依赖包，所以在构建项目之前，我们需要执行下面这个命令，让 Go 命令自动分析依赖项和版本，并更新 go.mod：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/gorilla/muxgo: found github.com/gorilla/mux <span class="token keyword">in</span> github.com/gorilla/mux v1.8.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完成后，我们就可以按下面的步骤来构建并执行 bookstore 了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build bookstore/cmd/bookstore$./bookstore<span class="token number">2021</span>/10/05 <span class="token number">16</span>:08:36 web server start ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你看到上面这个输出的日志，说明我们的程序启动成功了。</p><p>现在，我们就可以像前面一样使用 curl 命令行工具，模仿客户端向 bookstore 服务发起请求了，比如创建一个新书条目：</p><p><code>$curl -X POST -H "Content-Type:application/json" -d '{"id": "978-7-111-55842-2", "name": "The Go Programming Language", "authors":["Alan A.A.Donovan", "Brian W. Kergnighan"],"press": "Pearson Education"}' localhost:8080/book</code></p><p>此时服务端会输出如下日志，表明我们的 bookstore 服务收到了客户端请求。</p><p><code>2021/10/05 16:09:10 recv a POST request from [::1]:58021</code></p><p>接下来，我们再来获取一下这本书的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$curl</span> -X GET -H <span class="token string">"Content-Type:application/json"</span> localhost:8080/book/978-7-111-55842-2<span class="token punctuation">{</span><span class="token string">"id"</span><span class="token builtin class-name">:</span><span class="token string">"978-7-111-55842-2"</span>,<span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"The Go Programming Language"</span>,<span class="token string">"authors"</span>:<span class="token punctuation">[</span><span class="token string">"Alan A.A.Donovan"</span>,<span class="token string">"Brian W. Kergnighan"</span><span class="token punctuation">]</span>,<span class="token string">"press"</span><span class="token builtin class-name">:</span><span class="token string">"Pearson Education"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们看到 curl 得到的响应与我们预期的是一致的。</p><p>好了，我们不再进一步验证了，你课后还可以自行编译、执行并验证。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们就完成了我们第一个实战小项目，不知道你感觉如何呢？</p><p>这一讲中，我们带你用 Go 语言构建了一个最简单的 HTTP 服务，以及一个接近真实的图书管理 API 服务。在整个实战小项目的实现过程中，你也能初步学习到 Go 编码时常用的一些惯用法，比如基于接口的组合、类似 database/sql 所使用的惯用创建模式，等等。</p><p>通过这节课的学习，你是否体会到了 Go 语言的魅力了呢？是否察觉到 Go 编码与其他主流语言不同的风格了呢？其实不论你的理解程度有多少，都不重要。只要你能“照猫画虎”地将上面的程序自己编写一遍，构建、运行起来并验证一遍，就算是完美达成这一讲的目标了。</p><p>你在这个过程肯定会有各种各样的问题，但没关系，这些问题会成为你继续向下学习 Go 的动力。毕竟，带着问题的学习，能让你的学习过程更有的放矢、更高效。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入口函数与包初始化：搞清Go程序的执行次序</title>
      <link href="/2022/08/27/ru-kou-han-shu-yu-bao-chu-shi-hua-gao-qing-go-cheng-xu-de-zhi-xing-ci-xu/"/>
      <url>/2022/08/27/ru-kou-han-shu-yu-bao-chu-shi-hua-gao-qing-go-cheng-xu-de-zhi-xing-ci-xu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在刚开始学习 Go 语言的时候，我们可能经常会遇到这样一个问题：一个 Go 项目中有数十个 Go 包，每个包中又有若干常量、变量、各种函数和方法，那 Go 代码究竟是从哪里开始执行的呢？后续的执行顺序又是什么样的呢？</p><p>事实上，了解这门语言编写应用的执行次序，对我们写出结构合理、逻辑清晰的程序大有裨益，无论你用的是归属为哪种编程范式（Paradigm）的编程语言，过程式的、面向对象的、函数式的，或是其他编程范式的，我都建议你深入了解一下。</p><p>所以今天这节课，我就带你来了解一下 Go 程序的执行次序，这样在后续阅读和理解 Go 代码的时候，你就好比拥有了“通往宝藏的地图”，可以直接沿着 Go 代码执行次序这张“地图”去阅读和理解 Go 代码了，不会在庞大的代码库中迷失了。</p><p>Go 程序由一系列 Go 包组成，代码的执行也是在各个包之间跳转。和其他语言一样，Go 也拥有自己的用户层入口：main 函数。这节课我们就从 main 函数入手，逐步展开，最终带你掌握 Go 程序的执行次序。</p><p>那么下面，我们就先来看看 Go 应用的入口函数。</p><p><strong>main.main 函数：Go 应用的入口函数</strong></p><p>Go 语言中有一个特殊的函数：main 包中的 main 函数，也就是 main.main，它是所有 Go 可执行程序的用户层执行逻辑的入口函数。Go 程序在用户层面的执行逻辑，会在这个函数内按照它的调用顺序展开。</p><p>main 函数的函数原型是这样的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 用户层执行逻辑</span>    <span class="token operator">...</span> <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，main 函数的函数原型非常简单，没有参数也没有返回值。而且，Go 语言要求：可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。在启动了多个 Goroutine（Go 语言的轻量级用户线程，后面我们会详细讲解）的 Go 应用中，main.main 函数将在 Go 应用的主 Goroutine 中执行。</p><p>不过很有意思的是，在多 Goroutine 的 Go 应用中，相较于 main.main 作为 Go 应用的入口，main.main 函数返回的意义其实更大，因为 main 函数返回就意味着整个 Go 程序的终结，而且你也不用管这个时候是否还有其他子 Goroutine 正在执行。</p><p>另外还值得我们注意的是，除了 main 包外，其他包也可以拥有自己的名为 main 的函数或方法。但按照 Go 的可见性规则（小写字母开头的标识符为非导出标识符），非 main 包中自定义的 main 函数仅限于包内使用，就像下面代码这样，这是一段在非 main 包中定义 main 函数的代码片段：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> pkg1<span class="token keyword">import</span> <span class="token string">"fmt"</span>​<span class="token keyword">func</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main func for pkg1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这里 main 函数就主要是用来在包 pkg1 内部使用的，它是没法在包外使用的。</p><p>好，现在我们已经了解了 Go 应用的入口函数 main.main 的特性。<strong>不过对于 main 包的 main 函数来说，你还需要明确一点，就是它虽然是用户层逻辑的入口函数，但它却不一定是用户层第一个被执行的函数。</strong></p><p><strong>这是为什么呢？这跟 Go 语言的另一个函数 init 有关。</strong></p><p>除了前面讲过的 main.main 函数之外，Go 语言还有一个特殊函数，它就是用于进行包初始化的 init 函数了。</p><p>和 main.main 函数一样，init 函数也是一个无参数无返回值的函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 包初始化逻辑</span>    <span class="token operator">...</span> <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那我们现在回到前面这个“main 函数不一定是用户层第一个被执行的函数”的问题，其实就是因为，如果 main 包依赖的包中定义了 init 函数，或者是 main 包自身定义了 init 函数，那么 Go 程序在这个包初始化的时候，就会自动调用它的 init 函数，因此这些 init 函数的执行就都会发生在 main 函数之前。</p><p>不过对于 init 函数来说，我们还需要注意一点，就是在 Go 程序中我们不能手工显式地调用 init，否则就会收到编译错误，就像下面这个示例，它表示的手工显式调用 init 函数的错误做法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main​<span class="token keyword">import</span> <span class="token string">"fmt"</span>​<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"init invoked"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，在构建并运行上面这些示例代码之后，Go 编译器会报下面这个错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> run call_init.go ./call_init.go:10:2: undefined: init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，Go 包可以拥有不止一个 init 函数，每个组成 Go 包的 Go 源文件中，也可以定义多个 init 函数。</p><p>所以说，在初始化 Go 包时，Go 会按照一定的次序，逐一、顺序地调用这个包的 init 函数。一般来说，先传递给 Go 编译器的源文件中的 init 函数，会先被执行；而同一个源文件中的多个 init 函数，会按声明顺序依次执行。</p><p>那么，现在我们就知晓了 main.main 函数可能并不是第一个被执行的函数的原因了。所以，当我们要在 main.main 函数执行之前，执行一些函数或语句的时候，我们只需要将它放入 init 函数中就可以了。</p><p>了解了这两个函数的执行顺序之后，我们现在就来整体地看看，一个 Go 包的初始化是以何种次序和逻辑进行的。</p><h1 id="Go-包的初始化次序"><a href="#Go-包的初始化次序" class="headerlink" title="Go 包的初始化次序"></a>Go 包的初始化次序</h1><p>我们从程序逻辑结构角度来看，Go 包是程序逻辑封装的基本单元，每个包都可以理解为是一个“自治”的、封装良好的、对外部暴露有限接口的基本单元。一个 Go 程序就是由一组包组成的，程序的初始化就是这些包的初始化。每个 Go 包还会有自己的依赖包、常量、变量、init 函数（其中 main 包有 main 函数）等</p><p>在这里你要注意：<strong>我们在阅读和理解代码的时候，需要知道这些元素在在程序初始化过程中的初始化顺序，这样便于我们确定在某一行代码处这些元素的当前状态。</strong></p><p>下面，我们就通过一张流程图，来了解学习下 Go 包的初始化次序：</p><p><img src="https://static001.geekbang.org/resource/image/e4/0b/e4ddb702876f4f2a0880e4353a390d0b.jpg?wh=1920x1047"></p><p>这里，我们来看看具体的初始化步骤。</p><p>首先，main 包依赖 pkg1 和 pkg4 两个包，所以第一步，Go 会根据包导入的顺序，先去初始化 main 包的第一个依赖包 pkg1。</p><p>第二步，Go 在进行包初始化的过程中，会采用“深度优先”的原则，递归初始化各个包的依赖包。在上图里，pkg1 包依赖 pkg2 包，pkg2 包依赖 pkg3 包，pkg3 没有依赖包，于是 Go 在 pkg3 包中按照“常量 -&gt; 变量 -&gt; init 函数”的顺序先对 pkg3 包进行初始化；</p><p>紧接着，在 pkg3 包初始化完毕后，Go 会回到 pkg2 包并对 pkg2 包进行初始化，接下来再回到 pkg1 包并对 pkg1 包进行初始化。在调用完 pkg1 包的 init 函数后，Go 就完成了 main 包的第一个依赖包 pkg1 的初始化。</p><p>接下来，Go 会初始化 main 包的第二个依赖包 pkg4，pkg4 包的初始化过程与 pkg1 包类似，也是先初始化它的依赖包 pkg5，然后再初始化自身；</p><p>然后，当 Go 初始化完 pkg4 包后也就完成了对 main 包所有依赖包的初始化，接下来初始化 main 包自身。</p><p>最后，在 main 包中，Go 同样会按照“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化，执行完这些初始化工作后才正式进入程序的入口函数 main 函数。</p><p>现在，我们可以通过一段代码示例来验证一下 Go 程序启动后，Go 包的初始化次序是否是正确的，示例程序的结构如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">prog-init-order├── go.mod├── main.go├── pkg1│   └── pkg1.go├── pkg2│   └── pkg2.go└── pkg3    └── pkg3.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们设定的各个包的依赖关系如下：</p><ul><li><p>main 包依赖 pkg1 包和 pkg2 包；</p></li><li><p>pkg1 包和 pkg2 包都依赖 pkg3 包。</p></li></ul><p>这里我只列出了 main 包的代码，pkg1、pkg2 和 pkg3 包的代码与 main 包都是类似的，你可以自己尝试去列一下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main​<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>​    <span class="token boolean">_</span> <span class="token string">"github.com/bigwhite/prog-init-order/pkg1"</span>    <span class="token boolean">_</span> <span class="token string">"github.com/bigwhite/prog-init-order/pkg2"</span><span class="token punctuation">)</span>​<span class="token keyword">var</span> <span class="token punctuation">(</span>    <span class="token boolean">_</span>  <span class="token operator">=</span> <span class="token function">constInitCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    v1 <span class="token operator">=</span> <span class="token function">variableInit</span><span class="token punctuation">(</span><span class="token string">"v1"</span><span class="token punctuation">)</span>    v2 <span class="token operator">=</span> <span class="token function">variableInit</span><span class="token punctuation">(</span><span class="token string">"v2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>​<span class="token keyword">const</span> <span class="token punctuation">(</span>    c1 <span class="token operator">=</span> <span class="token string">"c1"</span>    c2 <span class="token operator">=</span> <span class="token string">"c2"</span><span class="token punctuation">)</span>​<span class="token keyword">func</span> <span class="token function">constInitCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c1 <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: const c1 has been initialized"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> c2 <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: const c2 has been initialized"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">variableInit</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"main: var %s has been initialized\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    <span class="token keyword">return</span> name<span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: first init func invoked"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: second init func invoked"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// do nothing</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，在 main 包中其实并没有使用 pkg1 和 pkg2 中的函数或方法，而是直接通过空导入的方式“触发”pkg1 包和 pkg2 包的初始化（pkg2 包也是通过空导入的方式依赖 pkg3 包的），下面是这个程序的运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> run main.gopkg3: const c has been initializedpkg3: var <span class="token function">v</span> has been initializedpkg3: init func invokedpkg1: const c has been initializedpkg1: var <span class="token function">v</span> has been initializedpkg1: init func invokedpkg2: const c has been initializedpkg2: var <span class="token function">v</span> has been initializedpkg2: init func invokedmain: const c1 has been initializedmain: const c2 has been initializedmain: var v1 has been initializedmain: var v2 has been initializedmain: first init func invokedmain: second init func invoked<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你看，正如我们预期的那样，Go 运行时是按照“pkg3 -&gt; pkg1 -&gt; pkg2 -&gt; main”的顺序，来对 Go 程序的各个包进行初始化的，而在包内，则是以“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化。此外，main 包的两个 init 函数，会按照在源文件 main.go 中的出现次序进行调用。</p><p>还有一点，pkg1 包和 pkg2 包都依赖 pkg3 包，但根据 Go 语言规范，一个被多个包依赖的包仅会初始化一次，因此这里的 pkg3 包仅会被初始化了一次。</p><p>所以简而言之，记住 Go 包的初始化次序并不难，你只需要记住这三点就可以了：</p><ul><li><p>依赖包按“深度优先”的次序进行初始化；</p></li><li><p>每个包内按以“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化；</p></li><li><p>包内的多个 init 函数按出现次序进行自动调用。</p></li></ul><p>到这里，我们已经知道了 Go 程序中包的初始化次序，也了解了每个包中常量、变量以及 init 函数的运行次序，以及 init 函数作为包初始化函数的一些特性。</p><p>搞完了这些最主线的内容之后，不知你有没有发现，我们好像还忘记了一件事：我们好像忘记分析 init 函数的用途了？别急，我们现在就把这落下的功课补上，看看作为 Go 包初始化函数的 init 函数，在日常 Go 语言开发中怎么来使用呢？</p><h1 id="init-函数的用途"><a href="#init-函数的用途" class="headerlink" title="init 函数的用途"></a>init 函数的用途</h1><p>其实，init 函数的这些常用用途，与 init 函数在 Go 包初始化过程中的次序密不可分。我们前面讲过，Go 包初始化时，init 函数的初始化次序在变量之后，这给了开发人员在 init 函数中对包级变量进行进一步检查与操作的机会。</p><p><strong>这里我们先来看 init 函数的第一个常用用途：重置包级变量值。</strong></p><p>init 函数就好比 Go 包真正投入使用之前唯一的“质检员”，负责对包内部以及暴露到外部的包级数据（主要是包级变量）的初始状态进行检查。在 Go 标准库中，我们能发现很多 init 函数被用于检查包级变量的初始状态的例子，标准库 flag 包对 init 函数的使用就是其中的一个，这里我们简单来分析一下。</p><p>flag 包定义了一个导出的包级变量 CommandLine，如果用户没有通过 flag.NewFlagSet 创建新的代表命令行标志集合的实例，那么 CommandLine 就会作为 flag 包各种导出函数背后，默认的代表命令行标志集合的实例。</p><p>而在 flag 包初始化的时候，由于 init 函数初始化次序在包级变量之后，因此包级变量 CommandLine 会在 init 函数之前被初始化了，你可以看一下下面的代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> CommandLine <span class="token operator">=</span> <span class="token function">NewFlagSet</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ExitOnError<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">NewFlagSet</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> errorHandling ErrorHandling<span class="token punctuation">)</span> <span class="token operator">*</span>FlagSet <span class="token punctuation">{</span>    f <span class="token operator">:=</span> <span class="token operator">&amp;</span>FlagSet<span class="token punctuation">{</span>        name<span class="token punctuation">:</span>          name<span class="token punctuation">,</span>        errorHandling<span class="token punctuation">:</span> errorHandling<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    f<span class="token punctuation">.</span>Usage <span class="token operator">=</span> f<span class="token punctuation">.</span>defaultUsage    <span class="token keyword">return</span> f<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>FlagSet<span class="token punctuation">)</span> <span class="token function">defaultUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> f<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Usage:\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Usage of %s:\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    f<span class="token punctuation">.</span><span class="token function">PrintDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，在通过 NewFlagSet 创建 CommandLine 变量绑定的 FlagSet 类型实例时，CommandLine 的 Usage 字段被赋值为 defaultUsage。</p><p>也就是说，如果保持现状，那么使用 flag 包默认 CommandLine 的用户就无法自定义 usage 的输出了。于是，flag 包在 init 函数中重置了 CommandLine 的 Usage 字段</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    CommandLine<span class="token punctuation">.</span>Usage <span class="token operator">=</span> commandLineUsage <span class="token comment">// 重置CommandLine的Usage字段</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">commandLineUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> Usage <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>CommandLine<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Usage of %s:\n"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token function">PrintDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候我们会发现，CommandLine 的 Usage 字段，设置为了一个 flag 包内的未导出函数 commandLineUsage，后者则直接使用了 flag 包的另外一个导出包变量 Usage。这样，就可以通过 init 函数，将 CommandLine 与包变量 Usage 关联在一起了。</p><p>然后，当用户将自定义的 usage 赋值给了 flag.Usage 后，就相当于改变了默认代表命令行标志集合的 CommandLine 变量的 Usage。这样当 flag 包完成初始化后，CommandLine 变量便处于一个合理可用的状态了。</p><p><strong>init 函数的第二个常用用途，是实现对包级变量的复杂初始化。</strong></p><p>有些包级变量需要一个比较复杂的初始化过程，有些时候，使用它的类型零值（每个 Go 类型都具有一个零值定义）或通过简单初始化表达式不能满足业务逻辑要求，而 init 函数则非常适合完成此项工作，标准库 http 包中就有这样一个典型示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    http2VerboseLogs    <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span>    http2logFrameWrites <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span>    http2logFrameReads  <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span>    http2inTests        <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    e <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"GODEBUG"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">"http2debug=1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        http2VerboseLogs <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2VerboseLogs的值进行重置</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">"http2debug=2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        http2VerboseLogs <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2VerboseLogs的值进行重置</span>        http2logFrameWrites <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2logFrameWrites的值进行重置</span>        http2logFrameReads <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2logFrameReads的值进行重置</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，标准库 http 包定义了一系列布尔类型的特性开关变量，它们默认处于关闭状态（即值为 false），但我们可以通过 GODEBUG 环境变量的值，开启相关特性开关。</p><p>可是这样一来，简单地将这些变量初始化为类型零值，就不能满足要求了，所以 http 包在 init 函数中，就根据环境变量 GODEBUG 的值，对这些包级开关变量进行了复杂的初始化，从而保证了这些开关变量在 http 包完成初始化后，可以处于合理状态。</p><p><strong>说完了这个，我们现在来讲 init 函数的第三个常用用途：在 init 函数中实现“注册模式”。</strong></p><p>为了让你更好地理解，首先我们来看一段使用 lib/pq 包访问 PostgreSQL 数据库的代码示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"database/sql"</span>    <span class="token boolean">_</span> <span class="token string">"github.com/lib/pq"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    db<span class="token punctuation">,</span> err <span class="token operator">:=</span> sql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"postgres"</span><span class="token punctuation">,</span> <span class="token string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    age <span class="token operator">:=</span> <span class="token number">21</span>    rows<span class="token punctuation">,</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token string">"SELECT name FROM users WHERE age = $1"</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，这是一段“神奇”的代码，你可以看到示例代码是以空导入的方式导入 lib/pq 包的，main 函数中没有使用 pq 包的任何变量、函数或方法，这样就实现了对 PostgreSQL 数据库的访问。而这一切的奥秘，全在 pq 包的 init 函数中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sql<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token string">"postgres"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Driver<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个奥秘就在，我们其实是利用了用空导入的方式导入 lib/pq 包时产生的一个“副作用”，也就是 lib/pq 包作为 main 包的依赖包，它的 init 函数会在 pq 包初始化的时候得以执行。</p><p>从上面代码中，我们可以看到在 pq 包的 init 函数中，pq 包将自己实现的 sql 驱动注册到了 sql 包中。这样只要应用层代码在 Open 数据库的时候，传入驱动的名字（这里是“postgres”)，那么通过 sql.Open 函数，返回的数据库实例句柄对数据库进行的操作，实际上调用的都是 pq 包中相应的驱动实现。</p><p>实际上，这种通过在 init 函数中注册自己的实现的模式，就有效降低了 Go 包对外的直接暴露，尤其是包级变量的暴露，从而避免了外部通过包级变量对包状态的改动。</p><p>另外，从标准库 database/sql 包的角度来看，这种“注册模式”实质是一种工厂设计模式的实现，sql.Open 函数就是这个模式中的工厂方法，它根据外部传入的驱动名称“生产”出不同类别的数据库实例句柄。</p><p>这种“注册模式”在标准库的其他包中也有广泛应用，比如说，使用标准库 image 包获取各种格式图片的宽和高：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"image"</span>    <span class="token boolean">_</span> <span class="token string">"image/gif"</span> <span class="token comment">// 以空导入方式注入gif图片格式驱动</span>    <span class="token boolean">_</span> <span class="token string">"image/jpeg"</span> <span class="token comment">// 以空导入方式注入jpeg图片格式驱动</span>    <span class="token boolean">_</span> <span class="token string">"image/png"</span> <span class="token comment">// 以空导入方式注入png图片格式驱动</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 支持png, jpeg, gif</span>    width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">imageSize</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 获取传入的图片文件的宽与高</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"get image size error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"image size: [%d, %d]\n"</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">imageSize</span><span class="token punctuation">(</span>imageFile <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>imageFile<span class="token punctuation">)</span> <span class="token comment">// 打开图文文件</span>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> image<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token comment">// 对文件进行解码，得到图片实例</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> err    <span class="token punctuation">}</span>    b <span class="token operator">:=</span> img<span class="token punctuation">.</span><span class="token function">Bounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回图片区域</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span>Max<span class="token punctuation">.</span>X<span class="token punctuation">,</span> b<span class="token punctuation">.</span>Max<span class="token punctuation">.</span>Y<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，上面这个示例程序支持 png、jpeg、gif 三种格式的图片，而达成这一目标的原因，正是 image/png、image/jpeg 和 image/gif 包都在各自的 init 函数中，将自己“注册”到 image 的支持格式列表中了，你可以看看下面这个代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/image/png/reader.go</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span><span class="token function">RegisterFormat</span><span class="token punctuation">(</span><span class="token string">"png"</span><span class="token punctuation">,</span> pngHeader<span class="token punctuation">,</span> Decode<span class="token punctuation">,</span> DecodeConfig<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// $GOROOT/src/image/jpeg/reader.go</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span><span class="token function">RegisterFormat</span><span class="token punctuation">(</span><span class="token string">"jpeg"</span><span class="token punctuation">,</span> <span class="token string">"\xff\xd8"</span><span class="token punctuation">,</span> Decode<span class="token punctuation">,</span> DecodeConfig<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// $GOROOT/src/image/gif/reader.go</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span><span class="token function">RegisterFormat</span><span class="token punctuation">(</span><span class="token string">"gif"</span><span class="token punctuation">,</span> <span class="token string">"GIF8?a"</span><span class="token punctuation">,</span> Decode<span class="token punctuation">,</span> DecodeConfig<span class="token punctuation">)</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，现在我们了解了 init 函数的常见用途。init 函数之所以可以胜任这些工作，恰恰是因为它在 Go 应用初始化次序中的特殊“位次”，也就是 main 函数之前，常量和变量初始化之后。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在这一节课中，我们一起了解了 Go 应用的用户层入口函数 main.main、包初始化函数 init，还有 Go 程序包的初始化次序和包内各种语法元素的初始化次序。</p><p>其中，你需要重点关注 init 函数具备的几种行为特征：</p><ul><li><p>执行顺位排在包内其他语法元素的后面；</p></li><li><p>每个 init 函数在整个 Go 程序生命周期内仅会被执行一次；</p></li><li><p>init 函数是顺序执行的，只有当一个 init 函数执行完毕后，才会去执行下一个 init 函数。</p></li></ul><p>基于上面这些特征，init 函数十分适合做一些包级数据初始化工作以及包级数据初始状态的检查工作，我们也通过实例讲解了 init 函数的这些常见用途。</p><p>最后，大多 Go 程序都是并发程序，程序会启动多个 Goroutine 并发执行程序逻辑，这里你一定要注意主 Goroutine 的优雅退出，也就是主 Goroutine 要根据实际情况来决定，是否要等待其他子 Goroutine 做完清理收尾工作退出后再行退出。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>今天我给你留了一个思考题：当 init 函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？</p><p>分情况而定</p><ol><li>初始化失败的是必要的数据 panic处理 结束进程</li><li>初始化失败的是对业务没影响，可成功可失败的 输出warn或error日志 方便定位</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day02</title>
      <link href="/2022/08/26/yi-yuan-ji-lu-day02/"/>
      <url>/2022/08/26/yi-yuan-ji-lu-day02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是妈妈住院的第四天，昨天做完手术后，妈妈十分难受，疼的一直叫，而且睡不着觉。昨天晚上我留在了医院，一直没有睡着，因为要照顾妈妈，而且还很担心。但是在医院的这几天虽然吃饭的时间不是很固定，而且有时候会头疼。</p><p>希望妈妈早日康复！！！</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建模式：Go Module的6类常规操作</title>
      <link href="/2022/08/24/gou-jian-mo-shi-go-module-de-6-lei-chang-gui-cao-zuo/"/>
      <url>/2022/08/24/gou-jian-mo-shi-go-module-de-6-lei-chang-gui-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过上一节课的讲解，我们掌握了 Go Module 构建模式的基本概念和工作原理，也初步学会了如何通过 go mod 命令，将一个 Go 项目转变为一个 Go Module，并通过 Go Module 构建模式进行构建。</p><p>但是，围绕一个 Go Module，Go 开发人员每天要执行很多 Go 命令对其进行维护。这些维护又是怎么进行的呢？</p><p>具体来说，维护 Go Module 无非就是对 Go Module 依赖包的管理。但在具体工作中还有很多情况，我们接下来会拆分成六个场景，层层深入给你分析。可以说，学好这些是每个 Go 开发人员成长的必经之路。</p><p>我们首先来看一下日常进行 Go 应用开发时遇到的最为频繁的一个场景：<strong>为当前项目添加一个依赖包。</strong></p><h1 id="为当前-module-添加一个依赖"><a href="#为当前-module-添加一个依赖" class="headerlink" title="为当前 module 添加一个依赖"></a>为当前 module 添加一个依赖</h1><p>在一个项目的初始阶段，我们会经常为项目引入第三方包，并借助这些包完成特定功能。即便是项目进入了稳定阶段，随着项目的演进，我们偶尔还需要在代码中引入新的第三方包。</p><p>那么我们如何为一个 Go Module 添加一个新的依赖包呢？</p><p>我们还是以上一节课中讲过的 module-mode 项目为例。如果我们要为这个项目增加一个新依赖：github.com/google/uuid，那需要怎么做呢？</p><p>我们首先会更新源码，就像下面代码中这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"github.com/google/uuid"</span>  <span class="token string">"github.com/sirupsen/logrus"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">NewString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新源码中，我们通过 import 语句导入了 github.com/google/uuid，并在 main 函数中调用了 uuid 包的函数 NewString。此时，如果我们直接构建这个 module，我们会得到一个错误提示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> buildmain.go:4:2: no required module provides package github.com/google/uuid<span class="token punctuation">;</span> to <span class="token function">add</span> it:  go get github.com/google/uuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Go 编译器提示我们，go.mod 里的 require 段中，没有哪个 module 提供了 github.com/google/uuid 包，如果我们要增加这个依赖，可以手动执行 go get 命令。那我们就来按照提示手工执行一下这个命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/google/uuidgo: downloading github.com/google/uuid v1.3.0go get: added github.com/google/uuid v1.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你会发现，go get 命令将我们新增的依赖包下载到了本地 module 缓存里，并在 go.mod 文件的 require 段中新增了一行内容：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">require <span class="token punctuation">(</span>  github<span class="token punctuation">.</span>com<span class="token operator">/</span>google<span class="token operator">/</span>uuid v1<span class="token punctuation">.</span><span class="token number">3.0</span> <span class="token comment">//新增的依赖</span>  github<span class="token punctuation">.</span>com<span class="token operator">/</span>sirupsen<span class="token operator">/</span>logrus v1<span class="token punctuation">.</span><span class="token number">8.1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这新增的一行表明，我们当前项目依赖的是 uuid 的 v1.3.0 版本。我们也可以使用 go mod tidy 命令，在执行构建前自动分析源码中的依赖变化，识别新增依赖项并下载它们：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/google/uuidgo: found github.com/google/uuid <span class="token keyword">in</span> github.com/google/uuid v1.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于我们这个例子而言，手工执行 go get 新增依赖项，和执行 go mod tidy 自动分析和下载依赖项的最终效果，是等价的。但对于复杂的项目变更而言，逐一手工添加依赖项显然很没有效率，go mod tidy 是更佳的选择。</p><p>到这里，我们已经了解了怎么为当前的 module 添加一个新的依赖。但是在日常开发场景中，我们需要对依赖的版本进行更改。那这又要怎么做呢？下面我们就来看看下面升、降级修改依赖版本的场景。</p><h1 id="升级-降级依赖的版本"><a href="#升级-降级依赖的版本" class="headerlink" title="升级 / 降级依赖的版本"></a>升级 / 降级依赖的版本</h1><p>我们先以对依赖的版本进行降级为例，分析一下。</p><p>在实际开发工作中，如果我们认为 Go 命令自动帮我们确定的某个依赖的版本存在一些问题，比如，引入了不必要复杂性导致可靠性下降、性能回退等等，我们可以手工将它降级为之前发布的某个兼容版本。</p><p>那这个操作依赖于什么原理呢？</p><p>答案就是我们上一节课讲过“语义导入版本”机制。我们再来简单复习一下，Go Module 的版本号采用了语义版本规范，也就是版本号使用 vX.Y.Z 的格式。其中 X 是主版本号，Y 为次版本号 (minor)，Z 为补丁版本号 (patch)。主版本号相同的两个版本，较新的版本是兼容旧版本的。如果主版本号不同，那么两个版本是不兼容的。</p><p>有了语义版本号作为基础和前提，我们就可以从容地手工对依赖的版本进行升降级了，Go 命令也可以根据版本兼容性，自动选择出合适的依赖版本了。</p><p>我们还是以上面提到过的 logrus 为例，logrus 现在就存在着多个发布版本，我们可以通过下面命令来进行查询：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> list -m -versions github.com/sirupsen/logrusgithub.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 v0.3.0 v0.4.0 v0.4.1 v0.5.0 v0.5.1 v0.6.0 v0.6.1 v0.6.2 v0.6.3 v0.6.4 v0.6.5 v0.6.6 v0.7.0 v0.7.1 v0.7.2 v0.7.3 v0.8.0 v0.8.1 v0.8.2 v0.8.3 v0.8.4 v0.8.5 v0.8.6 v0.8.7 v0.9.0 v0.10.0 v0.11.0 v0.11.1 v0.11.2 v0.11.3 v0.11.4 v0.11.5 v1.0.0 v1.0.1 v1.0.3 v1.0.4 v1.0.5 v1.0.6 v1.1.0 v1.1.1 v1.2.0 v1.3.0 v1.4.0 v1.4.1 v1.4.2 v1.5.0 v1.6.0 v1.7.0 v1.7.1 v1.8.0 v1.8.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中，基于初始状态执行的 go mod tidy 命令，帮我们选择了 logrus 的最新发布版本 v1.8.1。如果你觉得这个版本存在某些问题，想将 logrus 版本降至某个之前发布的兼容版本，比如 v1.7.0，那么我们可以在项目的 module 根目录下，执行带有版本号的 go get 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/sirupsen/logrus@v1.7.0go: downloading github.com/sirupsen/logrus v1.7.0go get: downgraded github.com/sirupsen/logrus v1.8.1 <span class="token operator">=</span><span class="token operator">&gt;</span> v1.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从这个执行输出的结果，我们可以看到，go get 命令下载了 logrus v1.7.0 版本，并将 go.mod 中对 logrus 的依赖版本从 v1.8.1 降至 v1.7.0。</p><p><strong>当然我们也可以使用万能命令 go mod tidy 来帮助我们降级，但前提是首先要用 go mod edit 命令，明确告知我们要依赖 v1.7.0 版本，而不是 v1.8.1，这个执行步骤是这样的</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod edit -require<span class="token operator">=</span>github.com/sirupsen/logrus@v1.7.0<span class="token variable">$go</span> mod tidy       go: downloading github.com/sirupsen/logrus v1.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>降级后，我们再假设 logrus v1.7.1 版本是一个安全补丁升级，修复了一个严重的安全漏洞，而且我们必须使用这个安全补丁版本，这就意味着我们需要将 logrus 依赖从 v1.7.0 升级到 v1.7.1。</p><p>我们可以使用与降级同样的步骤来完成升级，这里我只列出了使用 go get 实现依赖版本升级的命令和输出结果，你自己动手试一下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/sirupsen/logrus@v1.7.1go: downloading github.com/sirupsen/logrus v1.7.1go get: upgraded github.com/sirupsen/logrus v1.7.0 <span class="token operator">=</span><span class="token operator">&gt;</span> v1.7.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>好了，到这里你就学会了如何对项目依赖包的版本进行升降级了。</p><p>但是你可能会发现一个问题，在前面的例子中，Go Module 的依赖的主版本号都是 1。根据我们上节课中学习的语义导入版本的规范，在 Go Module 构建模式下，当依赖的主版本号为 0 或 1 的时候，我们在 Go 源码中导入依赖包，不需要在包的导入路径上增加版本号，也就是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">import</span> github.com/user/repo/v0 等价于 <span class="token function">import</span> github.com/user/repo<span class="token function">import</span> github.com/user/repo/v1 等价于 <span class="token function">import</span> github.com/user/repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是，如果我们要依赖的 module 的主版本号大于 1，这又要怎么办呢？接着我们就来看看这个场景下该如何去做。</p><h1 id="添加一个主版本号大于-1-的依赖"><a href="#添加一个主版本号大于-1-的依赖" class="headerlink" title="添加一个主版本号大于 1 的依赖"></a>添加一个主版本号大于 1 的依赖</h1><p>这里，我们还是先来回顾一下，上节课我们讲的语义版本规则中对主版本号大于 1 情况有没有相应的说明。</p><p>有的。语义导入版本机制有一个原则：如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，如果新旧两个包不兼容，那么我们就应该采用不同的导入路径。</p><p>按照语义版本规范，如果我们要为项目引入主版本号大于 1 的依赖，比如 v2.0.0，那么由于这个版本与 v1、v0 开头的包版本都不兼容，我们在导入 v2.0.0 包时，不能再直接使用 github.com/user/repo，而要使用像下面代码中那样不同的包导入路径：</p><p><code>import github.com/user/repo/v2/xxx</code></p><p>也就是说，如果我们要为 Go 项目添加主版本号大于 1 的依赖，我们就需要使用“语义导入版本”机制，在声明它的导入路径的基础上，加上版本号信息。我们以“向 module-mode 项目添加 github.com/go-redis/redis 依赖包的 v7 版本”为例，看看添加步骤。</p><p>首先，我们在源码中，以空导入的方式导入 v7 版本的 github.com/go-redis/redis 包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token boolean">_</span> <span class="token string">"github.com/go-redis/redis/v7"</span> <span class="token comment">// “_”为空导入</span>  <span class="token string">"github.com/google/uuid"</span>  <span class="token string">"github.com/sirupsen/logrus"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">NewString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空导入：只执行依赖包的初始化（包括常量、变量的初始化以及init函数的执行），而不在包外显式使用包内的任何语法元素；在实践中，空导入，通常意味着，我们期望依赖包的init函数得以执行，其中有我们需要的逻辑；</strong></p><p>接下来的步骤就与添加兼容依赖一样，我们通过 go get 获取 redis 的 v7 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/go-redis/redis/v7go: downloading github.com/go-redis/redis/v7 v7.4.1go: downloading github.com/go-redis/redis v6.15.9+incompatiblego get: added github.com/go-redis/redis/v7 v7.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，go get 为我们选择了 go-redis v7 版本下当前的最新版本 v7.4.1。</p><p>不过呢，这里说的是为项目添加一个主版本号大于 1 的依赖的步骤。有些时候，出于要使用依赖包最新功能特性等原因，我们可能需要将某个依赖的版本升级为其不兼容版本，也就是主版本号不同的版本，这又该怎么做呢？</p><p>我们还以 go-redis/redis 这个依赖为例，将这个依赖从 v7 版本升级到最新的 v8 版本看看。</p><h1 id="升级依赖版本到一个不兼容版本"><a href="#升级依赖版本到一个不兼容版本" class="headerlink" title="升级依赖版本到一个不兼容版本"></a>升级依赖版本到一个不兼容版本</h1><p>我们前面说了，按照语义导入版本的原则，不同主版本的包的导入路径是不同的。所以，同样地，我们这里也需要先将代码中 redis 包导入路径中的版本号改为 v8：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token boolean">_</span> <span class="token string">"github.com/go-redis/redis/v8"</span>  <span class="token string">"github.com/google/uuid"</span>  <span class="token string">"github.com/sirupsen/logrus"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们再通过 go get 来获取 v8 版本的依赖包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/go-redis/redis/v8go: downloading github.com/go-redis/redis/v8 v8.11.1go: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5fgo: downloading github.com/cespare/xxhash/v2 v2.1.1go get: added github.com/go-redis/redis/v8 v8.11.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们就完成了向一个不兼容依赖版本的升级。是不是很简单啊！</p><p>但是项目继续演化到一个阶段的时候，我们可能还需要移除对之前某个包的依赖。</p><h1 id="移除一个依赖"><a href="#移除一个依赖" class="headerlink" title="移除一个依赖"></a>移除一个依赖</h1><p>我们还是看前面 go-redis/redis 示例，如果我们这个时候不需要再依赖 go-redis/redis 了，你会怎么做呢？</p><p>你可能会删除掉代码中对 redis 的空导入这一行，之后再利用 go build 命令成功地构建这个项目。</p><p>但你会发现，与添加一个依赖时 Go 命令给出友好提示不同，这次 go build 没有给出任何关于项目已经将 go-redis/redis 删除的提示，并且 go.mod 里 require 段中的 go-redis/redis/v8 的依赖依旧存在着。</p><p>我们再通过 go list 命令列出当前 module 的所有依赖，你也会发现 go-redis/redis/v8 仍出现在结果中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> list -m allgithub.com/bigwhite/module-modegithub.com/cespare/xxhash/v2 v2.1.1github.com/davecgh/go-spew v1.1.1<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.github.com/go-redis/redis/v8 v8.11.1<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.gopkg.in/yaml.v2 v2.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是怎么回事呢？</p><p>其实，要想彻底从项目中移除 go.mod 中的依赖项，仅从源码中删除对依赖项的导入语句还不够。这是因为如果源码满足成功构建的条件，go build 命令是不会“多管闲事”地清理 go.mod 中多余的依赖项的。</p><p>那正确的做法是怎样的呢？我们还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。</p><p>到这里，其实我们已经分析了 Go Module 依赖包管理的 5 个常见情况了，但其实还有一种特殊情况，需要我们借用 vendor 机制。</p><h1 id="特殊情况：使用-vendor"><a href="#特殊情况：使用-vendor" class="headerlink" title="特殊情况：使用 vendor"></a>特殊情况：使用 vendor</h1><p>你可能会感到有点奇怪，为什么 Go Module 的维护，还有要用 vendor 的情况？</p><p>其实，vendor 机制虽然诞生于 GOPATH 构建模式主导的年代，但在 Go Module 构建模式下，它依旧被保留了下来，并且成为了 Go Module 构建机制的一个很好的补充。特别是在一些不方便访问外部网络，并且对 Go 应用构建性能敏感的环境，比如在一些内部的持续集成或持续交付环境（CI/CD）中，使用 vendor 机制可以实现与 Go Module 等价的构建。</p><p>和 GOPATH 构建模式不同，Go Module 构建模式下，我们再也无需手动维护 vendor 目录下的依赖包了，Go 提供了可以快速建立和更新 vendor 的命令，我们还是以前面的 module-mode 项目为例，通过下面命令为该项目建立 vendor：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod vendor<span class="token variable">$tree</span> -LF <span class="token number">2</span> vendorvendor├── github.com/│   ├── google/│   ├── magefile/│   └── sirupsen/├── golang.org/│   └── x/└── modules.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，go mod vendor 命令在 vendor 目录下，创建了一份这个项目的依赖包的副本，并且通过 vendor/modules.txt 记录了 vendor 下的 module 以及版本。</p><p>如果我们要基于 vendor 构建，而不是基于本地缓存的 Go Module 构建，我们需要在 go build 后面加上 -mod=vendor 参数。</p><p>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非你给 go build 传入 -mod=mod 的参数。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，到这里，我们就完成了维护 Go Module 的全部常见场景的学习了，现在我们一起来回顾一下吧。</p><p>在通过 go mod init 为当前 Go 项目创建一个新的 module 后，随着项目的演进，我们在日常开发过程中，会遇到多种常见的维护 Go Module 的场景。</p><p>其中最常见的就是为项目添加一个依赖包，我们可以通过 go get 命令手工获取该依赖包的特定版本，更好的方法是通过 go mod tidy 命令让 Go 命令自动去分析新依赖并决定使用新依赖的哪个版本。</p><p>另外，还有几个场景需要你记住：</p><ul><li><p>通过 go get 我们可以升级或降级某依赖的版本，如果升级或降级前后的版本不兼容，这里千万注意别忘了变化包导入路径中的版本号，这是 Go 语义导入版本机制的要求；</p></li><li><p>通过 go mod tidy，我们可以自动分析 Go 源码的依赖变更，包括依赖的新增、版本变更以及删除，并更新 go.mod 中的依赖信息。</p></li><li><p>通过 go mod vendor，我们依旧可以支持 vendor 机制，并且可以对 vendor 目录下缓存的依赖包进行自动管理。</p></li></ul><p>在了解了如何应对 Go Modules 维护的日常工作场景后，你是不是有一种再也不担心 Go 源码构建问题的感觉了呢？</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建模式：Go是怎么解决包依赖管理问题的？</title>
      <link href="/2022/08/24/gou-jian-mo-shi-go-shi-zen-me-jie-jue-bao-yi-lai-guan-li-wen-ti-de/"/>
      <url>/2022/08/24/gou-jian-mo-shi-go-shi-zen-me-jie-jue-bao-yi-lai-guan-li-wen-ti-de/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-构建模式是怎么演化的？"><a href="#Go-构建模式是怎么演化的？" class="headerlink" title="Go 构建模式是怎么演化的？"></a>Go 构建模式是怎么演化的？</h1><p> <strong>Go 程序由 Go 包组合而成的，Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程。</strong></p><p>Go 语言的构建模式历经了三个迭代和演化过程，分别是最初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module。这里我们就先来介绍一下前面这两个。</p><h2 id="首先我们来看-GOPATH。"><a href="#首先我们来看-GOPATH。" class="headerlink" title="首先我们来看 GOPATH。"></a>首先我们来看 GOPATH。</h2><p>Go 语言在首次开源时，就内置了一种名为 GOPATH 的构建模式。在这种构建模式下，Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><p>我这里给出了一段在 GOPATH 构建模式下编写的代码，你先来感受一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/sirupsen/logrus"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, gopath mode"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这段代码依赖了第三方包 logrus（logrus 是 Go 社区使用最为广泛的第三方 log 包）。</p><p>接下来，这个构建过程演示了 Go 编译器（这里使用 Go 1.10.8）在 GOPATH 环境变量所配置的目录下（这里为 /Users/tonybai/Go），无法找到程序依赖的 logrus 包而报错的情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.gomain.go:3:8: cannot <span class="token function">find</span> package <span class="token string">"github.com/sirupsen/logrus"</span> <span class="token keyword">in</span> any of:  /Users/tonybai/.bin/go1.10.8/src/github.com/sirupsen/logrus <span class="token punctuation">(</span>from <span class="token variable">$GOROOT</span><span class="token punctuation">)</span>  /Users/tonybai/Go/src/github.com/sirupsen/logrus <span class="token punctuation">(</span>from <span class="token variable">$GOPATH</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么 Go 编译器在 GOPATH 构建模式下，究竟怎么在 GOPATH 配置的路径下搜寻第三方依赖包呢？</strong></p><p>为了给你说清楚搜寻规则，我们先假定 Go 程序导入了 github.com/user/repo 这个包，我们也同时假定当前 GOPATH 环境变量配置的值为:</p><p><code>export GOPATH=/usr/local/goprojects:/home/tonybai/go</code></p><p>那么在 GOPATH 构建模式下，Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/goprojects/src/github.com/user/repo/home/tonybai/go/src/github.com/user/repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里注意一下，如果你没有显式设置 GOPATH 环境变量，Go 会将 GOPATH 设置为默认值，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，它的默认值是 $HOME/go。</p><p>那么，当遇到像上面例子一样，没有在本地找到程序的第三方依赖包的情况，我们该如何解决这个问题呢？</p><p>我们可以通过 go get 命令将本地缺失的第三方依赖包下载到本地，比如：</p><p><code>$go get github.com/sirupsen/logrus</code></p><p>这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。</p><p>不过，go get 下载的包只是那个时刻各个依赖包的最新主线版本，这样会给后续 Go 程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，得到不同的结果，也就是不能保证可重现的构建（Reproduceable Build）。又比如，如果依赖包引入了不兼容代码，程序将无法通过编译。</p><p>最后还有一点，如果依赖包因引入新代码而无法正常通过编译，并且该依赖包的作者又没用及时修复这个问题，这种错误也会传导到你的程序，导致你的程序无法通过编译。</p><p>也就是说，在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。</p><p><strong>现在我们就来看看 vendor 机制是怎么解决这个问题的。</strong></p><h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h2><p>Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。</p><p>Go 编译器会优先感知和使用 vendor 目录下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。</p><p>如果你将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。</p><p>下面这个目录结构就是为上面的代码示例添加 vendor 目录后的结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span>├── main<span class="token punctuation">.</span><span class="token keyword">go</span>└── vendor<span class="token operator">/</span>    ├── github<span class="token punctuation">.</span>com<span class="token operator">/</span>    │   └── sirupsen<span class="token operator">/</span>    │       └── logrus<span class="token operator">/</span>    └── golang<span class="token punctuation">.</span>org<span class="token operator">/</span>        └── x<span class="token operator">/</span>            └── sys<span class="token operator">/</span>                └── unix<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在添加完 vendor 后，我们重新编译 main.go，这个时候 Go 编译器就会在 vendor 目录下搜索程序依赖的 logrus 包以及后者依赖的 golang.org/x/sys/unix 包了。</p><p><strong>这里你还要注意一点，要想开启 vendor 机制，你的 Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面</strong>。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的。</p><p>不过 vendor 机制虽然一定程度解决了 Go 程序可重现构建的问题，但对开发者来说，它的体验却不那么好。一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。</p><p>另外，你还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等，最让开发者头疼的就是这一点。</p><p>为了解决这个问题，Go 核心团队与社区将 Go 构建的重点转移到如何解决包依赖管理上。Go 社区先后开发了诸如 gb、glide、dep 等工具，来帮助 Go 开发者对 vendor 下的第三方包进行自动依赖分析和管理，但这些工具也都有自身的问题。</p><p>就在 Go 社区为包依赖管理焦虑并抱怨没有官方工具的时候，Go 核心团队基于社区实践的经验和教训，推出了 Go 官方的解决方案：Go Module。</p><h2 id="创建你的第一个-Go-Module"><a href="#创建你的第一个-Go-Module" class="headerlink" title="创建你的第一个 Go Module"></a>创建你的第一个 Go Module</h2><p>从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。</p><p>在04 讲中，我们曾基于 Go Module 构建模式编写过一个“hello, world”程序，当时是为了讲解 Go 程序结构，这里我再带你回顾一下 Go Module 的基础概念。</p><p>一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。</p><p>go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><p>你可能也意识到了，Go Module 的原理和使用方法其实有点复杂，但“千里之行始于足下”，下面我们先从如何创建一个 Go Module 说起。我们先来将上面的例子改造成为一个基于 Go Module 构建模式的 Go 项目。</p><h2 id="创建一个-Go-Module"><a href="#创建一个-Go-Module" class="headerlink" title="创建一个 Go Module"></a>创建一个 Go Module</h2><p>将基于当前项目创建一个 Go Module，通常有如下几个步骤：</p><p>第一步，通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module；</p><p>第二步，通过 go mod tidy 命令自动更新当前 module 的依赖信息；</p><p>第三步，执行 go build，执行新 module 的构建。</p><p>我们一步一步来详细看一下。</p><p>我们先建立一个新项目 module-mode 用来演示 Go Module 的创建，注意我们可以在任意路径下创建这个项目，不必非要在 GOPATH 环境变量的配置路径下。</p><p>这个项目的 main.go 修改自上面的例子，修改后的 main.go 的代码是这样的，我们依旧依赖外部包 logrus：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/sirupsen/logrus"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这个项目目录下只有 main.go 一个源文件，现在我们就来为这个项目添加 Go Module 支持。我们通过 go mod init 命令为这个项目创建一个 Go Module（这里我们使用的是 Go 版本为 1.16.5，Go 1.16 版本默认采用 Go Module 构建模式）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod init github.com/bigwhite/module-modego: creating new go.mod: module github.com/bigwhite/module-modego: to <span class="token function">add</span> module requirements and sums:  go mod tidy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，go mod init 在当前项目目录下创建了一个 go.mod 文件，这个 go.mod 文件将当前项目变为了一个 Go Module，项目根目录变成了 module 根目录。go.mod 的内容是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/bigwhite/module-modego <span class="token number">1.16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个 go.mod 文件现在处于初始状态，它的第一行内容用于声明 module 路径 (module path)，最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p><p>go mod init 命令还输出了两行日志，提示我们可以使用 go mod tidy 命令，添加 module 依赖以及校验和。go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go.mod 文件。我们按照这个提示执行一下 go mod tidy 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/sirupsen/logrusgo: downloading github.com/sirupsen/logrus v1.8.1go: found github.com/sirupsen/logrus <span class="token keyword">in</span> github.com/sirupsen/logrus v1.8.1go: downloading golang.org/x/sys v0.0.0-20191026070338-33540a1f6037go: downloading github.com/stretchr/testify v1.2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，对于一个处于初始状态的 module 而言，go mod tidy 分析了当前 main module 的所有源文件，找出了当前 main module 的所有第三方依赖，确定第三方依赖的版本，还下载了当前 main module 的直接依赖包（比如 logrus），以及相关间接依赖包（直接依赖包的依赖，比如上面的 golang.org/x/sys 等）。</p><p>Go Module 还支持通过 Go Module 代理服务加速第三方依赖的下载。在03 讲我们讲解 Go 环境安装时，就提到过 GOPROXY 环境变量，这个环境变量的默认值为“https: // proxy.golang.org,direct”，不过我们可以配置更适合于中国大陆地区的 Go Module 代理服务。</p><p>由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]/pkg/mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径。</p><p>执行 go mod tidy 后，我们示例 go.mod 的内容更新如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">module github<span class="token punctuation">.</span>com<span class="token operator">/</span>bigwhite<span class="token operator">/</span>module<span class="token operator">-</span>mode<span class="token keyword">go</span> <span class="token number">1.16</span>require github<span class="token punctuation">.</span>com<span class="token operator">/</span>sirupsen<span class="token operator">/</span>logrus v1<span class="token punctuation">.</span><span class="token number">8.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，当前 module 的直接依赖 logrus，还有它的版本信息都被写到了 go.mod 文件的 require 段中。</p><p>而且，执行完 go mod tidy 后，当前项目除了 go.mod 文件外，还多了一个新文件 go.sum，内容是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c<span class="token operator">=</span>github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38<span class="token operator">=</span>github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM<span class="token operator">=</span>github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4<span class="token operator">=</span>github.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE<span class="token operator">=</span>github.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0<span class="token operator">=</span>github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w<span class="token operator">=</span>github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs<span class="token operator">=</span>golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4<span class="token operator">=</span>golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希值。</p><p>这是 Go Module 的一个安全措施。当将来这里的某个 module 的特定版本被再次下载的时候，go 命令会使用 go.sum 文件中对应的哈希值，和新下载的内容的哈希值进行比对，只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的 module 内容，不会被恶意或意外篡改。因此，我推荐你把 go.mod 和 go.sum 两个文件与源码，一并提交到代码版本控制服务器上</p><p>现在，go mod init 和 go mod tidy 已经为我们当前 Go Module 的构建铺平了道路，接下来，我们只需在当前 module 的根路径下，执行 go build 就可以完成 module 的构建了！</p><p>go build 命令会读取 go.mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。</p><p>整个过程的执行步骤是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build<span class="token variable">$ls</span>go.mod    go.sum    main.go    module-mode*$./module-mode INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> hello, go module mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，到这里，我们已经完成了一个有着多个第三方依赖的项目的构建了。但关于 Go Module 的操作还远不止这些。随着 Go 项目的演进，我们会在代码中导入新的第三方包，删除一些旧的依赖包，更新一些依赖包的版本等。关于这些内容，我会在下一节课再给你详细讲解。</p><p>那么，在看到我们的 Go Module 机制会自动分析项目的依赖包，并选出最适合的版本后，不知道你会不会有这样的疑惑：项目所依赖的包有很多版本，Go Module 是如何选出最适合的那个版本的呢？要想回答这个问题，我们就需要深入到 Go Module 构建模式的工作原理中去。</p><h2 id="深入-Go-Module-构建模式"><a href="#深入-Go-Module-构建模式" class="headerlink" title="深入 Go Module 构建模式"></a>深入 Go Module 构建模式</h2><p> Go 语言设计者在设计 Go Module 构建模式，来解决“包依赖管理”的问题时，进行了几项创新，这其中就包括语义导入版本 (Semantic Import Versioning)，以及和其他主流语言不同的最小版本选择 (Minimal Version Selection) 等机制。只要你深入理解了这些机制，你就能真正掌握 Go Module 构建模式。</p><h3 id="首先我们看一下-Go-Module-的语义导入版本机制。"><a href="#首先我们看一下-Go-Module-的语义导入版本机制。" class="headerlink" title="首先我们看一下 Go Module 的语义导入版本机制。"></a>首先我们看一下 Go Module 的语义导入版本机制。</h3><p>在上面的例子中，我们看到 go.mod 的 require 段中依赖的版本号，都符合 vX.Y.Z 的格式。在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成。</p><p>你可以看看下面这张图，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。例如上面的 logrus module 的版本号是 v1.8.1，这就表示它的主版本号为 1，次版本号为 8，补丁版本号为 1。</p><p><img src="https://static001.geekbang.org/resource/image/46/a2/468323b3294cce2ea7f4c1da3699c5a2.png?wh=1242x670"></p><p>Go 命令和 go.mod 文件都使用上面这种符合语义版本规范的版本号，作为描述 Go Module 版本的标准形式。借助于语义版本规范，Go 命令可以确定同一 module 的两个版本发布的先后次序，而且可以确定它们是否兼容。</p><p>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。</p><p>而且，Go Module 规定：<strong>如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的</strong>。怎么理解呢？我们来举个简单示例。我们就以 logrus 为例，它有很多发布版本，我们从中选出两个版本 v1.7.0 和 v1.8.1.。按照上面的语义版本规则，这两个版本的主版本号相同，新版本 v1.8.1 是兼容老版本 v1.7.0 的。那么，我们就可以知道，如果一个项目依赖 logrus，无论它使用的是 v1.7.0 版本还是 v1.8.1 版本，它都可以使用下面的包导入语句导入 logrus 包：</p><p><code>import "github.com/sirupsen/logrus"</code></p><p>那么问题又来了，假如在未来的某一天，logrus 的作者发布了 logrus v2.0.0 版本。那么根据语义版本规则，该版本的主版本号为 2，已经与 v1.7.0、v1.8.1 的主版本号不同了，那么 v2.0.0 与 v1.7.0、v1.8.1 就是不兼容的包版本。然后我们再按照 Go Module 的规定，如果一个项目依赖 logrus v2.0.0 版本，那么它的包导入路径就不能再与上面的导入方式相同了。那我们应该使用什么方式导入 logrus v2.0.0 版本呢？</p><p>Go Module 创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下面这样导入 logrus v2.0.0 版本依赖包：</p><p><code>import "github.com/sirupsen/logrus/v2"</code></p><p>这就是 Go 的“语义导入版本”机制，也就是说通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"github.com/sirupsen/logrus"</span>    logv2 <span class="token string">"github.com/sirupsen/logrus/v2"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过到这里，你可能会问，v0.y.z 版本应该使用哪种导入路径呢？</p><p>按照语义版本规范的说法，v0.y.z 这样的版本号是用于项目初始开发阶段的版本号。在这个阶段任何事情都有可能发生，其 API 也不应该被认为是稳定的。Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径，这样一定程度降低了 Go 开发人员使用这样版本号包时的心智负担。</p><p>Go 语义导入版本机制是 Go Module 机制的基础规则，同样它也是 Go Module 其他规则的基础。</p><h3 id="接下来，我们再来看一下-Go-Module-的最小版本选择原则。"><a href="#接下来，我们再来看一下-Go-Module-的最小版本选择原则。" class="headerlink" title="接下来，我们再来看一下 Go Module 的最小版本选择原则。"></a>接下来，我们再来看一下 Go Module 的最小版本选择原则。</h3><p>在前面的例子中，Go 命令都是在项目初始状态分析项目的依赖，并且项目中两个依赖包之间没有共同的依赖，这样的包依赖关系解决起来还是比较容易的。但依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？</p><p><img src="https://static001.geekbang.org/resource/image/49/1b/49eb7aa0458d8ec6131d9e5661155f1b.jpeg?wh=1920x1080"></p><p>在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0。这个时候，Go 命令是如何为 myproject 选出间接依赖包 C 的版本呢？选出的究竟是 v1.7.0、v1.1.0 还是 v1.3.0 呢？你可以暂停一两分钟思考一下。</p><p>其实，当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。</p><p>当然了，理想状态下，如果语义版本控制被正确应用，并且这种“社会契约”也得到了很好的遵守，那么这种选择算法是有道理的，而且也可以正常工作。在这样的情况下，依赖项的“最新最大版本”应该是最稳定和安全的版本，并且应该有向后兼容性。至少在相同的主版本 (Major Verion) 依赖树中是这样的。</p><p>但我们这个问题的答案并不是这样的。Go 设计者另辟蹊径，在诸多兼容性版本间，他们不光要考虑最新最大的稳定与安全，还要尊重各个 module 的述求：A 明明说只要求 C v1.1.0，B 明明说只要求 C v1.3.0。<strong>所以 Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”</strong></p><p>这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。并且，Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。</p><p>了解了语义导入版本与最小版本选择两种机制后，你就可以说你已经掌握了 Go Module 的精髓。</p><p>但很多 Go 开发人员的起点，并非是默认开启 Go Module 构建模式的 Go 1.16 版本，多数 Go 开发人使用的环境中都存在着多套 Go 版本，有用于体验最新功能特性的 Go 版本，也有某些遗留项目所使用的老版本 Go 编译器。</p><p>它们工作时采用的构建模式是不一样的，并且即便是引入 Go Module 的 Go 1.11 版本，它的 Go Module 机制，和后续进化后的 Go 版本的 Go Module 构建机制在表现行为上也有所不同。因此 Go 开发人员可能需要经常在各个 Go 版本间切换。而明确具体版本下 Go Module 的实际表现行为对 Go 开发人员是十分必要的。</p><h3 id="Go-各版本构建模式机制和切换"><a href="#Go-各版本构建模式机制和切换" class="headerlink" title="Go 各版本构建模式机制和切换"></a>Go 各版本构建模式机制和切换</h3><p>我们前面说了，在 Go 1.11 版本中，Go 开发团队引入 Go Modules 构建模式。这个时候，GOPATH 构建模式与 Go Modules 构建模式各自独立工作，我们可以通过设置环境变量 GO111MODULE 的值在两种构建模式间切换。</p><p>然后，随着 Go 语言的逐步演进，从 Go 1.11 到 Go 1.16 版本，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式几经变化，直到 Go 1.16 版本，Go Module 构建模式成为了默认模式。</p><p>所以，要分析 Go 各版本的具体构建模式的机制和切换，我们只需要找到这几个代表性的版本就好了。</p><p>我这里将 Go 1.13 版本之前、Go 1.13 版本以及 Go 1.16 版本，在 GO111MODULE 为不同值的情况下的行为做了一下对比，这样我们可以更好地理解不同版本下、不同构建模式下的行为特性，下面我们就来用表格形式做一下比对：</p><p><img src="https://static001.geekbang.org/resource/image/45/d3/45bdecc5fa873e06893d6658e447a8d3.jpeg?wh=1920x1080"></p><p>了解了这些，你就能在工作中游刃有余的在各个 Go 版本间切换了，不用再担心切换后模式变化，导致构建失败了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Go 语言最初发布时内置的构建模式为 GOPATH 构建模式。在这种构建模式下，所有构建都离不开 GOPATH 环境变量。在这个模式下，Go 编译器并没有关注依赖包的版本，开发者也无法控制第三方依赖的版本，导致开发者无法实现可重现的构建。</p><p>那么，为了支持可重现构建，Go 1.5 版本引入了 vendor 机制，开发者可以在项目目录下缓存项目的所有依赖，实现可重现构建。但 vendor 机制依旧不够完善，开发者还需要手工管理 vendor 下的依赖包，这就给开发者带来了不小的心智负担。</p><p>后来，Go 1.11 版本中，Go 核心团队推出了新一代构建模式：Go Module 以及一系列创新机制，包括语义导入版本机制、最小版本选择机制等。语义导入版本机制是 Go Moudle 其他机制的基础，它是通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本。而且，Go 命令使用最小版本选择机制进行包依赖版本选择，这和当前主流编程语言，以及 Go 社区之前的包依赖管理工具使用的算法都有点不同。</p><p>外，Go 命令还可以通过 GO111MODULE 环境变量进行 Go 构建模式的切换。但你要注意，从 Go 1.11 到 Go 1.16，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式以及具体表现行为也几经变化，这里你重点看一下前面总结的表格。</p><p>现在，Go 核心团队已经考虑在后续版本中彻底移除 GOPATH 构建模式，Go Module 构建模式将成为 Go 语言唯一的标准构建模式。所以，学完这一课之后，我建议你从现在开始就彻底抛弃 GOPATH 构建模式，全面使用 Go Module 构建模式。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day01</title>
      <link href="/2022/08/24/yi-yuan-ji-lu-day01/"/>
      <url>/2022/08/24/yi-yuan-ji-lu-day01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天去了县医院陪妈妈做检查，明天妈妈就要做手术了。</p><p>妈妈得了子宫肌瘤，虽然大家都说这是一个很常见的病，而且也是个小手术，但是还是很担心，害怕出现意外。而且妈妈也很害怕，因为她也很少住医院，而且也没有做过什么手术，希望明天一切都好。</p><p>每次到了这种时候，我都会想自己的长大跟不上父母衰老的速度，感觉自己现在还是个孩子，很多事情都做不好。而且最重要的就是自己还没有能力赚钱，这样就会感觉自己很没用。所以我有时候会想着不去上研究生，而选择直接就业，这样自己就能早点挣到钱了。</p><p>希望自己以后真的能够挣到差不多的钱，然后给父母一个安稳的晚年。</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准先行: Go项目的布局标准是什么?</title>
      <link href="/2022/08/23/biao-zhun-xian-xing-go-xiang-mu-de-bu-ju-biao-zhun-shi-shi-me/"/>
      <url>/2022/08/23/biao-zhun-xian-xing-go-xiang-mu-de-bu-ju-biao-zhun-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="现在的-Go-项目的典型结构布局是怎样的"><a href="#现在的-Go-项目的典型结构布局是怎样的" class="headerlink" title="现在的 Go 项目的典型结构布局是怎样的?"></a>现在的 Go 项目的典型结构布局是怎样的?</h1><p>一个 Go 项目通常分为可执行程序项目和库项目，现在我们就来分析一下这两类 Go 项目的典型结构布局分别是怎样的。</p><p><strong>首先我们先来看 Go 可执行程序项目的典型结构布局。</strong></p><p>可执行程序项目是以构建可执行程序为目的的项目，Go 社区针对这类 Go 项目所形成的典型结构布局是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -F exe-layout exe-layout├── cmd/│   ├── app1/│   │   └── main.go│   └── app2/│       └── main.go├── go.mod├── go.sum├── internal/│   ├── pkga/│   │   └── pkg_a.go│   └── pkgb/│       └── pkg_b.go├── pkg1/│   └── pkg1.go├── pkg2/│   └── pkg2.go└── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的一个 Go 项目典型布局就是“脱胎”于 Go 创世项目的最新结构布局，我现在跟你解释一下这里面的几个要点。</p><p>我们从上往下按顺序来，先来看 cmd 目录。cmd 目录就是存放项目要编译构建的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。</p><p>而且通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但它的功能其实并没有变。</p><p>接着我们来看 pkgN 目录，这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用。</p><p>然后是 go.mod 和 go.sum，它们是 Go 语言包依赖管理使用的配置文件。我们前面说过，Go 1.11 版本引入了 Go Module 构建机制，这里我建议你所有新项目都基于 Go Module 来进行包依赖管理，因为这是目前 Go 官方推荐的标准构建模式。</p><p>对于还没有使用 Go Module 进行包依赖管理的遗留项目，比如之前采用 dep、glide 等作为包依赖管理工具的，建议尽快迁移到 Go Module 模式。Go 命令支持直接将 dep 的 Gopkg.toml/Gopkg.lock 或 glide 的 glide.yaml/glide.lock 转换为 go.mod。</p><p>最后我们再来看看 vendor 目录。vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定版本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的。</p><p>不过呢，我们这里将 vendor 目录视为一个可选目录。原因在于，Go Module 本身就支持可再现构建，而无需使用 vendor。 当然 Go Module 机制也保留了 vendor 目录（通过 go mod vendor 可以生成 vendor 下的依赖包，通过 go build -mod=vendor 可以实现基于 vendor 的构建）。一般我们仅保留项目根目录下的 vendor 目录，否则会造成不必要的依赖选择的复杂性。</p><p>当然了，有些开发者喜欢借助一些第三方的构建工具辅助构建，比如：make、bazel 等。你可以将这类外部辅助构建工具涉及的诸多脚本文件（比如 Makefile）放置在项目的顶层目录下，就像 Go 创世项目中的 all.bash 那样。</p><p>另外，这里只要说明一下的是，Go 1.11 引入的 module 是一组同属于一个版本管理单元的包的集合。并且 Go 支持在一个项目 / 仓库中存在多个 module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。 因此，如果项目结构中存在版本管理的“分歧”，比如：app1 和 app2 的发布版本并不总是同步的，那么我建议你将项目拆分为多个项目（仓库），每个项目单独作为一个 module 进行单独的版本管理和演进。</p><p>当然如果你非要在一个代码仓库中存放多个 module，那么新版 Go 命令也提供了很好的支持。比如下面代码仓库 multi-modules 下面有三个 module：mainmodule、module1 和 module2：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> multi-modulesmulti-modules├── go.mod // mainmodule├── module1│   └── go.mod // module1└── module2    └── go.mod // module2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过 git tag 名字来区分不同 module 的版本。其中 vX.Y.Z 形式的 tag 名字用于代码仓库下的 mainmodule；而 module1/vX.Y.Z 形式的 tag 名字用于指示 module1 的版本；同理，module2/vX.Y.Z 形式的 tag 名字用于指示 module2 版本。</p><p>如果 Go 可执行程序项目有一个且只有一个可执行程序要构建，那就比较好办了，我们可以将上面项目布局进行简化：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">1</span> -F single-pkg-lib-layoutsingle-pkg-lib-layout├── feature1.go├── feature2.go├── go.mod└── internal/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，我们删除了 cmd 目录，将唯一的可执行程序的 main 包就放置在项目根目录下，而其他布局元素的功用不变。</p><p><strong>好了到这里，我们已经了解了 Go 可执行程序项目的典型布局，现在我们再来看看 Go 库项目的典型结构布局是怎样的。</strong></p><p>Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -F lib-layout lib-layout├── go.mod├── internal/│   ├── pkga/│   │   └── pkg_a.go│   └── pkgb/│       └── pkg_b.go├── pkg1/│   └── pkg1.go└── pkg2/    └── pkg2.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。</p><p>而且，在这里，vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go.mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了。</p><p>Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面。当然 internal 也可以有多个并存在于项目结构中的任一目录层级中，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。</p><p>对于有一个且仅有一个包的 Go 库项目来说，我们也可以将上面的布局做进一步简化，简化的布局如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">1</span> -F single-pkg-lib-layoutsingle-pkg-lib-layout├── feature1.go├── feature2.go├── go.mod└── internal/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化后，我们将这唯一包的所有源文件放置在项目的顶层目录下（比如上面的 feature1.go 和 feature2.go），其他布局元素位置和功用不变。</p><p>好了，现在我们已经了解完目前 Go 项目的典型结构布局了。不过呢，除了这些之外，还要注意一下早期 Go 可执行程序项目的经典布局，这个又有所不同。</p><p><strong>注意早期 Go 可执行程序项目的典型布局</strong></p><p>很多早期接纳 Go 语言的开发者所建立的 Go 可执行程序项目，深受 Go 创世项目 1.4 版本之前的布局影响，这些项目将所有可暴露到外面的 Go 包聚合在 pkg 目录下，就像前面 Go 1.3 版本中的布局那样，它们的典型布局结构是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">3</span> -F early-project-layoutearly-project-layout└── exe-layout/    ├── cmd/    │   ├── app1/    │   └── app2/    ├── go.mod    ├── internal/    │   ├── pkga/    │   └── pkgb/    ├── pkg/    │   ├── pkg1/    │   └── pkg2/    └── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，原本放在项目顶层目录下的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下了。而且，这种早期 Go 可执行程序项目的典型布局在 Go 社区内部也不乏受众，很多新建的 Go 项目依然采用这样的项目布局。</p><p>所以，当你看到这样的布局也不要奇怪，并且在我的讲解后，你应该就明确在这样的布局下 pkg 目录所起到的“聚类”的作用了。不过，在这里还是建议你在创建新的 Go 项目时，优先采用前面的标准项目布局。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们今天这门课就结束了。在这一节课里，我们学习了 Go 创世项目，也就是 Go 语言项目自身的项目源码布局，以及演进情况。在 Go 创世项目的启发下，Go 社区在多年实践中形成了典型的 Go 项目结构布局形式。</p><p>我们将 Go 项目分为可执行程序项目和 Go 库项目两类进行了详细的项目典型布局讲解，这里简单回顾一下。</p><p>首先，对于以生产可执行程序为目的的 Go 项目，它的典型项目结构分为五部分：</p><ul><li><p>放在项目顶层的 Go Module 相关文件，包括 go.mod 和 go.sum；</p></li><li><p>cmd 目录：存放项目要编译构建的可执行文件所对应的 main 包的源码文件；</p></li><li><p>项目包目录：每个项目下的非 main 包都“平铺”在项目的根目录下，每个目录对应一个 Go 包;</p></li><li><p>internal 目录：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；</p></li><li><p>vendor 目录：这是一个可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在的。这个目录下的内容均由 Go 命令自动维护，不需要开发者手工干预。</p></li></ul><p>第二，对于以生产可复用库为目的的 Go 项目，它的典型结构则要简单许多，我们可以直接理解为在 Go 可执行程序项目的基础上去掉 cmd 目录和 vendor 目录。</p><p>最后，早期接纳 Go 语言的开发者所建立的项目的布局深受 Go 创世项目 1.4 版本之前布局的影响，将可导出的公共包放入单独的 pkg 目录下，我们了解这种情况即可。对于新建 Go 项目，我依旧建议你采用前面介绍的标准布局形式。</p><p>现在，如果你要再面对一个要用于生产环境的 Go 应用项目的布局问题，是不是胸有成竹了呢？</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland 使用中的错误</title>
      <link href="/2022/08/23/goland-shi-yong-zhong-de-cuo-wu/"/>
      <url>/2022/08/23/goland-shi-yong-zhong-de-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>遇到问题</li></ul><p><img src="https://img-blog.csdnimg.cn/8c53af32c3b64a37b25f609af5977194.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>解决办法<ul><li>方案一</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/a0aeb21fb7844d788b3afa091a1085d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>删除go.mod</strong></p><p><img src="https://img-blog.csdnimg.cn/3fe3d3c764d54cffa9d8e7805a7ea111.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>产生原因</li></ul><p><strong>开启 Go module 模块支持后，并不能与 GOPATH 共存，所以需要删除其中一个</strong></p><p>现在基本开始使用 Go module ，所以可以将 GOPATH 删除</p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初窥门径: 一个Go程序的结构是怎样的?</title>
      <link href="/2022/08/23/chu-kui-men-jing-yi-ge-go-cheng-xu-de-jie-gou-shi-zen-yang-de/"/>
      <url>/2022/08/23/chu-kui-men-jing-yi-ge-go-cheng-xu-de-jie-gou-shi-zen-yang-de/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编写并运行第一个-Go-程序"><a href="#编写并运行第一个-Go-程序" class="headerlink" title="编写并运行第一个 Go 程序"></a>编写并运行第一个 Go 程序</h1><p><strong>Go 源文件总是用全小写字母形式的短小单词命名，并且以.go扩展名结尾</strong></p><p>如果要在源文件的名字中使用多个单词，我们通常是将多个单词连接起来作为源文件名，而不是使用其他分隔符，比如下划线。比如 hello_world.go</p><p><strong>下划线这种分隔符，在 Go 源文件命名中有特殊作用</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>终端运行</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token variable">$go</span> build main.go$./mainhello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">window<span class="token operator">&gt;</span>go build main.go<span class="token operator">&gt;</span>.<span class="token punctuation">\</span>main.exehello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="示例程序的结构"><a href="#示例程序的结构" class="headerlink" title="示例程序的结构"></a>示例程序的结构</h1><p><code>package main</code></p><p>这一行代码定义了 Go 中的一个包 package。包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属的包，在这里我们的“hello，world”示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。</p><p>main 包中的主要代码是一个名为 main 的函数： </p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>这里的 main 函数会比较特殊：当你运行一个可执行的 Go 程序的时候，所有的代码都会从这个入口函数开始运行</strong>这段代码的第一行声明了一个名为 main 的、没有任何参数和返回值的函数。如果某天你需要给函数声明参数的话，那么就必须把它们放置在圆括号 () 中。</p><p>另外，那对花括号{}被用来标记函数体，Go 要求所有的函数体都要被花括号包裹起来。按照惯例，我们推荐把左花括号与函数声明置于同一行并以空格分隔。Go 语言内置了一套 Go 社区约定俗称的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。</p><p>Gofmt 是 Go 语言在解决规模化（scale）问题上的一个最佳实践，并成为了 Go 语言吸引其他语言开发者的一大卖点。很多其他主流语言也在效仿 Go 语言推出自己的 format 工具，比如：Java formatter、Clang formatter、Dartfmt 等。因此，作为 Go 开发人员，请在提交你的代码前使用 Gofmt 格式化你的 Go 源码。</p><p>好，回到正题，我们再来看一看 main 函数体中的代码：</p><p><code>fmt.Println("hello, world")</code></p><p>注意点 1：标准 Go 代码风格使用 Tab 而不是空格来实现缩进的，当然这个代码风格的格式化工作也可以交由 gofmt 完成</p><p>注意点 2：我们调用了一个名为 Println 的函数，这个函数位于 Go 标准库的 fmt 包中。为了在我们的示例程序中使用 fmt 包定义的 Println 函数，我们其实做了两步操作。</p><ul><li><p>import “fmt” 一行中“fmt”代表的是包的导入路径（Import），它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；</p></li><li><p>fmt.Println 函数调用一行中的“fmt”代表的则是包名</p></li></ul><p>通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的“fmt”指的是包名，其实并不是这样的。</p><p>main 函数体中之所以可以调用 fmt 包的 Println 函数，还有最后一个原因，那就是 Println 函数名的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的（Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅限于在声明它的包内可见。</p><p>另外，在 Go 语言中，main 包是不可以像标准库 fmt 包那样被导入（Import）的，如果导入 main 包，在代码编译阶段你会收到一个 Go 编译器错误：import “xx/main” is a program, not an importable package。</p><p>注意点 3：我们还是回到 main 函数体实现上，把关注点放在传入到 Println 函数的字符串“hello, world”上面。你会发现，我们传入的字符串也就是我们执行程序后在终端的标准输出上看到的字符串。</p><p>这种“所见即所得”得益于 Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式，这与编译后的程序所运行的环境所使用的字符集和字符编码方式是一致的。</p><p>这里，即便我们将代码中的”hello, world”换成中文字符串“你好，世界”，像下面这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好，世界"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最后，不知道你有没有发现，我们整个示例程序源码中，都没有使用过分号来标识语句的结束，这与 C、C++、Java 那些传统编译型语言好像不太一样呀？</strong></p><p>不过，其实 Go 语言的正式语法规范是使用分号“;”来做结尾标识符的。那为什么我们很少在 Go 代码中使用和看到分号呢？这是因为，大多数分号都是可选的，常常被省略，不过在源码编译时，Go 编译器会自动插入这些被省略的分号。</p><p>我们给上面的“hello，world”示例程序加上分号也是完全合法的，是可以直接通过 Go 编译器编译并正常运行的。不过，gofmt 在按约定格式化代码时，会自动删除这些被我们手工加入的分号的。</p><p>在分析完这段代码结构后，我们来讲一下 Go 语言的编译。虽然刚刚你应该已经运行过“hello, world”这个示例程序了，在这过程中，有一个重要的步骤——编译，现在我就带你来看看 Go 语言中程序是怎么进行编译的。</p><h1 id="Go-语言中程序是怎么编译的"><a href="#Go-语言中程序是怎么编译的" class="headerlink" title="Go 语言中程序是怎么编译的?"></a>Go 语言中程序是怎么编译的?</h1><p>你应该也注意到了，刚刚我在运行”hello, world”程序之前，输入了 go build 命令，还有它附带的源文件名参数来编译它：</p><p><code>$go build main.go</code></p><p>假如你曾经有过 C/C++ 语言的开发背景，那么你就会发现这个步骤与 gcc 或 clang 编译十分相似。一旦编译成功，我们就会获得一个二进制的可执行文件。在 Linux 系统、macOS 系统，以及 Windows 系统的 PowerShell 中，我们可以通过输入下面这个 ls 命令看到刚刚生成的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ls</span>main*    main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面显示的文件里面有我们刚刚创建的、以.go 为后缀的源代码文件，还有刚生成的可执行文件（Windows 系统下为 main.exe，其余系统下为 main）。</p><p>如果你之前更熟悉某种类似于 Ruby、Python 或 JavaScript 之类的动态语言，你可能还不太习惯在运行之前需要先进行编译的情况。Go 是一种编译型语言，这意味着只有你编译完 Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境中。</p><p>而如果你交付给其他人的是一份.rb、.py 或.js 的动态语言的源文件，那么他们的目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 实现才能解释执行这些源文件。</p><p>当然，Go 也借鉴了动态语言的一些对开发者体验较好的特性，比如基于源码文件的直接执行，Go 提供了 run 命令可以直接运行 Go 源码文件，比如我们也可以使用下面命令直接基于 main.go 运行：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">$<span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>hello<span class="token punctuation">,</span> world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然像 go run 这类命令更多用于开发调试阶段，真正的交付成果还是需要使用 go build 命令构建的。</p><p>但是在我们的生产环境里，Go 程序的编译往往不会像我们前面，基于单个 Go 源文件构建类似“hello，world”这样的示例程序那么简单。越贴近真实的生产环境，也就意味着项目规模越大、协同人员越多，项目的依赖和依赖的版本都会变得复杂。</p><p>那在我们更复杂的生产环境中，go build 命令也能圆满完成我们的编译任务吗？我们现在就来探讨一下。</p><h1 id="复杂项目下-Go-程序的编译是怎样的"><a href="#复杂项目下-Go-程序的编译是怎样的" class="headerlink" title="复杂项目下 Go 程序的编译是怎样的"></a>复杂项目下 Go 程序的编译是怎样的</h1><p>我们还是直接上项目吧，给 go build 一个机会，看看它的复杂依赖管理到底怎么样。</p><p>现在我们创建一个新项目“hellomodule”，在新项目中我们将使用两个第三方库，zap 和 fasthttp，给 go build 的构建过程增加一些难度。和“hello，world”示例一样，我们通过下面命令创建“hellomodule”项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cd</span> ~/goprojects<span class="token variable">$mkdir</span> hellomodule<span class="token variable">$cd</span> hellomodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着，我们在“hellomodule“下创建并编辑我们的示例源码文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"github.com/valyala/fasthttp"</span>  <span class="token string">"go.uber.org/zap"</span><span class="token punctuation">)</span><span class="token keyword">var</span> logger <span class="token operator">*</span>zap<span class="token punctuation">.</span>Logger<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> zap<span class="token punctuation">.</span><span class="token function">NewProduction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">fastHTTPHandler</span><span class="token punctuation">(</span>ctx <span class="token operator">*</span>fasthttp<span class="token punctuation">.</span>RequestCtx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"hello, go module"</span><span class="token punctuation">,</span> zap<span class="token punctuation">.</span><span class="token function">ByteString</span><span class="token punctuation">(</span><span class="token string">"uri"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">RequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fasthttp<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span> fastHTTPHandler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例创建了一个在 8081 端口监听的 http 服务，当我们向它发起请求后，这个服务会在终端标准输出上输出一段访问日志。</p><p>你会看到，和“hello，world“相比，这个示例显然要复杂许多。但不用担心，你现在大可不必知道每行代码的功用，你只需要我们在这个稍微有点复杂的示例中引入了两个第三方依赖库，zap 和 fasthttp 就可以了。</p><p>我们尝试一下使用编译“hello，world”的方法来编译“hellomodule”中的 main.go 源文件，go 编译器的输出结果是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.gomain.go:4:2: no required module provides package github.com/valyala/fasthttp: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span>main.go:5:2: no required module provides package go.uber.org/zap: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看这结果，这回我们运气似乎不佳，main.go 的编译失败了！</p><p>从编译器的输出来看，go build 似乎在找一个名为 go.mod 的文件，来解决程序对第三方包的依赖决策问题。</p><p><strong>好了，我们也不打哑谜了，是时候让 Go module 登场了！</strong></p><p>Go module 构建模式是在 Go 1.11 版本正式引入的，为的是彻底解决 Go 项目复杂版本依赖的问题，在 Go 1.16 版本中，Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制。</p><p>Go Module 的核心是一个<strong>名为go.mod 的文件</strong>，在这个文件中存储了这个 module 对第三方依赖的全部信息。接下来，我们就通过下面命令为“hello，module”这个示例程序添加 go.mod 文件：</p><p><code>go mod init</code>  <strong>后面的名称，可以自己随意定义，跟本地文件没有关系，使用 github.com/… 作为 module path 是因为多数实用级 module 多是上传到 github 上的。这样是为了便于后续与真实生产接驳。但对于本地开发使用的简单示例程序而言，可以随意命名</strong></p><p><strong>go mod init后面的路径就是go.mod中module后面的路径，代表的是module path。</strong></p><p><strong>go mod init命令的实际行为就是在当前目录下创建一个go.mod，而这个go.mod将当前目录转换为一个go module。</strong></p><p><strong>go module是一个逻辑概念。文中也说了，它更像一个命名空间的概念。它与文件夹名称无关。有了go.mod后，这个文件夹下的各个包就算是这个go module下面的包了。包的导入路径也是以module path为前缀的。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod init github.com/bigwhite/hellomodulego: creating new go.mod: module github.com/bigwhite/hellomodulego: to <span class="token function">add</span> module requirements and sums:  go mod tidy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，go mod init 命令的执行结果是在当前目录下生成了一个 go.mod 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cat</span> go.modmodule github.com/bigwhite/hellomodulego <span class="token number">1.16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。go.mod 所在的目录被我们称为它声明的 module 的根目录。</p><p>不过呢，这个时候的 go.mod 文件内容还比较简单，第一行内容是用于声明 module 路径（module path）的。而且，module 隐含了一个命名空间的概念，module 下每个包的导入路径都是由 module path 和包所在子目录的名字结合在一起构成。</p><p>比如，如果 hellomodule 下有子目录 pkg/pkg1，那么 pkg1 下面的包的导入路径就是由 module path（github.com/bigwhite/hellomodule）和包所在子目录的名字（pkg/pkg1）结合而成，也就是 github.com/bigwhite/hellomodule/pkg/pkg1。</p><p>另外，go.mod 的最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p><p><strong>有了 go.mod 后，是不是我们就可以构建 hellomodule 示例了呢？</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">$<span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> no required module provides <span class="token keyword">package</span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>valyala<span class="token operator">/</span>fasthttp<span class="token punctuation">;</span> to add it<span class="token punctuation">:</span>  <span class="token keyword">go</span> get github<span class="token punctuation">.</span>com<span class="token operator">/</span>valyala<span class="token operator">/</span>fasthttpmain<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> no required module provides <span class="token keyword">package</span> <span class="token keyword">go</span><span class="token punctuation">.</span>uber<span class="token punctuation">.</span>org<span class="token operator">/</span>zap<span class="token punctuation">;</span> to add it<span class="token punctuation">:</span>  <span class="token keyword">go</span> get <span class="token keyword">go</span><span class="token punctuation">.</span>uber<span class="token punctuation">.</span>org<span class="token operator">/</span>zap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，Go 编译器提示源码依赖 fasthttp 和 zap 两个第三方包，但是 go.mod 中没有这两个包的版本信息，我们需要按提示手工添加信息到 go.mod 中。</p><p>这个时候，除了按提示手动添加外，我们也可以使用 go mod tidy 命令，让 Go 工具自动添加：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidy       go: downloading go.uber.org/zap v1.18.1go: downloading github.com/valyala/fasthttp v1.28.0go: downloading github.com/andybalholm/brotli v1.0.2<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果中，我们看到 Go 工具不仅下载并添加了 hellomodule 直接依赖的 zap 和 fasthttp 包的信息，还下载了这两个包的相关依赖包。go mod tidy 执行后，我们 go.mod 的最新内容变成了这个样子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/bigwhite/hellomodulego <span class="token number">1.16</span>require <span class="token punctuation">(</span>  github.com/valyala/fasthttp v1.28.0  go.uber.org/zap v1.18.1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，go.mod 已经记录了 hellomodule 直接依赖的包的信息。不仅如此，hellomodule 目录下还多了一个名为 go.sum 的文件，这个文件记录了 hellomodule 的直接依赖和间接依赖包的相关版本的 hash 值，用来校验本地包的真实性。在构建的时候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建。</p><p>有了 go.mod 以及 hellomodule 依赖的包版本信息后，我们再来执行构建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.go<span class="token variable">$ls</span>go.mod    go.sum    main*    main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这次我们成功构建出了可执行文件 main，运行这个文件，新开一个终端窗口，在新窗口中使用 curl 命令访问该 http 服务：curl localhost:8081/foo/bar，我们就会看到服务端输出如下日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./main<span class="token punctuation">{</span><span class="token string">"level"</span><span class="token builtin class-name">:</span><span class="token string">"info"</span>,<span class="token string">"ts"</span>:1626614126.9899719,<span class="token string">"caller"</span><span class="token builtin class-name">:</span><span class="token string">"hellomodule/main.go:15"</span>,<span class="token string">"msg"</span><span class="token builtin class-name">:</span><span class="token string">"hello, go module"</span>,<span class="token string">"uri"</span><span class="token builtin class-name">:</span><span class="token string">"/foo/bar"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这下，我们的“ hellomodule”程序可算创建成功了。我们也看到使用 Go Module 的构建模式，go build 完全可以承担其构建规模较大、依赖复杂的 Go 项目的重任。还有更多关于 Go Module 的内容，我会在第 7 节课再详细跟你讲解。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们终于亲手编写完成了 Go 语言的第一个程序“hello, world”，我们终于知道一个 Go 程序长成啥样子了，这让我们在自己的 Go 旅程上迈出了坚实的一步！</p><p>在这一节课里，我们通过 helloworld 示例程序，了解了一个 Go 程序的源码结构与代码风格自动格式化的约定。</p><ul><li><p>Go 包是 Go 语言的基本组成单元。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中；</p></li><li><p>Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数；</p></li><li><p>Go 源码需要先编译，再分发和运行。如果是单 Go 源文件的情况，我们可以直接使用 go build 命令 +Go 源文件名的方式编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目的构建。</p></li><li><p>最后，我们结合 hellomodule 示例初步学习了一个基于 Go Module 构建模式编写和构建更大规模 Go 程序的步骤并介绍了 Go Module 涉及到的各种概念。而且，Go Module 机制日渐成熟，我希望你学会基于 Go Module 构建 Go 应用。关于 Go Module 构建模式，我们还会在后面的讲解中详细介绍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cd 命令的使用</title>
      <link href="/2022/08/23/cd-ming-ling-de-shi-yong/"/>
      <url>/2022/08/23/cd-ming-ling-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>cd : Change Directory 切换路径</strong></p><ul><li><p><code>cd /</code> 回到根目录</p></li><li><p><code>cd ..</code> 回到上一层目录</p></li><li><p>进入任意目录</p></li></ul><p>方法一：</p><ol><li><p>直接输入 [该目录所在盘区]:    进入该盘区目录</p></li><li><p>然后输入 cd [在盘区下相对路径]   进入该目录</p><p><img src="https://img-blog.csdnimg.cn/20190806125049779.PNG" alt="在这里插入图片描述"></p></li></ol><p>方法二:</p><p><code>cd /d [对应目录]</code></p><p><img src="https://img-blog.csdnimg.cn/2019080612540499.PNG" alt="在这里插入图片描述"></p><ul><li>显示 cd 帮助及用法</li></ul><p><code>cd/?</code></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 的安装问题</title>
      <link href="/2022/08/23/go-de-an-zhuang-wen-ti/"/>
      <url>/2022/08/23/go-de-an-zhuang-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前安装过 go ，版本为 go1.18</p><p>安装路径设置不正确，没有设置为 Go 文件夹，而是直接安装到了 D:\ 路径下。</p><p>配置环境变量, GOROOT</p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配好环境：选择一种最适合你的Go安装方法</title>
      <link href="/2022/08/23/pei-hao-huan-jing-xuan-ze-yi-chong-zui-gua-he-ni-de-go-an-zhuang-fang-fa/"/>
      <url>/2022/08/23/pei-hao-huan-jing-xuan-ze-yi-chong-zui-gua-he-ni-de-go-an-zhuang-fang-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装-Go"><a href="#安装-Go" class="headerlink" title="安装 Go"></a>安装 Go</h1><h2 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h2><p>Go 几乎支持 Linux 所有的主流发行版操作系统，常见的包括 Ubuntu、CentOS（Redhat 企业版 Linux 的社区开源版）、Fedora、SUSE 等等，Go 在这些主流的 Linux 发行版操作系统上的安装方法都是一样的（当然某个发行版也可能会利用其软件安装管理器提供仅属于其自己的安装方法）。你可以参考下面这样的安装步骤。</p><p>首先，我们需要下载并解压 Go Linux 安装包：</p><p><code>$wget -c https://golang.google.cn/dl/go1.16.5.linux-amd64.tar.gz</code></p><p>这里有个小提醒：虽然 Go 官方下载站点是 golang.org/dl，但我们可以用针对中国大陆的镜像站点 golang.google.cn/dl 来下载，在中国大陆地区使用大陆镜像站点可以大幅缩短下载时间。</p><p>第二步，将下载完毕的 Go 安装包解压到安装目录中：</p><p><code>$tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz</code></p><p>执行完上面解压缩命令后，我们将在 /usr/local 下面看到名为 go 的目录，这个目录就是 Go 的安装目录，也是 Go 官方推荐的 Go 安装目录。我们执行下面命令可以查看该安装目录下的组成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ls</span> -F /usr/local/goAUTHORS          CONTRIBUTORS  PATENTS    SECURITY.md  api/  doc/         lib/   pkg/        src/CONTRIBUTING.md  LICENSE       README.md  VERSION      bin/  favicon.ico  misc/  robots.txt  test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过呢，为了可以在任意路径下使用 go 命令，我们需要将 Go 二进制文件所在路径加入到用户环境变量 PATH 中（以用户使用 bash 为例），具体操作是将下面这行环境变量设置语句添加到 $HOME/.profile 文件的末尾：</p><p><code>export PATH=$PATH:/usr/local/go/bin</code></p><p>然后执行下面命令使上述环境变量的设置立即生效：</p><p><code>$source ~/.profile</code></p><p>最后，我们可以通过下面命令验证此次安装是否成功：</p><p><code>go version</code></p><h2 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h2><p><strong>与linux 几乎没有差别</strong></p><h2 id="Window-安装"><a href="#Window-安装" class="headerlink" title="Window 安装"></a>Window 安装</h2><p>在 Windows 上，我们最好的安装方式就是采用图形界面引导下的 Go 安装方法。</p><p>我们打开Go 包的下载页面&lt;<a href="https://golang.google.cn/dl/">Downloads - The Go Programming Language (google.cn)</a>&gt;，在页面上找到 Go 1.16.5 版本的 Windows msi 安装包（AMD64 架构下的）：go1.16.5.windows-amd64.msi，通过浏览器自带的下载工具它下载到本地任意目录下。</p><p>双击打开已下载的 go1.16.5.windows-amd64.msi 文件，我们就能看到下面这个安装引导界面：</p><p><img src="https://static001.geekbang.org/resource/image/68/2a/686e669aefbbe3ae35e37b0929b9722a.png?wh=618x483"></p><p>和所有使用图形界面方式安装的 Windows 应用程序一样，我们只需一路点击“继续（next）”就可完成 Go 程序的安装了，安装程序默认会把 Go 安装在 C:\Program Files\Go 下面，当然你也可以自己定制你的安装目录。</p><p>除了会将 Go 安装到你的系统中之外，Go 安装程序还会自动为你设置好 Go 使用所需的环境变量，包括在用户环境变量中增加 GOPATH，它的值默认为 C:\Users[用户名]\go，在系统变量中也会为 Path 变量增加一个值：C:\Program Files\Go\bin，这样我们就可以在任意路径下使用 Go 了。</p><h1 id="安装多个-Go-版本"><a href="#安装多个-Go-版本" class="headerlink" title="安装多个 Go 版本"></a>安装多个 Go 版本</h1><h2 id="重新设置-PATH-环境变量"><a href="#重新设置-PATH-环境变量" class="headerlink" title="重新设置 PATH 环境变量"></a>重新设置 PATH 环境变量</h2><p>你只需要将不同版本的 Go 安装在不同路径下，然后将它们的 Go 二进制文件的所在路径加入到 PATH 环境变量中就可以了。</p><p>我们以 Linux 环境为例，在前面介绍 Go 标准安装方法的时候，我们已经将 Go 1.16.5 版本安装到了 /usr/local/go 下面，也将 /usr/local/go/bin 这个路径加入到了 PATH 路径下了，当前状态我们在任意路径下敲入 go，执行的都是 Go 1.16.5 版本对应的 Go 二进制文件。</p><p>那这个时候，如果我们想再安装一个 Go 1.15.13 版本要怎么办呢？首先，你需要按照标准步骤将 Go 1.15.13 安装到事先建好的 /usr/local/go1.15.13 路径下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> /usr/local/go1.15.13<span class="token variable">$wget</span> -c https://golang.google.cn/dl/go1.15.13.linux-amd64.tar.gz<span class="token variable">$tar</span> -C /usr/local/go1.15.13 -xzf go1.15.13.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们来设置 PATH 环境变量，将原先 $HOME/.profile 中的 PATH 变量的值由：</p><p><code>export PATH=$PATH:/usr/local/go/bin</code></p><p>改为:</p><p><code>export PATH=$PATH:/usr/local/go1.15.13/go/bin</code></p><h2 id="go-get-命令"><a href="#go-get-命令" class="headerlink" title="go get 命令"></a>go get 命令</h2><p><strong>这种方法有一个前提，那就是当前系统中已经通过标准方法安装过某个版本的 Go 了。</strong></p><p>我们还以 Linux 环境为例，假设目前环境中已经存在了采用标准方法安装的 Go 1.16.5 版本，我们接下来想再安装一个 Go 1.15.13 版本。按照 Go 官方方法，我们可以这样来做：</p><p>首先，将 $ HOME/go/bin 加入到 PATH 环境变量中并生效，即便这个目录当前不存在也没关系：</p><p><code>export PATH=$PATH:/usr/local/go/bin:~/go/bin</code></p><p>然后，我们要执行下面这个命令安装 Go 1.15.13 版本的下载器：</p><p><code>$go get golang.org/dl/go1.15.13</code></p><p>这个命令会将名为 Go 1.15.13 的可执行文件安装到 $HOME/go/bin 这个目录下，它是 Go 1.15.13 版本的专用下载器，下面我们再来执行 Go 1.15.13 的下载安装命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 downloadDownloaded   <span class="token number">0.0</span>% <span class="token punctuation">(</span>    <span class="token number">16384</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded   <span class="token number">1.8</span>% <span class="token punctuation">(</span>  <span class="token number">2129904</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded  <span class="token number">84.9</span>% <span class="token punctuation">(</span><span class="token number">102792432</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded <span class="token number">100.0</span>% <span class="token punctuation">(</span><span class="token number">121120420</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span>Unpacking /root/sdk/go1.15.13/go1.15.13.linux-amd64.tar.gz <span class="token punctuation">..</span>.Success. You may now run <span class="token string">'go1.15.13'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们看到这个命令下载了 go1.15.13.linux-amd64.tar.gz 安装包，也将它安装到 $HOME/sdk/go1.15.13 下面了。下载安装结束后，我们就可以利用带有版本号的 go 命令来使用特定版本的 Go 了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 versiongo version go1.15.13 linux/amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 <span class="token function">env</span> GOROOT/root/sdk/go1.15.13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="go-get-命令安装非稳定版本"><a href="#go-get-命令安装非稳定版本" class="headerlink" title="go get 命令安装非稳定版本"></a>go get 命令安装非稳定版本</h2><p>其实，除了 Go 团队正式发布的稳定版本 (stable version)，像前面安装的 Go 1.16.5 或 Go 1.15.13，我们还可以通过 go get 的方法安装 Go 团队正在开发的非稳定版本 (Unstable Version)，包括每个稳定版发布前的 beta 版本或当前最新的 tip 版本，这些非稳定版本可以让 Go 开发人员提前体验到即将加入到稳定版本中的新特性。</p><p>但是，通过 go get 安装不同 Go 版本的方法在中国大陆地区会因网络问题而失败。如果你已经克服了网络问题，那安装非稳定版本的步骤其实和上面的步骤一样。现在，我们以 Go 1.17beta1 和 Go Tip 版本为例，带你体验一下它们的安装步骤和验证方法。</p><p>首先我们来看 Go 1.17beta1：</p><h1 id="配置-Go"><a href="#配置-Go" class="headerlink" title="配置 Go"></a>配置 Go</h1><p>其实 Go 在安装后是开箱即用的，这也意味着我们在使用 Go 之前无需做任何配置。但为了更好地了解和学习 Go，我们还是要认识一些 Go 自带的常用配置项。Go 的配置项是以环境变量的形式存在的，我们可以通过下面这个命令查看 Go 的这些配置项：</p><p><code>go env</code></p><p><img src="https://static001.geekbang.org/resource/image/ba/96/ba6990798fb17fc18386749f9cce2c96.jpg?wh=1080x1192"></p><p>如果你还要了解更多关于 Go 配置项的说明，你可以通过 go help environment 命令查看。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，到这里我们的 Go 安装配置方法就讲解完毕了，选好你要使用的 Go 安装方法了吗？在这一节课中我们首先讲解了三种 Go 版本的选择策略：</p><ul><li><p>一种，也是我们推荐的一种，那就是使用 Go 最新的版本，这样你可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能，并且很多老版本中的 bug 在最新版本中都会得到及时修复；</p></li><li><p>如果你还是对最新版本的稳定性有一丝担忧，你也可以选择使用次新版；</p></li><li><p>最后，如果你要考虑现存生产项目或开源项目，那你按照需要选择，与项目策略保持一致就好了。</p></li></ul><p>确定完 Go 版本后，我们就可以来安装这个 Go 版本了。这一节课我们也详细介绍了在三个主流操作系统上安装 Go 稳定版本的方法。</p><p>对于使用 Windows 或 macOS 操作系统的开发者，使用基于图形界面的安装方式显然是最方便、最简洁的；对于使用 Linux 操作系统的开发者，使用自解压的安装包，或者是通过操作系统自带安装工具来进行 Go 安装比较普遍。</p><p>如果你是要在本地开发环境安装多个 Go 版本，或者是要抢先体验新版 Go，我们还讲解了两种在本地安装多个 Go 版本的方法。这里再强调一下，通过 go get 方式安装最新的 Go tip 版本存在失败的可能性哦！</p><p>最后，我们讲解了 Go 的一些常用配置项的功用，对于中国地区的 Go 开发者而言，你在真正使用 Go 构建应用之前，唯一要做的就是配置 GOPROXY 这个 Go 环境变量。</p><p>有了 Go 开发环境，我们就有了编写和构建 Go 代码的基础，在下一讲中我们就将开始学习如何编写 Go 代码。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言的设计哲学是怎么一回事</title>
      <link href="/2022/08/23/go-yu-yan-de-she-ji-zhe-xue-shi-zen-me-yi-hui-shi/"/>
      <url>/2022/08/23/go-yu-yan-de-she-ji-zhe-xue-shi-zen-me-yi-hui-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为</strong></p><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><p>知名 Go 开发者戴维·切尼（Dave Cheney）曾说过：“大多数编程语言创建伊始都致力于成为一门简单的语言，但最终都只是满足于做一个强大的编程语言”。</p><p>而 Go 语言是一个例外。Go 语言的设计者们在语言设计之初，就拒绝了走语言特性融合的道路，选择了“做减法”并致力于打造一门简单的编程语言。</p><p>选择了“简单”，就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。</p><p>其实，Go 语言也没它看起来那么简单，自身实现起来并不容易，但这些复杂性被 Go 语言的设计者们“隐藏”了，所以 Go 语法层面上呈现了这样的状态：</p><ul><li><p>仅有 25 个关键字</p></li><li><p>内置垃圾收集</p></li><li><p>首字母大小写决定可见性，无需通过额外关键字修饰</p></li><li><p>变量初始为类型零值</p></li><li><p>内置数组边界检查</p></li><li><p>内置并发支持，简化并发程序设计</p></li><li><p>内置接口类型，为组合的设计哲学奠定基础</p></li><li><p>原生提供完善的工具链，开箱即用</p></li><li><p>……</p></li></ul><p>看，我说的没错吧，确实挺简单的。当然了，任何的设计都存在着权衡与折中。我们看到 Go 设计者选择的“简单”，其实是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出了自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。</p><p>Go 这种有些“逆潮流”的“简单哲学”并不是一开始就能得到程序员的理解的，但在真正使用 Go 之后，我们才能真正体会到这种简单所带来的收益：简单意味着可以使用更少的代码实现相同的功能；简单意味着代码具有更好的可读性，而可读性好的代码通常意味着更好的可维护性以及可靠性。</p><p>总之，在软件工程化的今天，这些都意味着对生产效率提升的极大促进，<strong>我们可以认为简单的设计哲学是 Go 生产力的源泉。</strong></p><h1 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h1><p>在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，这与 C 语言的“信任程序员”原则完全不同，因此你需要以显式的方式通过转型统一参与计算各个变量的类型。</p><p>除此之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用了显式的基于值比较的错误处理方案，函数 / 方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误的处理。</p><p>这种有悖于“主流语言潮流”的错误处理机制还一度让开发者诟病，社区也提出了多个新错误处理方案，但或多或少都包含隐式的成分，都被 Go 开发团队一一否决了，这也与显式的设计哲学不无关系。</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>这个设计哲学和我们各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中是找不到经典的面向对象语法元素、类型体系和继承机制的，Go 推崇的是组合的设计哲学。</p><p>在诠释组合之前，我们需要先来了解一下 Go 在语法元素设计时，是如何为“组合”哲学的应用奠定基础的。</p><p>在 Go 语言设计层面，Go 设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括：</p><ul><li><p>Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念</p></li><li><p>每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的</p></li><li><p>实现某个接口时，无需想 java 那样采用特定关键字修饰</p></li><li><p>包之间是相对独立的，没有子包的概念</p></li></ul><p>我们可以看到，无论是包、接口还是一个个具体的类型定义，Go 语言其实是为我们呈现了这样的一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。那么现在摆在面前的工作，就是在这些孤岛之间以最适当的方式建立关联，并形成一个整体。<strong>而 Go 选择采用的组合方式，也是最主要的方式。</strong></p><p>Go 语言为支撑组合的设计提供了<strong>类型嵌入（Type Embedding）</strong>。通过类型嵌入，我们可以将已经实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有些类似经典面向对象语言中的“继承”机制，但在原理上却与面向对象中的继承完全不同，这是一种 Go 设计者们精心设计的“语法糖”。</p><p>被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。<strong>这种组合方式，我称之为垂直组合</strong>，即通过类型嵌入，快速让一个新类型“复用”其他类型已经实现的能力，实现功能的垂直扩展。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/sync/pool.go</span><span class="token keyword">type</span> poolLocal <span class="token keyword">struct</span> <span class="token punctuation">{</span>    private <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>       shared  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    Mutex   <span class="token comment">//类型嵌入              </span>    pad     <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口</span><span class="token comment">// $GOROOT/src/io/io.go</span><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>    Reader    Writer<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>垂直组合本质上是一种“能力继承”，采用嵌入方式定义的新类型继承了嵌入类型的能力。Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。</p><p>Go 语言中的接口是一个创新设计，它只是方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间“纽带”。</p><p>水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码段所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/io/ioutil/ioutil.go</span><span class="token keyword">func</span> <span class="token function">ReadAll</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// $GOROOT/src/io/io.go</span><span class="token keyword">func</span> <span class="token function">Copy</span><span class="token punctuation">(</span>dst Writer<span class="token punctuation">,</span> src Reader<span class="token punctuation">)</span><span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起了，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。类似的水平组合“模式”还有点缀器、中间件等，这里我就不展开了，在后面讲到接口类型时再详细叙述。</p><p>此外，我们还可以将 Go 语言内置的并发能力进行灵活组合以实现，比如，通过 goroutine+channel 的组合，可以实现类似 Unix Pipe 的能力。</p><p>总之，组合原则的应用实质上是塑造了 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。并且，组合也让遵循“简单”原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>好，前面我们已经看过 3 个设计哲学了，紧接着我带你看的是第 4 个：并发。</p><p>“并发”这个设计哲学的出现有它的背景，你也知道 CPU 都是靠提高主频来改进性能的，但是现在这个做法已经遇到了瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约了 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。</p><p>在这种大背景下，Go 的设计者在决定去创建一门新语言的时候，果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，<strong>Go 放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程</strong>，Go 将之称为 goroutine。</p><p>goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的栈空间仅 2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。</p><p>在提供了开销较低的 goroutine 的同时，Go 还在语言层面内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。</p><p>此外，并发的设计哲学不仅仅让 Go 在语法层面提供了并发原语支持，其对 Go 应用程序设计的影响更为重要。并发是一种程序结构设计的方法，它使得并行成为可能。采用并发方案设计的程序在单核处理器上也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能。</p><p>而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel+select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言也更适应现代计算环境。</p><h1 id="面向工程"><a href="#面向工程" class="headerlink" title="面向工程"></a>面向工程</h1><p>最后，我们来看一下 Go 的最后一条设计哲学：面向工程。</p><p>Go 语言设计的初衷，就是<strong>面向解决真实世界中 Google 内部大规模软件开发存在的各种问题</strong>，为这些问题提供答案，这些问题包括：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。</p><p>很多编程语言设计者和他们的粉丝们认为这些问题并不是一门编程语言应该去解决的，但 Go 语言的设计者并不这么看，他们在 Go 语言最初设计阶段就将解决工程问题作为 Go 的设计原则之一去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与其他偏学院派、偏研究型的编程语言在设计思路上的一个重大差异。</p><p>语法是编程语言的用户接口，它直接影响开发人员对于这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心的打磨。比如：</p><ul><li><p>重新设计编译单元和目标文件格式，实现 Go 源码快速构建，让大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；</p></li><li><p>如果源文件导入它不使用的包，则程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的。这也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；</p></li><li><p>去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；</p></li><li><p>包路径是唯一的，而包名不必唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的”这个约定，大大降低了开发人员给包起唯一名字的心智负担；</p></li><li><p>故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；</p></li><li><p>增加类型别名（type alias），支持大规模代码库的重构。</p></li></ul><p>在标准库方面，Go 被称为“自带电池”的编程语言。如果说一门编程语言是“自带电池”，则说明这门语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库，Go 语言恰恰就是这类编程语言。</p><p>由于诞生年代较晚，而且目标比较明确，Go 在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto、encoding等包充分迎合了云原生时代的关于 API/RPC Web 服务的构建需求，Go 开发者可以直接基于标准库提供的这些包实现一个满足生产要求的 API 服务，从而减少对外部第三方包或库的依赖，降低工程代码依赖管理的复杂性，也降低了开发人员学习第三方库的心理负担。</p><p>而且，开发人员在工程过程中肯定是需要使用工具的，Go 语言就提供了足以让所有其它主流语言开发人员羡慕的工具链，工具链涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪等方方面面。</p><p>这里值得重点介绍的是 gofmt，它统一了 Go 语言的代码风格，在其他语言开发者还在为代码风格争论不休的时候，Go 开发者可以更加专注于领域业务中。同时，相同的代码风格让以往困扰开发者的代码阅读、理解和评审工作变得容易了很多，至少 Go 开发者再也不会有那种因代码风格的不同而产生的陌生感。Go 的这种统一代码风格思路也在开始影响着后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴 Go 的一些设计。</p><p>在提供丰富的工具链的同时，Go 在标准库中提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> <strong>Go 语言的设计哲学：简单、显式、组合、并发和面向工程</strong></p><ul><li><p>简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；</p></li><li><p>显式是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；</p></li><li><p>组合是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；</p></li><li><p>并发是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；</p></li><li><p>面向工程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前世今生：你不得不了解的Go的历史和现状</title>
      <link href="/2022/08/23/qian-shi-jin-sheng-ni-bu-de-bu-liao-jie-de-go-de-li-shi-he-xian-zhuang/"/>
      <url>/2022/08/23/qian-shi-jin-sheng-ni-bu-de-bu-liao-jie-de-go-de-li-shi-he-xian-zhuang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-语言是怎样诞生的"><a href="#Go-语言是怎样诞生的" class="headerlink" title="Go 语言是怎样诞生的?"></a>Go 语言是怎样诞生的?</h1><p>Go 语言的创始人有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson），Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。</p><p>在罗伯·派克的心目中，“go”这个单词短小、容易输入并且在组合其他字母后便可以用来命名 Go 相关的工具，比如编译器（goc）、汇编器（goa）、链接器（gol）等（go 的早期版本曾如此命名 go 工具链，但后续版本撤销了这种命名方式，仅保留 go 这一统一的工具链名称 ）。</p><p>这里我还想澄清一个误区，很多 Go 语言初学者经常称这门语言为 Golang，其实这是不对的：“Golang”仅应用于命名 Go 语言官方网站，而且当时没有用 go.com 纯粹是这个域名被占用了而已。</p><p>在 Go 语言项目开源后，Go 语言也迎来了自己的“吉祥物”，是一只由罗伯·派克夫人芮妮·弗伦奇（Renee French）设计的地鼠，从此地鼠（gopher）也就成为了世界各地 Go 程序员的象征，Go 程序员也被昵称为 Gopher，在后面的课程中，我会直接使用 Gopher 指代 Go 语言开发者。</p><p><img src="https://static001.geekbang.org/resource/image/75/ab/756c7093c15eb32b5f9476b9fc5fcfab.png?wh=245x300"></p><h1 id="Go-是否值得我们学习？"><a href="#Go-是否值得我们学习？" class="headerlink" title="Go 是否值得我们学习？"></a>Go 是否值得我们学习？</h1><p>时间已经来到了 2021 年。经过了十余年的打磨与优化，如今的 Go 语言已经逐渐成为了云计算时代基础设施的编程语言。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、Istio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等。当然，这个列表还在持续增加，可见 Go 语言的影响力已经十分强大。</p><p>Go 除了在云计算基础设施领域，拥有上面这些杀手级应用之外，Go 语言的用户数量也在近几年快速增加。Go 语言项目技术负责人罗斯·考克斯甚至还专门写过一篇文章，来估算全世界范围的 Gopher 数量。按照他的估算结果，全世界范围的 Gopher 数量从 2017 年年中的最多 100 万，增长到 2019 年 11 月的最多 196 万，大概两年半翻了一番。庞大的 Gopher 基数为 Go 未来的发展提供持续的增长潜力和更大的想象空间。</p><h1 id="Go-语言前景究竟如何，值不值得投入学习呢"><a href="#Go-语言前景究竟如何，值不值得投入学习呢" class="headerlink" title="Go 语言前景究竟如何，值不值得投入学习呢?"></a>Go 语言前景究竟如何，值不值得投入学习呢?</h1><p>从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长的“技术萌芽期”。然后，实现了自举，而且对 GC 延迟进行了大幅优化的 Go 1.5 版本，成为了 Go 语言演化过程中的第一个“引爆点”，推动 Go 语言进入“技术膨胀期”。</p><p>也正是在这段时间内，Go 语言以迅雷不及掩耳盗铃之势推出了以 Docker、Kubernetes 为典型代表的“杀手级应用”，充分展现了实力，在世界范围收获了百万粉丝，迸发出极高的潜力和持续的活力。</p><p>Go 开源于 2009 年末，如果从那时算起，Go 才 11 岁。但在 Go 核心开发团队眼中，Go 的真正诞生年份是 2007 年，距今已 13 个年头有余了。</p><p>回顾一下计算机编程语言的历史，我们会发现，绝大多数主流编程语言，都将在其 15 至 20 年间大步前进。Java、Python、Ruby、JavaScript 和许多其他编程语言都是这样。如今 Go 语言也马上进入自己的黄金 5～10 年，从前面的技术成熟度曲线分析也可以印证这一点：Go 已经重新回到“稳步爬升的光明期”。对于开发人员来说，Go 语言学习的最佳时刻已经到来了！</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言第一课</title>
      <link href="/2022/08/23/go-yu-yan-di-yi-ke/"/>
      <url>/2022/08/23/go-yu-yan-di-yi-ke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择-Go-语言的三大理由"><a href="#选择-Go-语言的三大理由" class="headerlink" title="选择 Go 语言的三大理由"></a>选择 Go 语言的三大理由</h1><ul><li><p>对初学者足够友善，能够快速上手</p><ul><li>Go 是一种非常简单的语言，静态语言</li></ul></li><li><p>生产力与性能的最佳结合</p></li><li><p>快乐又有”钱景“</p><ul><li><p>简单的语法</p></li><li><p>得心应手的工具链</p></li><li><p>丰富和健壮的标准库</p></li></ul></li></ul><h1 id="五个阶段"><a href="#五个阶段" class="headerlink" title="五个阶段"></a>五个阶段</h1><p><img src="https://static001.geekbang.org/resource/image/fc/9d/fcf857acac0ec2512de6f9dd77b1a69d.jpg?wh=1920x1080"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本架构：一个键值数据库包含什么?</title>
      <link href="/2022/08/23/ji-ben-jia-gou-yi-ge-jian-zhi-shu-ju-ku-bao-han-shi-me/"/>
      <url>/2022/08/23/ji-ben-jia-gou-yi-ge-jian-zhi-shu-ju-ku-bao-han-shi-me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>Redis 支持的 value 类型包括了 String、哈希表、列表、集合等</p></li><li><p>数据的基本操作</p><ul><li><p>PUT</p></li><li><p>GET</p></li><li><p>DELETE</p></li><li><p>SCAN，根据一段 key 的范围返回对应的 value 值</p></li></ul></li><li><p>键值对保存在内存</p></li></ul><p><strong>键值数据库的基本结构</strong></p><p><img src="https://static001.geekbang.org/resource/image/ec/d5/ec18bf4b8afef2fa8b99af252d95a2d5.jpg?wh=2360*3791"></p><h2 id="采用什么访问模式"><a href="#采用什么访问模式" class="headerlink" title="采用什么访问模式"></a>采用什么访问模式</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这样学Redis</title>
      <link href="/2022/08/23/zhe-yang-xue-redis/"/>
      <url>/2022/08/23/zhe-yang-xue-redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Reids 知识全景图</strong></p><p><img src="https://static001.geekbang.org/resource/image/79/e7/79da7093ed998a99d9abe91e610b74e7.jpg?wh=2001*1126"></p><p><strong>Redis问题画像图</strong></p><p><img src="https://static001.geekbang.org/resource/image/70/b4/70a5bc1ddc9e3579a2fcb8a5d44118b4.jpeg?wh=2048*1536"></p><p><strong>课程大纲</strong></p><p><img src="https://static001.geekbang.org/resource/image/13/7e/13946f7543f9eea58c9bd2b877826b7e.jpg?wh=750*4458"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习和使用</title>
      <link href="/2022/08/22/git-xue-xi-he-shi-yong/"/>
      <url>/2022/08/22/git-xue-xi-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git分布式版本控制工具</p><p><strong>git 命令总结</strong></p><h2 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h2><ul><li><p>了解 Git 基本概念</p></li><li><p>概述 Git 工作流程</p></li><li><p>使用 Git 常用命令</p></li><li><p>熟悉 Git 代码托管服务</p></li><li><p>能够使用 idea 操作 Git</p></li></ul><h1 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h1><h2 id="2-1、开发中的实际场景"><a href="#2-1、开发中的实际场景" class="headerlink" title="2.1、开发中的实际场景"></a>2.1、开发中的实际场景</h2><ul><li><p>备份，及时进行备份，防止丢失修改</p></li><li><p>代码还原，可以进行代码还原，记录修改记录</p></li><li><p>协同开发，创建分支，可以多人协同开发，进行合并</p></li><li><p>追溯问题代码的编写人和编写时间。可以查看日志，进行问题查看.</p></li></ul><h2 id="2-2、版本控制器的方式"><a href="#2-2、版本控制器的方式" class="headerlink" title="2.2、版本控制器的方式"></a>2.2、版本控制器的方式</h2><ul><li><p>集中式版本控制工具</p><p>集中式版本控制工具，版本库是集中存放在中央服务器中，团队里的成员从中央服务器下载代码，是必须联网才能工作，个人修改后然后提交到中央版本库。</p><p>  举例：SVN和CVS</p></li><li><p>分布式版本控制工具</p><p>分布式版本控制系统没有”中央服务器“，每个人的电脑上都是一个完整的版本库，这样工作的时候，不需要联网。多人协作只需要各自的修改推送给对方，就能相互看到对方的修改了。</p></li></ul><h2 id="2-3、Git工作流程图"><a href="#2-3、Git工作流程图" class="headerlink" title="2.3、Git工作流程图"></a>2.3、Git工作流程图</h2><h1 id="3、Git安装与常用命令"><a href="#3、Git安装与常用命令" class="headerlink" title="3、Git安装与常用命令"></a>3、Git安装与常用命令</h1><h2 id="3-1、Git-环境配置"><a href="#3-1、Git-环境配置" class="headerlink" title="3.1、Git 环境配置"></a>3.1、Git 环境配置</h2><h3 id="3-1-1-下载与安装"><a href="#3-1-1-下载与安装" class="headerlink" title="3.1.1 下载与安装"></a>3.1.1 下载与安装</h3><p>下载地址：<a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p>安装完成后，在桌面或者是文件夹，点击鼠标右键，可以看到两个图标</p><ul><li><p>Git GUI Here: 图形界面工具</p></li><li><p>Git Bash: Git 提供的命令行工具</p></li></ul><h3 id="3-1-2-基本配置"><a href="#3-1-2-基本配置" class="headerlink" title="3.1.2 基本配置"></a>3.1.2 基本配置</h3><ul><li>设置用户名称和email地址<ol><li><p>打开Git Bash</p></li><li><p>设置用户信息</p></li></ol></li></ul><p>git config –global user.name “zzu”</p><p>git config –global user.email “”</p><h3 id="3-1-3-为常用指令配置别名"><a href="#3-1-3-为常用指令配置别名" class="headerlink" title="3.1.3 为常用指令配置别名"></a>3.1.3 为常用指令配置别名</h3><ol><li><p>打开用户目录，创建 .bashrc 文件</p><p><code>touch ~/.bashrc</code></p></li><li><p>在 .bashrc文件中输入你想要设置的命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">一些linux的命令都可以在这里使用<span class="token comment">#用于输出git提交日志</span><span class="token builtin class-name">alias</span> git-log<span class="token operator">=</span><span class="token string">'git log --pretty=online --all --graph --abbrev-commit'</span><span class="token comment">#用于输出当前目录所有文件和基本信息</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ll</span><span class="token operator">=</span><span class="token string">'ls -al'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>打开 gitBash, 执行 source ~/.bashrc</p><p><code>source ~/.bashrc</code></p></li></ol><h3 id="3-1-4-解决-GitBash-乱码问题"><a href="#3-1-4-解决-GitBash-乱码问题" class="headerlink" title="3.1.4 解决 GitBash 乱码问题"></a>3.1.4 解决 GitBash 乱码问题</h3><ol><li><p>打开 GitBash 执行下面命令</p><p><code>git config --global core.quotepath false</code></p></li><li><p>. ${git_home}/etc/bash.bashrc 文件最后加入下面两行</p><p><strong>Linux export 命令用于设置或显示环境变量。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="3-2、获取本地仓库"><a href="#3-2、获取本地仓库" class="headerlink" title="3.2、获取本地仓库"></a>3.2、获取本地仓库</h2><ol><li><p>选择一个空目录作为我们的本地仓库</p></li><li><p>进入这个目录，点击右键打开Git Bash Here窗口</p></li><li><p>执行命令 git init, 初始化仓库</p></li><li><p>创建成功后出现隐藏目录.git</p></li></ol><h2 id="3-3、基础操作命令"><a href="#3-3、基础操作命令" class="headerlink" title="3.3、基础操作命令"></a>3.3、基础操作命令</h2><p><strong>Git 会对仓库中的文件进行状态记录，每一个文件都会有几个状态</strong></p><ol><li><p>git add (工作区 –&gt; 暂存区)</p></li><li><p>git commit (暂存区 –&gt; 本地仓库)</p></li><li><p>git status 查看修改的状态</p></li><li><p>git add . 使用通配符，将工作区的多个文件的修改添加到暂存区</p></li><li><p>git commit -m ‘注释内容’</p></li><li><p>git log [option] 查看提交记录</p><ul><li>options<ul><li><p>-all 显示所有分支</p></li><li><p>–pretty=oneline 将提交信息显示为一行</p></li><li><p>–abbrev-commit 输出结果更加简短</p></li><li><p>–graph 以图的形式显示</p></li></ul></li></ul></li><li><p>git reset –hard commmitID 版本回退，进行版本切换</p><ul><li><p>commmitID 可以使用 git log 指令查看</p></li><li><p>如何查看已经删除的记录</p><ul><li>git reflog</li></ul></li></ul></li></ol><h2 id="3-4、编辑-gitignore文件"><a href="#3-4、编辑-gitignore文件" class="headerlink" title="3.4、编辑 .gitignore文件"></a>3.4、编辑 .gitignore文件</h2><p>并不是所有的文件都需要 git 的管理，比如日志文件，还有编译过程中生成的临时文件等。在这种情况下，我们可以创建一个 .gitignore 文件，列出要忽略的文件模式。</p><pre class="line-numbers language-none"><code class="language-none">HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5、分支"><a href="#3-5、分支" class="headerlink" title="3.5、分支"></a>3.5、分支</h2><p>几乎所有的版本控制系统都已某种形式支持分支。使用分支意味着你可以把你的工作从主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><h3 id="3-5-1、查看本地分支"><a href="#3-5-1、查看本地分支" class="headerlink" title="3.5.1、查看本地分支"></a>3.5.1、查看本地分支</h3><ul><li>git branch</li></ul><h3 id="3-5-2、创建本地分支"><a href="#3-5-2、创建本地分支" class="headerlink" title="3.5.2、创建本地分支"></a>3.5.2、创建本地分支</h3><ul><li>git branch 分支名</li></ul><h3 id="3-5-3、切换分支"><a href="#3-5-3、切换分支" class="headerlink" title="3.5.3、切换分支"></a>3.5.3、切换分支</h3><ul><li><p>git checkout 分支名</p></li><li><p>git checkout -b 分支名 (切换到一个不存在的分支，创建并切换)</p></li></ul><h3 id="3-5-4、合并分支"><a href="#3-5-4、合并分支" class="headerlink" title="3.5.4、合并分支"></a>3.5.4、合并分支</h3><ul><li>git merge 分支名 (合并到当前分支)</li></ul><h3 id="3-5-5、删除分支"><a href="#3-5-5、删除分支" class="headerlink" title="3.5.5、删除分支"></a>3.5.5、删除分支</h3><p><strong>不能删除当前分支，只能删除其他分支</strong></p><ul><li><p>git branch -d 分支名 (删除分支时，需要做各种检查)</p></li><li><p>git branch -D 分支名 (不做任何检查，强制删除)</p></li></ul><h3 id="3-5-6、解决冲突"><a href="#3-5-6、解决冲突" class="headerlink" title="3.5.6、解决冲突"></a>3.5.6、解决冲突</h3><p><strong>不同的分支对同一个文件进行修改，在进行合并时，可能会存在冲突，这个时候需要手动解决冲突</strong></p><ol><li><p>处理文件冲突的地方,进行文件编辑，选择你想要留下的修改</p></li><li><p>将文件加入暂存区(add)</p></li><li><p>提交到仓库(commit)</p></li></ol><h3 id="3-5-7、开发中分支使用的原则和流程"><a href="#3-5-7、开发中分支使用的原则和流程" class="headerlink" title="3.5.7、开发中分支使用的原则和流程"></a>3.5.7、开发中分支使用的原则和流程</h3><ul><li><p>master 生产分支</p></li><li><p>develop 开发分支</p></li><li><p>feature/xxxx分支</p></li><li><p>hotfix/xxxx分支</p></li><li><p>test分支</p></li><li><p>pre分支</p></li></ul><h1 id="4、Git远程仓库"><a href="#4、Git远程仓库" class="headerlink" title="4、Git远程仓库"></a>4、Git远程仓库</h1><h2 id="4-1、常见的远程仓库"><a href="#4-1、常见的远程仓库" class="headerlink" title="4.1、常见的远程仓库"></a>4.1、常见的远程仓库</h2><ul><li><p>github <a href="https://github.com/">https://github.com/</a>是一个面向开源及私有软件项目的托管平台，只支持 Git 作为唯一的版本库格式进行托管。服务器在国外，访问不稳定。</p></li><li><p>码云 <a href="https://gitee.com/">https://gitee.com/</a> 是国内的一个代码托管平台，由于服务器在国内，访问快，稳定。</p></li><li><p>GitLab <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> 是一个用于仓库管理系统的开源项目， 一般用于在企业、学校等内部网络搭建 git 私服。</p></li></ul><h2 id="4-2、注册码云"><a href="#4-2、注册码云" class="headerlink" title="4.2、注册码云"></a>4.2、注册码云</h2><ul><li>注册码云账号 <a href="https://gitee.com/signup">注册 - Gitee.com</a></li></ul><h2 id="4-3、创建远程仓库"><a href="#4-3、创建远程仓库" class="headerlink" title="4.3、创建远程仓库"></a>4.3、创建远程仓库</h2><p><strong>仓库创建后可以查看仓库的地址</strong></p><h2 id="4-4、配置SSH公钥"><a href="#4-4、配置SSH公钥" class="headerlink" title="4.4、配置SSH公钥"></a>4.4、配置SSH公钥</h2><ol><li><p>打开 Git Bash Here ，生成 SSH 公钥</p><ul><li><p>ssh-keygen -t rsa</p></li><li><p>不断回车</p><ul><li>如果公钥已经存在，则自动覆盖</li></ul></li></ul></li><li><p>Gitee 设置账户公钥</p><ul><li>获取公钥<ul><li>cat ~/.ssh/id_rsa.pub</li></ul></li></ul></li><li><p>验证是否配置成功</p><ul><li>ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a></li></ul></li></ol><h2 id="4-5、操作远程仓库"><a href="#4-5、操作远程仓库" class="headerlink" title="4.5、操作远程仓库"></a>4.5、操作远程仓库</h2><h3 id="4-5-1、添加远程仓库"><a href="#4-5-1、添加远程仓库" class="headerlink" title="4.5.1、添加远程仓库"></a>4.5.1、添加远程仓库</h3><p><strong>需要先创建一个本地仓库，然后与远程仓库进行连接</strong></p><ul><li>命令：git remote add &lt;远端名称&gt; &lt;仓库路径&gt;<ul><li><p>远端名称，默认是 origin,取决于远端服务器设置</p></li><li><p>仓库路径，从远端服务器获取此 URL</p></li><li><p><code>git remote add origin https://gitee.com/z1397543194/reggie_take_out.git</code></p></li></ul></li></ul><h3 id="4-5-2、查看远程仓库"><a href="#4-5-2、查看远程仓库" class="headerlink" title="4.5.2、查看远程仓库"></a>4.5.2、查看远程仓库</h3><ul><li>命令：git remote</li></ul><h3 id="4-5-3、推送到远程仓库"><a href="#4-5-3、推送到远程仓库" class="headerlink" title="4.5.3、推送到远程仓库"></a>4.5.3、推送到远程仓库</h3><ul><li>命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名]]<ul><li><p><code>git push origin master</code> 如果远程分支名和本地分支名称统统，则可以只写本地分支</p></li><li><p>-f 表示强制覆盖</p></li><li><p>–set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</p><ul><li><code>git push --set-upstream origin master</code></li></ul></li><li><p>如果当前分支已经和远端分支关联,则可以省略分支名和远端名</p><ul><li>git push 将master分支推送到已关联的远端分支</li></ul></li></ul></li></ul><h3 id="4-5-4、查看本地分支与远程分支的关联关系"><a href="#4-5-4、查看本地分支与远程分支的关联关系" class="headerlink" title="4.5.4、查看本地分支与远程分支的关联关系"></a>4.5.4、查看本地分支与远程分支的关联关系</h3><ul><li>命令：<code>git branch -vv</code></li></ul><h3 id="4-5-5、从远程仓库克隆"><a href="#4-5-5、从远程仓库克隆" class="headerlink" title="4.5.5、从远程仓库克隆"></a>4.5.5、从远程仓库克隆</h3><ul><li>命令： git clone &lt;仓库路径&gt; [本地目录]<ul><li>本地目录可以省略，会自动生成一个目录</li></ul></li></ul><h3 id="4-5-6、从远程仓库中抓取和拉取"><a href="#4-5-6、从远程仓库中抓取和拉取" class="headerlink" title="4.5.6、从远程仓库中抓取和拉取"></a>4.5.6、从远程仓库中抓取和拉取</h3><ul><li><p>抓取命令：<code>git fetch [remote name] [branch name]</code></p><ul><li><p>将仓库里的更新都抓取到本地，不会进行合并</p></li><li><p>如果不指定远端名称和分支名，则抓取所有分支</p></li></ul></li><li><p>拉取命令：<code>git pull [remote name] [branch name]</code></p><ul><li><p>将远端仓库的修改拉到本地并自动进行合并，==&gt;fetch + merge</p></li><li><p>如果不指定远端名称和分支名，则抓取并更新所有分支</p></li></ul></li></ul><h3 id="4-5-7、解决合并冲突"><a href="#4-5-7、解决合并冲突" class="headerlink" title="4.5.7、解决合并冲突"></a>4.5.7、解决合并冲突</h3><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。<br>A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。</p><h1 id="5、在-Idea-中使用-Git"><a href="#5、在-Idea-中使用-Git" class="headerlink" title="5、在 Idea 中使用 Git"></a>5、在 Idea 中使用 Git</h1><h2 id="5-1、在-Idea-中配置-Git"><a href="#5-1、在-Idea-中配置-Git" class="headerlink" title="5.1、在 Idea 中配置 Git"></a>5.1、在 Idea 中配置 Git</h2><h2 id="5-2、操作-Git"><a href="#5-2、操作-Git" class="headerlink" title="5.2、操作 Git"></a>5.2、操作 Git</h2><h3 id="5-2-1、创建远程仓库，使用码云"><a href="#5-2-1、创建远程仓库，使用码云" class="headerlink" title="5.2.1、创建远程仓库，使用码云"></a>5.2.1、创建远程仓库，使用码云</h3><h3 id="5-2-2、初始化本地仓库"><a href="#5-2-2、初始化本地仓库" class="headerlink" title="5.2.2、初始化本地仓库"></a>5.2.2、初始化本地仓库</h3><ul><li><p>在 idea 中创建</p></li><li><p>在目录中，执行 git init</p></li></ul><h3 id="5-2-3、设置远程仓库-或者克隆仓库"><a href="#5-2-3、设置远程仓库-或者克隆仓库" class="headerlink" title="5.2.3、设置远程仓库,或者克隆仓库"></a>5.2.3、设置远程仓库,或者克隆仓库</h3><h3 id="5-2-4、Git-的操作"><a href="#5-2-4、Git-的操作" class="headerlink" title="5.2.4、Git 的操作"></a>5.2.4、Git 的操作</h3><p><strong>git pull + merge / git add + commit / git push</strong></p><ul><li><p>更新项目 Ctrl + T</p></li><li><p>提交 Ctrl + K</p></li><li><p>推送 Ctrl + Shift + K</p></li></ul><h3 id="5-2-5、分支操作"><a href="#5-2-5、分支操作" class="headerlink" title="5.2.5、分支操作"></a>5.2.5、分支操作</h3><h3 id="5-2-6、解决冲突"><a href="#5-2-6、解决冲突" class="headerlink" title="5.2.6、解决冲突"></a>5.2.6、解决冲突</h3><ol><li><p>修改出现冲突的文件</p></li><li><p>add</p></li><li><p>commit</p></li><li><p>git push</p></li></ol><h2 id="5-3、IDEA常用-Git-操作入口"><a href="#5-3、IDEA常用-Git-操作入口" class="headerlink" title="5.3、IDEA常用 Git 操作入口"></a>5.3、IDEA常用 Git 操作入口</h2><h1 id="6、注意事项"><a href="#6、注意事项" class="headerlink" title="6、注意事项"></a>6、注意事项</h1><ul><li><p>切换分支前先提交本地的修改</p></li><li><p>代码写完后，要及时提交</p></li></ul><h2 id="6-1、window-查看隐藏文件-bashrc、-gitignore"><a href="#6-1、window-查看隐藏文件-bashrc、-gitignore" class="headerlink" title="6.1、window 查看隐藏文件(.bashrc、.gitignore)"></a>6.1、window 查看隐藏文件(.bashrc、.gitignore)</h2><h2 id="6-2、window-下创建-bashrc、-gitignore文件"><a href="#6-2、window-下创建-bashrc、-gitignore文件" class="headerlink" title="6.2、window 下创建.bashrc、.gitignore文件"></a>6.2、window 下创建.bashrc、.gitignore文件</h2><ul><li><p>打开git bash here</p></li><li><p><code>touch .gitignore</code></p></li></ul><h2 id="6-3、IDEA集成-GitBash-作为-Terminal"><a href="#6-3、IDEA集成-GitBash-作为-Terminal" class="headerlink" title="6.3、IDEA集成 GitBash 作为 Terminal"></a>6.3、IDEA集成 GitBash 作为 Terminal</h2><p><strong>可以作为git 的命令行，直接输入命令进行操作</strong></p><h1 id="7、学习资源推荐"><a href="#7、学习资源推荐" class="headerlink" title="7、学习资源推荐"></a>7、学习资源推荐</h1><ul><li><p>菜鸟教程 [菜鸟教程](<a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程 (runoob.com)</a>)</p></li><li><p>在线练习网站 [Git](<a href="https://oschina.gitee.io/learn-git-branching/">Learn Git Branching (gitee.io)</a>)</p></li><li><p>廖雪峰教程 [Git](<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window 如何打开终端</title>
      <link href="/2022/08/22/window-ru-he-da-kai-zhong-duan/"/>
      <url>/2022/08/22/window-ru-he-da-kai-zhong-duan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Window 如何打开命令行</strong></p><p>命令行工具有两种 cmd 和 powershell。老一代命令行工具cmd.exe及Windows新一代命令行工具Windows powershell工具，允许管理人员通过命令行的方式来管理计算机。只是相对cmd.exe，powershell的功能要强大的多，可以让管理员更容易地控制系统管理和加速自动化。powershell 是 cmd 的升级版、补充版,增加了很多命令。</p><h2 id="1-通过运行对话框打开"><a href="#1-通过运行对话框打开" class="headerlink" title="1. 通过运行对话框打开"></a>1. 通过运行对话框打开</h2><ul><li><p>win + R 打开运行对话框</p></li><li><p>输入 cmd / powershell</p></li></ul><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-20-58-image.png"></p><h2 id="2-通过开始菜单打开"><a href="#2-通过开始菜单打开" class="headerlink" title="2.通过开始菜单打开"></a>2.通过开始菜单打开</h2><ul><li><p>win + x ，或者在“开始”菜单上右键</p></li><li><p>选择命令提示符 / powershell</p></li></ul><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-21-16-image.png"></p><h1 id="3-在指定目录下打开"><a href="#3-在指定目录下打开" class="headerlink" title="3.在指定目录下打开"></a>3.在指定目录下打开</h1><h3 id="3-1-输入-cmd"><a href="#3-1-输入-cmd" class="headerlink" title="3.1 输入 cmd"></a>3.1 输入 cmd</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-26-52-image.png"></p><h3 id="3-2-shift-鼠标右键"><a href="#3-2-shift-鼠标右键" class="headerlink" title="3.2 shift + 鼠标右键"></a>3.2 shift + 鼠标右键</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-28-03-image.png"></p><h2 id="4-以管理员的身份打开"><a href="#4-以管理员的身份打开" class="headerlink" title="4.以管理员的身份打开"></a>4.以管理员的身份打开</h2><h3 id="4-1-搜索"><a href="#4-1-搜索" class="headerlink" title="4.1 搜索"></a>4.1 搜索</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-29-53-image.png"></p><h3 id="4-2-win-x"><a href="#4-2-win-x" class="headerlink" title="4.2 win + x"></a>4.2 win + x</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-30-24-image.png"></p><h3 id="4-3-在开始菜单中查找-cmd"><a href="#4-3-在开始菜单中查找-cmd" class="headerlink" title="4.3 在开始菜单中查找 cmd"></a>4.3 在开始菜单中查找 cmd</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-33-25-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Window </tag>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 学习</title>
      <link href="/2022/08/22/markdown-xue-xi/"/>
      <url>/2022/08/22/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1.语法</strong><br>**1.1 标题 **<br># 一级标题<br>## 二级标题<br>**1.2 列表 **</p><ul><li>无序列表使用 * 或 + 或 -</li><li>有序列表使用数字加.标识，例如：1.</li><li>无序列表<ul><li>二级列表项</li><li>二级列表项<ul><li>三级列表项，按TAB缩进即可</li></ul></li></ul></li><li>有序列表<ol><li>第一项</li><li>第二项<br><strong>1.3 链接</strong><br><strong>快捷键 Ctrl + k</strong><br><strong>1.3.1 文字超链接</strong><br>[显示的名字](网站)<br><a href="http://www.baidu.com/" title="百度一下">百度</a><br><strong>1.3.2 图像超链接</strong><br>![找不到图像文件时显示的文本](图像路径）<br><strong>1.3.3 索引超链接</strong><br>[显示名称][索引]<br>[索引]:对应的网站<br><a href="http://www.baudu.com/">百度官网</a></li></ol></li></ul><p><strong>1.3.4 自动链接</strong><br>直接用一对尖括号包围即可<br>&lt;网站&gt;<br>电子邮件地址也可以这样做<br><a href="mailto:1397543199@qq.com">1397543199@qq.com</a><br><strong>1.4 代码</strong><br><strong>1.4.1 代码片段</strong><br><strong>段落上的一个函数或片段的代码可以用反引号(<code>切换为英文输入法，在键盘的左上角) 把它包起来，例如：**</code>print(“你好”)`<br>**1.4.2 代码区块**<br>**用三个```或者三个~~~都可以定义代码区块，还可以选择语言种类，对代码进行高亮显示，不过应该不能补全提示，所以建议在ide中编写完成后，复制粘贴</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>1.5 文本</strong></p><pre class="line-numbers language-none"><code class="language-none">文本分段，前后至少保留一个空行即可。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1.5.1 加粗或斜体</strong><br><strong>加粗</strong> ** **<br><em>斜体</em> _ _<br><em><strong>粗斜体</strong></em> *** ***<br><em><strong>粗斜体</strong></em> ___ ___</p><ul><li><p>快捷键：Ctrl + B,可以快速添加加粗效果<br><strong>1.5.2 线条</strong></p></li><li><p>水平线：三个—,在这里不知道为什么加载不出来，别的编辑器可以<br>你好</p></li><li><p>删除线：前后各两个~~ ~~</p><p><del>原价:100</del></p></li><li><p>下划线：和HTML的标签相同，，在这里不知道为什么加载不出来，别的编辑器可以</p><p><u>你好</u></p></li></ul><p><strong>1.5.3 符号或图标</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c168c88c2a94b6fbd6761bc91a7fc62~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8256891606e4821a28dd7a244d1381c~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9506a3b069cb4cf48d98fc1f1a60cf15~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14bca78a45b64fc28bd8059be12b9b36~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbd904891c74d9299d542c9a2fb9b7d~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p>更多图标写法可参考: <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><p><strong>1.5.4 转义字符</strong></p><p>使用反斜杠\插入语法中用到的特殊符号。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d6fafb83a74ff5919539f4aa5dc8d2~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p>例如，如果你需要插入反斜杠，就连续输入两个\即可。<br>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p><p><strong>1.5.5 数学公式</strong></p><p>这个我平时很少使用，就不在这记录了，需要的时候在网上查找</p><p><strong>1.5.6 脚注</strong></p><p>脚注是对文本的补充说明<br>Markdown 脚注的格式如下:</p><p>[^要说明的文本]</p><p><strong>eg</strong></p><p>创建脚注格式类似这样<a href="%E4%BD%A0%E5%A5%BD%EF%BC%81%EF%BC%81%EF%BC%81">^hello</a>。</p><p><strong>1.6 引用</strong></p><p>区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号</p><blockquote><p>冬天来了，春天还会远吗?</p></blockquote><p><strong>1.7 表格</strong></p><p>表格使用 | 来分割不同的单元格，使用 - 来分割表头和其他行</p><table><thead><tr><th>姓名</th><th>年龄</th><th>性别</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>男</td></tr><tr><td>李四</td><td>18</td><td>女</td></tr></tbody></table><p><strong>1.8 样式</strong></p><p>  Markdown 标记语言出现的目的不是替代 HTML，也不是发明一种更便捷的插入HTML标签的方式。它对应的只是HTML标签的一个很小的子集。</p><p><strong>1.8.1 空格标记</strong></p><p>HTML提供好几种空格实体，它们拥有不同的宽度，非断行空格(&nbsp;)是常规空格的宽度，可运行于所有的主流浏览器。</p><ul><li>&nbsp; 不换行空格，全称No-Break Space。</li><li>  半角空格，全称En Space,占据的宽度正好是1/2个中文宽度，而且基本上不受字体的影响。</li><li>  全角空格，全称Em Space,占据的宽度正好是1个中文宽度，而且基本上不受字体的影响。</li><li>&amp;thsisp; 窄空格，全称Thin Space。占据的宽度比较小。</li><li>‌ 零宽不连字，全称Zero Width Non Joiner,是一个不打印字符,抑制本来会发生的连字。</li><li>‍ 零宽连字，全称Zero Width Joiner,产生连字的效果。</li></ul><p><strong>1.8.2 特殊样式，颜色</strong></p><p>【样式的写法】</p><p>不知道为什么，这里也没有效果</p><p>红色的文字</p><p><strong>1.10 图形</strong></p><p><strong>1.10.1 流程图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDStart <span class="token arrow operator">--&gt;</span> Stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDA<span class="token text string">[模块A]</span> <span class="token arrow operator">--&gt;</span><span class="token label property">|A1|</span> B<span class="token text string">(模块B)</span>B <span class="token arrow operator">--&gt;</span> C<span class="token text string">{判断条件C}</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C1|</span> D<span class="token text string">&gt;模块D]</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C2|</span> E<span class="token text string">((模块E))</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C3|</span> F<span class="token text string">["模块F(引号可转义特殊字符)"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.10.2 时序图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">sequenceDiagram</span>Alice<span class="token arrow operator">-&gt;&gt;</span>John<span class="token operator">:</span> Hello John, how are you?John<span class="token arrow operator">--&gt;&gt;</span>Alice<span class="token operator">:</span> Great!Alice<span class="token arrow operator">-)</span>John<span class="token operator">:</span> See you later!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.10.3 甘特图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">gantt</span>title A Gantt DiagramdateFormat  YYYY-MM-DDsection SectionA task           <span class="token operator">:</span>a1, 2014-01-01, 30dAnother task     <span class="token operator">:</span>after a1  , 20dsection AnotherTask in sec      <span class="token operator">:</span>2014-01-12  , 12danother task      <span class="token operator">:</span> 24d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13292f82dd1d45f59c1138fe1bd34dc0~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><strong>2 使用的软件</strong></p><p><strong>2.1 Typora</strong></p><p>之前是免费的，界面简洁，功能强大，现在是收费的。</p><p><strong>2.2 MarkText</strong></p><p>开源免费，支持多个平台。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cd9a9cb609241cbba108653769e7959~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><strong>2.3 ide插件</strong></p><p>VS Code, idea 等软件可以安装Markdown的插件。</p><p>学习使用Markdown<br>草稿箱<br>theme: juejin</p><hr>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 常用命令和命令别名快捷设置</title>
      <link href="/2022/08/22/hexo-chang-yong-ming-ling-he-ming-ling-bie-ming-kuai-jie-she-zhi/"/>
      <url>/2022/08/22/hexo-chang-yong-ming-ling-he-ming-ling-bie-ming-kuai-jie-she-zhi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>每次更新完博客后，都需要执行更新操作，命令较多，所以可以使用别名来减少输入</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><p><code>hexo clean </code>清理缓存</p></li><li><p><code>hexo g</code>  生成静态网页    hexo generate</p></li><li><p><code>hexo s</code>  本地预览            hexo server  默认为4000端口 -p 端口号</p></li><li><p><code>hexo d </code> 部署到 Github, 或者是服务器   hexo deploy</p></li><li><p><code>hexo n "postname"</code>  新建文章   hexo new “”</p></li><li><p><code>hexo n [layout] &lt;title&gt;</code> </p><ul><li>layout 不同，文件保存位置不同</li></ul></li></ul><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><ul><li><p><code>hexo init</code> 文件夹名称  初始化 hexo</p></li><li><p><code>npm update hexo -g</code>  升级</p></li><li><p><code>npm install hexo -g</code>   安装</p></li><li><p><code>node -v</code></p></li><li><p><code>npm -v</code></p></li><li><p><code>git --version</code></p></li><li><p><code>hexo -v</code></p></li><li><p><code>hexo publish [layout] &lt;title&gt;</code> 将草稿移动到 _posts 文件夹中</p><ul><li>草稿默认不会显示在页面中，您可在执行时加上&nbsp;<code>--draft</code>&nbsp;参数，或是把&nbsp;<code>render_drafts</code>&nbsp;参数设为&nbsp;<code>true</code>&nbsp;来预览草稿。</li></ul></li></ul><h1 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h1><p><code>$ hexo new photo "My Gallery"</code></p><p>在执行这行指令时，Hexo 会尝试在&nbsp;<code>scaffolds</code>&nbsp;文件夹中寻找&nbsp;<code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td></tr><tr><td><code>title</code></td><td>标题</td></tr><tr><td><code>date</code></td><td>文件建立日期</td></tr></tbody></table><h1 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h1><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了&nbsp;<code>hexo-renderer-marked</code>&nbsp;和&nbsp;<code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了&nbsp;<code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从&nbsp;<code>md</code>&nbsp;改成&nbsp;<code>ejs</code>，Hexo 就会使用&nbsp;<code>hexo-renderer-ejs</code>&nbsp;渲染这个文件，其他格式同理。</p><p><strong>参考链接：</strong>&lt;<a href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a>&gt;</p><h1 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h1><ol><li><p>打开 Git 的文件夹</p></li><li><p>找到 \Git\etc\bash.bashrc 文件,添加别名</p></li><li><pre><code class="bash">alias hs='hexo clean &amp;&amp; hexo g &amp;&amp; hexo s'alias hd='hexo clean &amp;&amp; hexo g &amp;&amp; hexo d'alias gp='git add . &amp;&amp; git commit -m "update" &amp;&amp; git push -f'</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github、Git 设置代理</title>
      <link href="/2022/08/22/github-git-she-zhi-dai-li/"/>
      <url>/2022/08/22/github-git-she-zhi-dai-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitHub-、Git设置和取消代理"><a href="#GitHub-、Git设置和取消代理" class="headerlink" title="GitHub 、Git设置和取消代理"></a>GitHub 、Git设置和取消代理</h1><h2 id="主要是加速-git-clone-操作"><a href="#主要是加速-git-clone-操作" class="headerlink" title="主要是加速 git clone 操作"></a>主要是加速 git clone 操作</h2><ul><li>git 设置代理</li></ul><p><code>git config --global http.proxy http:127.0.0.1:[10810 这里面是你代理的端口号]</code></p><ul><li>git 取消代理</li></ul><p><code>git config --global --unset http.proxy</code></p><ul><li>针对 github.com 设置代理</li></ul><p><code>git config --global http.https://github.com.proxy http://127.0.0.1:[端口号]</code></p><ul><li>取消 github.com 代理</li></ul><p><code>git config --global --unset http.https://github.com.proxy</code></p><p><strong>注意</strong>：设置代理需要科学上网，可以在软件上查看，也可以在设置里查看</p><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-21-09-36-20-image.png"></p><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-21-09-36-29-image.png"></p><h2 id="ssh-连接-github-失败问题"><a href="#ssh-连接-github-失败问题" class="headerlink" title="ssh 连接 github 失败问题"></a>ssh 连接 github 失败问题</h2><p>设置公钥后，连接失败，显示22端口拒绝,更换为 443 端口</p><p><code>ssh git@github.com</code></p><p><code>ssh: connect to host github.com port 22: Connection refused</code></p><ol><li><p>在任意位置打开 Git Bash Here</p></li><li><p>创建 config 文件</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.ssh/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在里面添加</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com Hostname ssh.github.com Port <span class="token number">443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
