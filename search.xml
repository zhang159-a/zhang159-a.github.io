<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图解Redis</title>
      <link href="/2022/09/08/tu-jie-redis/"/>
      <url>/2022/09/08/tu-jie-redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis-常见面试题"><a href="#Redis-常见面试题" class="headerlink" title="Redis 常见面试题"></a>Redis 常见面试题</h1><p>大家好，我是小林。</p><p>不知不觉《图解 Redis》系列文章写了很多了，考虑到一些同学面试突击 Redis，所以我整理了 3 万字 + 40 张图的 Redis 八股文，共收集了 40 多个面试题。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%85%AB%E8%82%A1%E6%96%87%E6%8F%90%E7%BA%B2.png" alt="提纲"></p><h2 id="认识-Redis"><a href="#认识-Redis" class="headerlink" title="认识 Redis"></a>认识 Redis</h2><h3 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h3><p>我们直接看 Redis 官方是怎么介绍自己的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E7%AE%80%E4%BB%8B.png" alt="img"></p><p>Redis 官方的介绍原版是英文的，我翻译成了中文后截图的，所以有些文字读起来会比较拗口，没关系，我会把里面比较重要的特性抽出来讲一下。</p><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><p>Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p><h3 id="Redis-和-Memcached-有什么区别？"><a href="#Redis-和-Memcached-有什么区别？" class="headerlink" title="Redis 和 Memcached 有什么区别？"></a>Redis 和 Memcached 有什么区别？</h3><p>很多人都说用 Redis 作为缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，我们就要弄清楚 Redis 和 Memcached 的区别。 Redis 与 Memcached <strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p>Redis 与 Memcached <strong>区别</strong>：</p><ul><li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li></ul><h3 id="为什么用-Redis-作为-MySQL-的缓存？"><a href="#为什么用-Redis-作为-MySQL-的缓存？" class="headerlink" title="为什么用 Redis 作为 MySQL 的缓存？"></a>为什么用 Redis 作为 MySQL 的缓存？</h3><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p><p><em><strong>1、Redis 具备高性能</strong></em></p><p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/37e4378d2edcb5e217b00e5f12973efd.png" alt="img"></p><p>如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。</p><p><em><strong>2、 Redis 具备高并发</strong></em></p><p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p><p>所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h3 id="Redis-数据类型以及使用场景分别是什么？"><a href="#Redis-数据类型以及使用场景分别是什么？" class="headerlink" title="Redis 数据类型以及使用场景分别是什么？"></a>Redis 数据类型以及使用场景分别是什么？</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/key.png" alt="img"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="img"></p><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。 Redis 五种数据类型的应用场景：</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><blockquote><p>TIP</p><p>想深入了解这 9 种数据类型，可以看这篇：<a href="https://xiaolincoding.com/redis/data_struct/command.html">2万字 + 20 张图 ｜ 细说 Redis 常见数据类型和应用场景</a></p></blockquote><h3 id="五种常见的-Redis-数据类型是怎么实现？"><a href="#五种常见的-Redis-数据类型是怎么实现？" class="headerlink" title="五种常见的 Redis 数据类型是怎么实现？"></a>五种常见的 Redis 数据类型是怎么实现？</h3><p>我画了一张 Redis 数据类型和底层数据结构的对应关图，左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Redis 7.0 版本的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9fa26a74965efbf0f56b707a03bb9b7f.png" alt="img"></p><blockquote><p>String 类型内部实现</p></blockquote><p>String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><blockquote><p>List 类型内部实现</p></blockquote><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p><blockquote><p>Hash 类型内部实现</p></blockquote><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><blockquote><p>Set 类型内部实现</p></blockquote><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><blockquote><p>ZSet 类型内部实现</p></blockquote><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><blockquote><p>TIP</p><p>想深入了解这 9 种数据结构，可以看这篇：<a href="https://xiaolincoding.com/redis/data_struct/data_struct.html">2万字 + 40 张图 ｜ 细说 Redis 数据结构</a></p></blockquote><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="Redis-是单线程吗？"><a href="#Redis-是单线程吗？" class="headerlink" title="Redis 是单线程吗？"></a>Redis 是单线程吗？</h3><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li></ul><p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg" alt="img"></p><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p><ul><li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li><li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li><li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；</li></ul><h3 id="Redis-单线程模式是怎样的？"><a href="#Redis-单线程模式是怎样的？" class="headerlink" title="Redis 单线程模式是怎样的？"></a>Redis 单线程模式是怎样的？</h3><p>Redis 6.0 版本之前的单线模式如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png" alt="img"></p><p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I/O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解MySQL</title>
      <link href="/2022/09/08/tu-jie-mysql/"/>
      <url>/2022/09/08/tu-jie-mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="执行一条-select-语句，期间发生了什么？"><a href="#执行一条-select-语句，期间发生了什么？" class="headerlink" title="执行一条 select 语句，期间发生了什么？"></a>执行一条 select 语句，期间发生了什么？</h1><p>学习 SQL 的时候，大家肯定第一个先学到的就是 select 查询语句了，比如下面这句查询语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">// 在 product 表中，查询 id = 1 的记录</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是有没有想过，<strong>MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？</strong></p><p>带着这个问题，我们可以很好的了解 MySQL 内部的架构，所以这次小林就带大家拆解一下 MySQL 内部的结构，看看内部里的每一个“零件”具体是负责做什么的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程">可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p><ul><li><p>Server 层负责建立连接、分析和执行 SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</p></li><li><p><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</p><p>  好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p></li></ul><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><span class="token comment"># -u 指定用户名，管理员角色名为 root；</span><span class="token comment"># -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span>mysql -h<span class="token variable">$ip</span> -u<span class="token variable">$user</span> -p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF.png" alt="img"></p><p>如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF.png" alt="img"></p><p>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。</p><p>所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><blockquote><p>如何查看 MySQL 服务被多少个客户端连接了？</p></blockquote><p>如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 <code>show processlist</code> 命令进行查看。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png" alt="img"></p><p>比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 <code>Sleep</code> ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。</p><blockquote><p>空闲连接会一直占用着吗？</p></blockquote><p>当然不是了，MySQL 定义了空闲连接的最大空闲时长，由 <code>wait_timeout</code> 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'wait_timeout'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token operator">|</span> wait_timeout  <span class="token operator">|</span> <span class="token number">28800</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">---------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">kill</span> connection <span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><blockquote><p>MySQL 的连接数有限制吗？</p></blockquote><p>MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'max_connections'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">-----------------+-------+</span><span class="token operator">|</span> Variable_name   <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------+-------+</span><span class="token operator">|</span> max_connections <span class="token operator">|</span> <span class="token number">151</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 短连接</span>连接 mysql 服务（TCP 三次握手）执行sql断开 mysql 服务（TCP 四次挥手）<span class="token comment">// 长连接</span>连接 mysql 服务（TCP 三次握手）执行sql执行sql执行sql<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>断开 mysql 服务（TCP 四次挥手）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><blockquote><p>怎么解决长连接占用内存的问题？</p></blockquote><p>有两种解决方式。</p><p>第一种，<strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p><p>第二种，<strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><p>至此，连接器的工作做完了，简单总结一下：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>这么看，查询缓存还挺有用，但是其实**<font color="green">查询缓存挺鸡肋</font>**的。</p><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p><p>所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。</p><blockquote><p>TIP</p><p>这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer poll。</p></blockquote><h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><p>在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由由「解析器」来完成。</p><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器会做如下两件事情。</p><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><p>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF.png" alt="img"></p><p>但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7和8.0）得出结论是解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。</p><p>那到底谁来做检测表和字段是否存在的工作呢？别急，接下来就是了。</p><h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来说说预处理阶段做了什么事情。</p><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul><p>我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test<span class="token punctuation">;</span>ERROR <span class="token number">1146</span> <span class="token punctuation">(</span><span class="token number">42</span>S02<span class="token punctuation">)</span>: <span class="token keyword">Table</span> <span class="token string">'mysql.test'</span> doesn't exist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里贴个 MySQL 8.0 源码来证明表或字段是否存在的判断，不是在解析器里做的，而是在 prepare 阶段。（<em>PS：下图是公众号「一树一溪」老哥帮我分析的，这位老哥专门写 MySQL 源码文章，感兴趣的朋友，可以微信搜索关注</em>）</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%A1%A8%E4%B8%8D%E5%AD%98%E5%9C%A8.jpeg" alt="img"></p><p>上面的中间部分是 MySQL 报错表不存在时的函数调用栈，可以看到表不存在的错误是在get_table_share() 函数里报错的，而这个函数是在 prepare 阶段调用的。</p><p>不过，对于 MySQL 5.7 判断表或字段是否存在的工作，是在词法分析&amp;语法分析之后，prepare 阶段之前做的。结论都一样，不是在解析器里做的。代码我就不放了，正因为 MySQL 5.7 代码结构不好，所以 MySQL 8.0 代码结构变化很大，后来判断表或字段是否存在的工作就被放入到 prepare 阶段做了。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用主键索引。</p><p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 <code>PRIMARY</code> 就是使用了主键索引。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p><p>如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png" alt="img"></p><p>这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E4%BA%A7%E5%93%81%E8%A1%A8.png" alt="img"></p><p>这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> product <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">1</span>  <span class="token operator">and</span> name <span class="token operator">like</span> <span class="token string">'i%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p><p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p><p><strong>很显然这条查询语句是</strong>覆盖索引<strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</strong></p><p>在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95.png" alt="img"></p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p><p>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。</p><ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul><h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><p>以本文开头查询语句为例，看看执行器是怎么工作的。</p><p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>至此，这个语句就执行完成了。</p><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>举个全表扫描的例子：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">select * from product where name = 'iphone';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li><p>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</p></li><li><p>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</p></li><li><p>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</p></li><li><p>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</p></li><li><p>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</p></li></ul><p>至此，这个语句就执行完成了。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。</p><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%B7%AF%E9%A3%9E%E8%A1%A8.png" alt="img"></p><p>现在有下面这条查询语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user  <span class="token keyword">where</span> age <span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">and</span> reward <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>联合索引当遇到范围查询 (&gt;、&lt;、between、like) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。具体原因这里可以看这篇：<a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">索引常见面试题</a></p><p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li><li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p><p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li><li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p><p>当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><p>怎么样？现在再看这张图，是不是很清晰了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><h1 id="索引常见面试题"><a href="#索引常见面试题" class="headerlink" title="索引常见面试题"></a>索引常见面试题</h1><p>面试中，MySQL 索引相关的问题基本都是一系列问题，都是先从索引的基本原理，再到索引的使用场景，比如：</p><ul><li>索引底层使用了什么数据结构和算法？</li><li>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</li><li>什么时候适用索引？</li><li>什么时候不需要创建索引？</li><li>什么情况下索引会失效？</li><li>有什么优化索引的方法？</li><li>…..</li></ul><p>今天就带大家，夯实 MySQL 索引的知识点。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>当你想查阅书中某个知识的内容，你会选择一页一页的找呢？还是在书的目录去找呢？</p><p>傻瓜都知道时间是宝贵的，当然是选择在书的目录去找，找到后再翻到对应的页。书中的<strong>目录</strong>，就是充当<strong>索引</strong>的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。</p><p>那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><p>所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎。</p><p>下图是 MySQL 的结构图，索引和数据就是位于存储引擎中：</p><p><img src="https://myblog-tuchuang.oss-cn-shanghai.aliyuncs.com/1623727651911_20170928110355446.png" alt="img"></p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>你知道索引有哪些吗？大家肯定都能霹雳啪啦地说出聚簇索引、主键索引、二级索引、普通索引、唯一索引、hash索引、B+树索引等等。</p><p>然后再问你，你能将这些索引分一下类吗？可能大家就有点模糊了。其实，要对这些索引进行分类，要清楚这些索引的使用和实现方式，然后再针对有相同特点的索引归为一类。</p><p>我们可以按照四个角度来分类索引。</p><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><p>接下来，按照这些角度来说说各类索引的特点。</p><h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p><p>每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+PicGo+Github设置图床</title>
      <link href="/2022/09/07/typora-picgo-github-she-zhi-tu-chuang/"/>
      <url>/2022/09/07/typora-picgo-github-she-zhi-tu-chuang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>之前 Typora 收费了，然后就没有再用了，现在发现了可以继续使用，但是已经用习惯了MarkText,但是还是下载了，现在给它也配置一下图床</strong></p><h1 id="GitHub-创建仓库"><a href="#GitHub-创建仓库" class="headerlink" title="GitHub 创建仓库"></a>GitHub 创建仓库</h1><h1 id="创建GitHub中的Token令牌"><a href="#创建GitHub中的Token令牌" class="headerlink" title="创建GitHub中的Token令牌"></a>创建GitHub中的Token令牌</h1><h1 id="下载PicGo"><a href="#下载PicGo" class="headerlink" title="下载PicGo"></a>下载PicGo</h1><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>点击左边图床设计，选择GitHub图床，具体配置如下</li><li>设定仓库名，填写：<strong>GitHub名/库名</strong></li><li>分支，<strong>默认填main(之前默认是master，后面改成了main)</strong></li><li>设定Token，<strong>刚才保存的token令牌</strong></li><li>指定存储路径，<strong>默认填img/</strong></li><li>点击确定和设为默认图床</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b6f85ee2cda796bb963699a628a8b839.png" alt="img"></p><ul><li>进入PicGo设置，打开时间戳重命名</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/fa66df92843955c2092905e7a341a9de.png" alt="img"></p><h1 id="Typora-配置"><a href="#Typora-配置" class="headerlink" title="Typora 配置"></a>Typora 配置</h1><ul><li>下载安装&nbsp;<strong><a href="https://link.zhihu.com/?target=https://typora.io/">Typora</a></strong></li><li>点击文件中偏好设置</li><li>进行图片中的设置</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5966a52c0a8fff2e50df1cf281837c5c.png" alt="img"></p><ul><li>所有的设置都已经完成就点击<em><strong>验证图片上传选项</strong></em></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/dc979c49b9b58ce273292fe331735a8b.png" alt="img"></p><ul><li>然后进入GitHub里看一下有图片就代表成功了</li></ul><h1 id="【Bug】PicGo上传失败原因及解决-Branch-master-not-found"><a href="#【Bug】PicGo上传失败原因及解决-Branch-master-not-found" class="headerlink" title="【Bug】PicGo上传失败原因及解决-Branch master not found"></a>【Bug】PicGo上传失败原因及解决-Branch master not found</h1><p>错误日志<br>[PicGo ERROR] StatusCodeError: 404 - {“message”:“Branch master not found”,“documentation_url”:“<a href="https://docs.github.com/rest/reference/repos#create-or-update-file-contents%E2%80%9D}">https://docs.github.com/rest/reference/repos#create-or-update-file-contents”}</a></p><p>github创建的仓库默认都是main分支了，不是master分支，所以设定分支名的地方改为main</p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解系统</title>
      <link href="/2022/09/07/tu-jie-xi-tong/"/>
      <url>/2022/09/07/tu-jie-xi-tong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图解系统介绍"><a href="#图解系统介绍" class="headerlink" title="图解系统介绍"></a>图解系统介绍</h1><p>图解系统不仅仅涉及了操作系统的内容，还涉及一些计算机组成和 Linux 命令的内容，</p><p>当然还是操作系统的内容占比较高，基本把操作系统<strong>进程管理、内存管理、文件系统、设备管理、网络系统</strong>这五大结构图解了，其中进程管理和网络系统这两个章节篇幅比较多，进程管理不仅包含了进程与线程的基本知识，还包含了进程间通信，多线程同步、死锁、悲观锁和乐观锁。网络系统包含 I/O 多路复用、零拷贝、Reactor 等等。</p><p>计算机组成主要涉及是 CPU 方面的知识，我们不关注 CPU 是怎么设计与实现的，<strong>只关注跟我们开发者有关系的 CPU 知识</strong>，比如 CPU 执行程序的原理，CPU 缓存，CPU 伪共享等等，这些看似跟我们开发者无关，实际上关系挺大的，只有了解 CPU 缓存才能写出更快的代码，只要了解 CPU 伪共享才能避免写出无效缓存的代码。</p><p>至于 Linux 命令的章节暂时内容没有很多，主要就写了如何用 Linux 命令「查看网络指标」和「从日志分析 PV、UV」，之所以没有写太多是觉得命令类的文章没办法体现出小林的图解功力，再加上这类命令一般网上资源也很多，工作中遇到需要使用某个命令时，去搜索了解并自己体验了一番后，才会比较深刻，单纯只看文章很容易就忘记这些命令了。</p><h1 id="2-1-CPU-是如何执行程序的？"><a href="#2-1-CPU-是如何执行程序的？" class="headerlink" title="2.1 CPU 是如何执行程序的？"></a>2.1 CPU 是如何执行程序的？</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%8F%90%E7%BA%B2.png"></p><h2 id="图灵机的工作方式"><a href="#图灵机的工作方式" class="headerlink" title="图灵机的工作方式"></a>图灵机的工作方式</h2><p>要想知道程序执行的原理，我们可以先从「图灵机」说起，图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。</p><p>图灵机长什么样子呢？你从下图可以看到图灵机的实际样子：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/Turing%2Bmachine%2B1.jpeg" alt="图来源自：http://www.kristergustafsson.me/turing-machine/"></p><p>图灵机的基本组成如下</p><ul><li>有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；</li><li>有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；</li><li>读写头上有一些部件，比如存储单元、控制单元以及运算单元： 1、存储单元用于存放数据； 2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等； 3、运算单元用于执行运算指令；</li></ul><p>知道了图灵机的组成后，我们以简单数学运算的&nbsp;<code>1 + 2</code>&nbsp;作为例子，来看看它是怎么执行这行代码的。</p><ul><li>首先，用读写头把 「1、2、+」这 3 个字符分别写入到纸带上的 3 个格子，然后读写头先停在 1 字符对应的格子上；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%9B%BE%E7%81%B5%E6%9C%BA-%E7%AC%AC%E4%B8%80%E6%AD%A5.png"></p><ul><li>接着，读写头读入 1 到存储设备中，这个存储设备称为图灵机的状态；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%9B%BE%E7%81%B5%E6%9C%BA-%E7%AC%AC%E4%BA%8C%E6%AD%A5.png"></p><ul><li>然后读写头向右移动一个格，用同样的方式把 2 读入到图灵机的状态，于是现在图灵机的状态中存储着两个连续的数字， 1 和 2；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%9B%BE%E7%81%B5%E6%9C%BA-%E7%AC%AC%E4%B8%89%E6%AD%A5.png"></p><ul><li>读写头再往右移动一个格，就会碰到 + 号，读写头读到 + 号后，将 + 号传输给「控制单元」，控制单元发现是一个 + 号而不是数字，所以没有存入到状态中，因为&nbsp;<code>+</code>&nbsp;号是运算符指令，作用是加和目前的状态，于是通知「运算单元」工作。运算单元收到要加和状态中的值的通知后，就会把状态中的 1 和 2 读入并计算，再将计算的结果 3 存放到状态中；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%9B%BE%E7%81%B5%E6%9C%BA-%E7%AC%AC%E5%9B%9B%E6%AD%A5.png"></p><ul><li>最后，运算单元将结果返回给控制单元，控制单元将结果传输给读写头，读写头向右移动，把结果 3 写入到纸带的格子中；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%9B%BE%E7%81%B5%E6%9C%BA-%E7%AC%AC%E4%BA%94%E6%AD%A5.png"></p><p>通过上面的图灵机计算&nbsp;<code>1 + 2</code>&nbsp;的过程，可以发现图灵机主要功能就是读取纸带格子中的内容，然后交给控制单元识别字符是数字还是运算符指令，如果是数字则存入到图灵机状态中，如果是运算符，则通知运算符单元读取状态中的数值进行计算，计算结果最终返回给读写头，读写头把结果写入到纸带的格子中。</p><p>事实上，图灵机这个看起来很简单的工作方式，和我们今天的计算机是基本一样的。接下来，我们一同再看看当今计算机的组成以及工作方式。</p><h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><p>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储。</p><p>最重要的是定义计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong>，这 5 个部分也被称为<strong>冯诺依曼模型</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Von_Neumann_architecture.svg"></p><p>运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。</p><p>存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png"></p><p>接下来，分别介绍内存、中央处理器、总线、输入输出设备。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p><p>在计算机数据存储中，存储数据的基本单位是<strong>字节（<em>byte</em>）</strong>，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p><p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><p>中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p><ul><li>32 位 CPU 一次可以计算 4 个字节；</li><li>64 位 CPU 一次可以计算 8 个字节；</li></ul><p>这里的 32 位和 64 位，通常称为 CPU 的位宽。</p><p>之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节&nbsp;<code>0~255</code>&nbsp;范围内的数值，这样就无法一次完成计算&nbsp;<code>10000 * 500</code>&nbsp;，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是&nbsp;<code>4294967295</code></p><p>CPU 内部还有一些组件，常见的有<strong>寄存器、控制单元和逻辑运算单元</strong>等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p><p>CPU 中的寄存器主要作用是存储计算时的数据，你可能好奇为什么有了内存还需要寄存器？原因很简单，因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。</p><p>常见的寄存器种类：</p><ul><li><em>通用寄存器</em>，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li><li><em>程序计数器</em>，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li><li><em>指令寄存器</em>，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li></ul><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：</p><ul><li><em>地址总线</em>，用于指定 CPU 将要操作的内存地址；</li><li><em>数据总线</em>，用于读写内存的数据；</li><li><em>控制总线</em>，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li></ul><p>当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：</p><ul><li>首先要通过「地址总线」来指定内存的地址；</li><li>然后通过「控制总线」控制是读或写命令；</li><li>最后通过「数据总线」来传输数据</li></ul><h3 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h3><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p><h2 id="线路位宽与-CPU-位宽"><a href="#线路位宽与-CPU-位宽" class="headerlink" title="线路位宽与 CPU 位宽"></a>线路位宽与 CPU 位宽</h2><p>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。</p><p>如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p><p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。</p><p>为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p><p>CPU 要想操作的内存地址就需要地址总线：</p><ul><li>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；</li><li>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</li></ul><p>那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为&nbsp;<code>2 ^ 32 = 4G</code>。</p><p>知道了线路位宽的意义后，我们再来看看 CPU 位宽。</p><p>CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。</p><p>如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p><p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p><p>但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以<strong>如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来</strong>。</p><p>另外，32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为&nbsp;<code>2^64</code>。</p><h2 id="程序执行的基本过程"><a href="#程序执行的基本过程" class="headerlink" title="程序执行的基本过程"></a>程序执行的基本过程</h2><p>在前面，我们知道了程序在图灵机的执行过程，接下来我们来看看程序在冯诺依曼模型上是怎么执行的。</p><p>程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/CPU%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F.png"></p><p>那 CPU 执行程序的过程如下：</p><ul><li>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。</li><li>第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；</li><li>第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；</li></ul><p>简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。</p><p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为&nbsp;<strong>CPU 的指令周期</strong>。</p><h2 id="a-1-2-执行具体过程"><a href="#a-1-2-执行具体过程" class="headerlink" title="a = 1 + 2 执行具体过程"></a>a = 1 + 2 执行具体过程</h2><p>知道了基本的程序执行过程后，接下来用&nbsp;<code>a = 1 + 2</code>&nbsp;的作为例子，进一步分析该程序在冯诺伊曼模型的执行过程。</p><p>CPU 是不认识&nbsp;<code>a = 1 + 2</code>&nbsp;这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成<strong>汇编语言</strong>的程序，这个过程称为编译成汇编代码。</p><p>针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的<strong>计算机指令</strong>，这个才是 CPU 能够真正认识的东西。</p><p>下面来看看&nbsp;<code>a = 1 + 2</code>&nbsp;在 32 位 CPU 的执行过程。</p><p>程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是「数据段」。如下图，数据 1 和 2 的区域位置：</p><ul><li>数据 1 被存放到 0x100 位置；</li><li>数据 2 被存放到 0x104 位置；</li></ul><p>注意，数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E6%95%B0%E6%8D%AE%E6%AE%B5%E4%B8%8E%E6%AD%A3%E6%96%87%E6%AE%B5.png"></p><p>编译器会把&nbsp;<code>a = 1 + 2</code>&nbsp;翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 0x200 ~ 0x20c 的区域中：</p><ul><li>0x200 的内容是&nbsp;<code>load</code>&nbsp;指令将 0x100 地址中的数据 1 装入到寄存器&nbsp;<code>R0</code>；</li><li>0x204 的内容是&nbsp;<code>load</code>&nbsp;指令将 0x104 地址中的数据 2 装入到寄存器&nbsp;<code>R1</code>；</li><li>0x208 的内容是&nbsp;<code>add</code>&nbsp;指令将寄存器&nbsp;<code>R0</code>&nbsp;和&nbsp;<code>R1</code>&nbsp;的数据相加，并把结果存放到寄存器&nbsp;<code>R2</code>；</li><li>0x20c 的内容是&nbsp;<code>store</code>&nbsp;指令将寄存器&nbsp;<code>R2</code>&nbsp;中的数据存回数据段中的 0x108 地址中，这个地址也就是变量&nbsp;<code>a</code>&nbsp;内存中的地址；</li></ul><p>编译完成后，具体执行程序的时候，程序计数器会被设置为 0x200 地址，然后依次执行这 4 条指令。</p><p>上面的例子中，由于是在 32 位 CPU 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节。</p><p>而数据的大小是根据你在程序中指定的变量类型，比如&nbsp;<code>int</code>&nbsp;类型的数据则占 4 个字节，<code>char</code>&nbsp;类型的数据则占 1 个字节。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>上面的例子中，图中指令的内容我写的是简易的汇编代码，目的是为了方便理解指令的具体内容，事实上指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU 通过解析机器码来知道指令的内容。</p><p>不同的 CPU 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码，接下来选用最简单的 MIPS 指集，来看看机器码是如何生成的，这样也能明白二进制的机器码的具体含义。</p><p>MIPS 的指令是一个 32 位的整数，高 6 位代表着操作码，表示这条指令是一条什么样的指令，剩下的 26 位不同指令类型所表示的内容也就不相同，主要有三种类型R、I 和 J。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/MIPS%E6%8C%87%E4%BB%A4%E9%9B%86.png"></p><p>一起具体看看这三种类型的含义：</p><ul><li><em>R 指令</em>，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的「位移量」，而最后的「功能码」则是再前面的操作码不够的时候，扩展操作码来表示对应的具体指令的；</li><li><em>I 指令</em>，用在数据传输、条件分支等。这个类型的指令，就没有了位移量和功能码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数；</li><li><em>J 指令</em>，用在跳转，高 6 位之外的 26 位都是一个跳转后的地址；</li></ul><p>接下来，我们把前面例子的这条指令：「<code>add</code>&nbsp;指令将寄存器&nbsp;<code>R0</code>&nbsp;和&nbsp;<code>R1</code>&nbsp;的数据相加，并把结果放入到&nbsp;<code>R2</code>」，翻译成机器码。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/add%E7%9A%84MIPS%E6%8C%87%E4%BB%A4.png"></p><p>加和运算 add 指令是属于 R 指令类型：</p><ul><li>add 对应的 MIPS 指令里操作码是&nbsp;<code>000000</code>，以及最末尾的功能码是&nbsp;<code>100000</code>，这些数值都是固定的，查一下 MIPS 指令集的手册就能知道的；</li><li>rs 代表第一个寄存器 R0 的编号，即&nbsp;<code>00000</code>；</li><li>rt 代表第二个寄存器 R1 的编号，即&nbsp;<code>00001</code>；</li><li>rd 代表目标的临时寄存器 R2 的编号，即&nbsp;<code>00010</code>；</li><li>因为不是位移操作，所以位移量是&nbsp;<code>00000</code></li></ul><p>把上面这些数字拼在一起就是一条 32 位的 MIPS 加法指令了，那么用 16 进制表示的机器码则是&nbsp;<code>0x00011020</code>。</p><p>编译器在编译程序的时候，会构造指令，这个过程叫做指令的编码。CPU 执行程序的时候，就会解析指令，这个过程叫作指令的解码。</p><p>现代大多数 CPU 都使用来流水线的方式来执行指令，所谓的流水线就是把一个任务拆分成多个小任务，于是一条指令通常分为 4 个阶段，称为 4 级流水线，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/CPU%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png"></p><p>四个阶段的具体含义：</p><ol><li>CPU 通过程序计数器读取对应内存地址的指令，这个部分称为&nbsp;<strong>Fetch（取得指令）</strong>；</li><li>CPU 对指令进行解码，这个部分称为&nbsp;<strong>Decode（指令译码）</strong>；</li><li>CPU 执行指令，这个部分称为&nbsp;<strong>Execution（执行指令）</strong>；</li><li>CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为&nbsp;<strong>Store（数据回写）</strong>；</li></ol><p>上面这 4 个阶段，我们称为<strong>指令周期（<em>Instrution Cycle</em>）</strong>，CPU 的工作就是一个周期接着一个周期，周而复始。</p><p>事实上，不同的阶段其实是由计算机中的不同组件完成的：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%BB%84%E4%BB%B6.png"></p><ul><li>取指令的阶段，我们的指令是存放在<strong>存储器</strong>里的，实际上，通过程序计数器和指令寄存器取出指令的过程，是由<strong>控制器</strong>操作的；</li><li>指令的译码过程，也是由<strong>控制器</strong>进行的；</li><li>指令执行的过程，无论是进行算术操作、逻辑操作，还是进行数据传输、条件分支操作，都是由<strong>算术逻辑单元</strong>操作的，也就是由<strong>运算器</strong>处理的。但是如果是一个简单的无条件地址跳转，则是直接在<strong>控制器</strong>里面完成的，不需要用到运算器。</li></ul><h3 id="指令的类型"><a href="#指令的类型" class="headerlink" title="指令的类型"></a>指令的类型</h3><p>指令从功能角度划分，可以分为 5 大类：</p><ul><li><em>数据传输类型的指令</em>，比如&nbsp;<code>store/load</code>&nbsp;是寄存器与内存间数据传输的指令，<code>mov</code>&nbsp;是将一个内存地址的数据移动到另一个内存地址的指令；</li><li><em>运算类型的指令</em>，比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据；</li><li><em>跳转类型的指令</em>，通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的&nbsp;<code>if-else</code>、<code>swtich-case</code>、函数调用等。</li><li><em>信号类型的指令</em>，比如发生中断的指令&nbsp;<code>trap</code>；</li><li><em>闲置类型的指令</em>，比如指令&nbsp;<code>nop</code>，执行后 CPU 会空转一个周期；</li></ul><h3 id="指令的执行速度"><a href="#指令的执行速度" class="headerlink" title="指令的执行速度"></a>指令的执行速度</h3><p>CPU 的硬件参数都会有&nbsp;<code>GHz</code>&nbsp;这个参数，比如一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期。</p><p>对于 CPU 来说，在一个时钟周期内，CPU 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。</p><p>一个时钟周期一定能执行完一条指令吗？答案是不一定的，大多数指令不能在一个时钟周期完成，通常需要若干个时钟周期。不同的指令需要的时钟周期是不同的，加法和乘法都对应着一条 CPU 指令，但是乘法需要的时钟周期就要比加法多。</p><blockquote><p>如何让程序跑的更快？</p></blockquote><p>程序执行的时候，耗费的 CPU 时间少就说明程序是快的，对于程序的 CPU 执行时间，我们可以拆解成&nbsp;<strong>CPU 时钟周期数（<em>CPU Cycles</em>）和时钟周期时间（<em>Clock Cycle Time</em>）的乘积</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E7%A8%8B%E5%BA%8F%E7%9A%84CPU%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%85%AC%E5%BC%8F1.png"></p><p>时钟周期时间就是我们前面提及的 CPU 主频，主频越高说明 CPU 的工作速度就越快，比如我手头上的电脑的 CPU 是 2.4 GHz 四核 Intel Core i5，这里的 2.4 GHz 就是电脑的主频，时钟周期时间就是 1/2.4G。</p><p>要想 CPU 跑的更快，自然缩短时钟周期时间，也就是提升 CPU 主频，但是今非彼日，摩尔定律早已失效，当今的 CPU 主频已经很难再做到翻倍的效果了。</p><p>另外，换一个更好的 CPU，这个也是我们软件工程师控制不了的事情，我们应该把目光放到另外一个乘法因子 —— CPU 时钟周期数，如果能减少程序所需的 CPU 时钟周期数量，一样也是能提升程序的性能的。</p><p>对于 CPU 时钟周期数我们可以进一步拆解成：「<strong>指令数 x 每条指令的平均时钟周期数（<em>Cycles Per Instruction</em>，简称&nbsp;<code>CPI</code>）</strong>」，于是程序的 CPU 执行时间的公式可变成如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/%E7%A8%8B%E5%BA%8F%E7%9A%84CPU%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E5%85%AC%E5%BC%8F2.png"></p><p>因此，要想程序跑的更快，优化这三者即可：</p><ul><li>*<front color="Blue">指令数</front>*，表示执行程序所需要多少条指令，以及哪些指令。这个层面是基本靠编译器来优化，毕竟同样的代码，在不同的编译器，编译出来的计算机指令会有各种不同的表示方式。</li><li><em>每条指令的平均时钟周期数 CPI</em>，表示一条指令需要多少个时钟周期数，现代大多数 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU 时钟周期数尽可能的少；</li><li><em>时钟周期时间</em>，表示计算机主频，取决于计算机硬件。有的 CPU 支持超频技术，打开了超频意味着把 CPU 内部的时钟给调快了，于是 CPU 工作速度就变快了，但是也是有代价的，CPU 跑的越快，散热的压力就会越大，CPU 会很容易奔溃。</li></ul><p>很多厂商为了跑分而跑分，基本都是在这三个方面入手的哦，特别是超频这一块。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们再来回答开头的问题。</p><blockquote><p>64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？</p></blockquote><p>64 位相比 32 位 CPU 的优势主要体现在两个方面：</p><ul><li>64 位 CPU 可以一次计算超过 32 位的数字，而 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以<strong>只有运算大数字的时候，64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不大</strong>。</li><li>64 位 CPU 可以<strong>寻址更大的内存空间</strong>，32 位 CPU 最大的寻址地址是 4G，即使你加了 8G 大小的内存，也还是只能寻址到 4G，而 64 位 CPU 最大寻址地址是&nbsp;<code>2^64</code>，远超于 32 位 CPU 最大寻址地址的&nbsp;<code>2^32</code>。</li></ul><blockquote><p>你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？</p></blockquote><p>4 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：</p><ul><li>如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是<strong>如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令</strong>；</li><li>操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。</li></ul><p>总之，硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。</p><h1 id="2-2-磁盘比内存慢几万倍？"><a href="#2-2-磁盘比内存慢几万倍？" class="headerlink" title="2.2 磁盘比内存慢几万倍？"></a>2.2 磁盘比内存慢几万倍？</h1><p>大家如果想自己组装电脑的话，肯定需要购买一个 CPU，但是存储器方面的设备，分类比较多，那我们肯定不能只买一种存储器，比如你除了要买内存，还要买硬盘，而针对硬盘我们还可以选择是固态硬盘还是机械硬盘。</p><p>相信大家都知道内存和硬盘都属于计算机的存储设备，断电后内存的数据是会丢失的，而硬盘则不会，因为硬盘是持久化存储设备，同时也是一个 I/O 设备。</p><p>但其实 CPU 内部也有存储数据的组件，这个应该比较少人注意到，比如<strong>寄存器、CPU L1/L2/L3 Cache</strong>&nbsp;也都是属于存储设备，只不过它们能存储的数据非常小，但是它们因为靠近 CPU 核心，所以访问速度都非常快，快过硬盘好几个数量级别。</p><p>问题来了，<strong>那机械硬盘、固态硬盘、内存这三个存储器，到底和 CPU L1 Cache 相比速度差多少倍呢？</strong></p><p>在回答这个问题之前，我们先来看看「<strong>存储器的层次结构</strong>」，好让我们对存储器设备有一个整体的认识。</p><p><img src="https://raw.githubusercontent.com/xiaolincoder/ImageHost3/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E6%8F%90%E7%BA%B2.png"></p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p>我们想象中一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。</p><p>就是这么一个小小的场景，已经把计算机的存储结构基本都涵盖了。</p><p>我们可以把 CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的<strong>寄存器</strong>，处理速度是最快的，但是能存储的数据也是最少的，毕竟我们也不能一下同时思考太多的事情，除非你练过。</p><p>我们大脑中的记忆，就好比&nbsp;<strong>CPU Cache</strong>，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p><p>CPU Cache 通常会分为&nbsp;<strong>L1、L2、L3 三层</strong>，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2/L3 Cache。</p><p>寄存器和 CPU Cache 都是在 CPU 内部，跟 CPU 挨着很近，因此它们的读写速度都相当的快，但是能存储的数据很少，毕竟 CPU 就这么丁点大。</p><p>知道 CPU 内部的存储器的层次分布，我们放眼看看 CPU 外部的存储器。</p><p>当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比<strong>内存</strong>，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比<strong>硬盘</strong>，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.png"></p><p>我们从图书馆书架取书，把书放到桌子上，再阅读书，我们大脑就会记忆知识点，然后再经过大脑思考，这一系列过程相当于，数据从硬盘加载到内存，再从内存加载到 CPU 的寄存器和 Cache 中，然后再通过 CPU 进行处理和计算。</p><p><strong>对于存储器，它的速度越快、能耗会越高、而且材料的成本也是越贵的，以至于速度快的存储器的容量都比较小。</strong></p><p>CPU 里的寄存器和 Cache，是整个计算机存储器中价格最贵的，虽然存储空间很小，但是读写速度是极快的，而相对比较便宜的内存和硬盘，速度肯定比不上 CPU 内部的存储器，但是能弥补存储空间的不足。</p><p>存储器通常可以分为这么几个级别：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%88%86%E7%BA%A7.png"></p><ul><li>寄存器；</li><li>CPU Cache；<ol><li>L1-Cache；</li><li>L2-Cache；</li><li>L3-Cahce；</li></ol></li><li>内存；</li><li>SSD/HDD 硬盘</li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>最靠近 CPU 的控制单元和逻辑计算单元的存储器，就是寄存器了，它使用的材料速度也是最快的，因此价格也是最贵的，那么数量不能很多。</p><p>存储器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据。比如：</p><ul><li>32 位 CPU 中大多数寄存器可以存储&nbsp;<code>4</code>&nbsp;个字节；</li><li>64 位 CPU 中大多数寄存器可以存储&nbsp;<code>8</code>&nbsp;个字节。</li></ul><p>寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1/2G，也就是 0.5ns（纳秒）。</p><p>CPU 处理一条指令的时候，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。</p><h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>CPU Cache 用的是一种叫&nbsp;<strong>SRAM（<em>Static Random-Access</em>&nbsp;Memory，静态随机存储器）</strong>&nbsp;的芯片。</p><p>SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。</p><p>在 SRAM 里面，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。</p><p>CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/CPU-Cache.png"></p><h4 id="L1-高速缓存"><a href="#L1-高速缓存" class="headerlink" title="L1 高速缓存"></a>L1 高速缓存</h4><p>L1 高速缓存的访问速度几乎和寄存器一样快，通常只需要&nbsp;<code>2~4</code>&nbsp;个时钟周期，而大小在几十 KB 到几百 KB 不等。</p><p>每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。</p><p>在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L1 Cache 「数据」缓存的容量大小：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/size32K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cache/index1/size32K <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="L2-高速缓存"><a href="#L2-高速缓存" class="headerlink" title="L2 高速缓存"></a>L2 高速缓存</h4><p>L2 高速缓存同样每个 CPU 核心都有，但是 L2 高速缓存位置比 L1 高速缓存距离 CPU 核心 更远，它大小比 L1 高速缓存更大，CPU 型号不同大小也就不同，通常大小在几百 KB 到几 MB 不等，访问速度则更慢，速度在&nbsp;<code>10~20</code>&nbsp;个时钟周期。</p><p>在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L2 Cache 的容量大小：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cache/index2/size256K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="L3-高速缓存"><a href="#L3-高速缓存" class="headerlink" title="L3 高速缓存"></a>L3 高速缓存</h4><p>L3 高速缓存通常是多个 CPU 核心共用的，位置比 L2 高速缓存距离 CPU 核心 更远，大小也会更大些，通常大小在几 MB 到几十 MB 不等，具体值根据 CPU 型号而定。</p><p>访问速度相对也比较慢一些，访问速度在&nbsp;<code>20~60</code>个时钟周期。</p><p>在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L3 Cache 的容量大小：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">cat</span> /sys/devices/system/cpu/cpu0/cache/index3/size 3072K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h3><p>内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作&nbsp;<strong>DRAM （<em>Dynamic Random Access Memory</em>，动态随机存取存储器）</strong>&nbsp;的芯片。</p><p>相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。</p><p>DRAM 存储一个 bit 数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p><p>DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在&nbsp;<code>200~300</code>&nbsp;个 时钟周期之间。</p><h3 id="SSD-HDD-硬盘"><a href="#SSD-HDD-硬盘" class="headerlink" title="SSD/HDD 硬盘"></a>SSD/HDD 硬盘</h3><p>SSD（<em>Solid-state disk</em>） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快&nbsp;<code>10~1000</code>&nbsp;倍。</p><p>当然，还有一款传统的硬盘，也就是机械硬盘（<em>Hard Disk Drive, HDD</em>），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢&nbsp;<code>10W</code>&nbsp;倍左右。</p><p>由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。</p><h2 id="存储器的层次关系"><a href="#存储器的层次关系" class="headerlink" title="存储器的层次关系"></a>存储器的层次关系</h2><p>现代的一台计算机，都用上了 CPU Cahce、内存、到 SSD 或 HDD 硬盘这些存储器设备了。</p><p>其中，存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。</p><p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p><p>比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><p>所以，<strong>每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构</strong>。</p><p>另外，当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E7%BC%93%E5%AD%98%E4%BD%93%E7%B3%BB1.png"></p><p>所以，存储层次结构也形成了<strong>缓存</strong>的体系。</p><h2 id="存储器之间的实际价格和性能差距"><a href="#存储器之间的实际价格和性能差距" class="headerlink" title="存储器之间的实际价格和性能差距"></a>存储器之间的实际价格和性能差距</h2><p>前面我们知道了，速度越快的存储器，造价成本往往也越高，那我们就以实际的数据来看看，不同层级的存储器之间的性能和价格差异。</p><p>下面这张表格是不同层级的存储器之间的成本对比图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%99%A8%E6%88%90%E6%9C%AC%E7%9A%84%E5%AF%B9%E6%AF%94.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>各种存储器之间的关系，可以用我们在图书馆学习这个场景来理解。</p><p>CPU 可以比喻成我们的大脑，我们当前正在思考和处理的知识的过程，就好比 CPU 中的<strong>寄存器</strong>处理数据的过程，速度极快，但是容量很小。而 CPU 中的&nbsp;<strong>L1-L3 Cache</strong>&nbsp;好比我们大脑中的短期记忆和长期记忆，需要小小花费点时间来调取数据并处理。</p><p>我们面前的桌子就相当于<strong>内存</strong>，能放下更多的书（数据），但是找起来和看起来就要花费一些时间，相比 CPU Cache 慢不少。而图书馆的书架相当于<strong>硬盘</strong>，能放下比内存更多的数据，但找起来就更费时间了，可以说是最慢的存储器设备了。</p><p>从 寄存器、CPU Cache，到内存、硬盘，这样一层层下来的存储器，访问速度越来越慢，存储容量越来越大，价格也越来越便宜，而且每个存储器只和相邻的一层存储器设备打交道，于是这样就形成了存储器的层次结构。</p><p>再来回答，开头的问题：那机械硬盘、固态硬盘、内存这三个存储器，到底和&nbsp;<code>CPU L1 Cache</code>&nbsp;相比速度差多少倍呢？</p><p>CPU L1 Cache 随机访问延时是 1 纳秒，内存则是 100 纳秒，所以&nbsp;<strong>CPU L1 Cache 比内存快&nbsp;<code>100</code>&nbsp;倍左右</strong>。</p><p>SSD 随机访问延时是 150 微秒，所以&nbsp;<strong>CPU L1 Cache 比 SSD 快&nbsp;<code>150000</code>&nbsp;倍左右</strong>。</p><p>最慢的机械硬盘随机访问延时已经高达 10 毫秒，我们来看看机械硬盘到底有多「龟速」：</p><ul><li><strong>SSD 比机械硬盘快 70 倍左右；</strong></li><li><strong>内存比机械硬盘快 100000 倍左右；</strong></li><li><strong>CPU L1 Cache 比机械硬盘快 10000000 倍左右；</strong></li></ul><p>我们把上述的时间比例差异放大后，就能非常直观感受到它们的性能差异了。如果 CPU 访问 L1 Cache 的缓存时间是 1 秒，那访问内存则需要大约 2 分钟，随机访问 SSD 里的数据则需要 1.7 天，访问机械硬盘那更久，长达近 4 个月。</p><p>可以发现，不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造<strong>缓存</strong>体系。</p><h1 id="2-3-如何写出让-CPU-跑得更快的代码？"><a href="#2-3-如何写出让-CPU-跑得更快的代码？" class="headerlink" title="2.3 如何写出让 CPU 跑得更快的代码？"></a>2.3 如何写出让 CPU 跑得更快的代码？</h1><p>代码都是由 CPU 跑起来的，我们代码写的好与坏就决定了 CPU 的执行效率，特别是在编写计算密集型的程序，更要注重 CPU 的执行效率，否则将会大大影响系统性能。</p><p>CPU 内部嵌入了 CPU Cache（高速缓存），它的存储容量很小，但是离 CPU 核心很近，所以缓存的读写速度是极快的，那么如果 CPU 运算时，直接从 CPU Cache 读取数据，而不是从内存的话，运算速度就会很快。</p><p>但是，大多数人不知道 CPU Cache 的运行机制，以至于不知道如何才能够写出能够配合 CPU Cache 工作机制的代码，一旦你掌握了它，你写代码的时候，就有新的优化思路了。</p><p>那么，接下来我们就来看看，CPU Cache 到底是什么样的，是如何工作的呢，又该如何写出让 CPU 执行更快的代码呢？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/CPUCache%E6%8F%90%E7%BA%B2.png"></p><h2 id="CPU-Cache-有多快？"><a href="#CPU-Cache-有多快？" class="headerlink" title="CPU Cache 有多快？"></a>CPU Cache 有多快？</h2><p>你可能会好奇为什么有了内存，还需要 CPU Cache？根据摩尔定律，CPU 的访问速度每 18 个月就会翻倍，相当于每年增长 60% 左右，内存的速度当然也会不断增长，但是增长的速度远小于 CPU，平均每年只增长 7% 左右。于是，CPU 与内存的访问性能的差距不断拉大。</p><p>到现在，一次内存访问所需时间是&nbsp;<code>200~300</code>&nbsp;多个时钟周期，这意味着 CPU 和内存的访问速度已经相差&nbsp;<code>200~300</code>&nbsp;多倍了。</p><p>为了弥补 CPU 与内存两者之间的性能差异，就在 CPU 内部引入了 CPU Cache，也称高速缓存。</p><p>CPU Cache 通常分为大小不等的三级缓存，分别是&nbsp;<strong>L1 Cache、L2 Cache 和 L3 Cache</strong>。</p><p>由于 CPU Cache 所使用的材料是 SRAM，价格比内存使用的 DRAM 高出很多，在当今每生产 1 MB 大小的 CPU Cache 需要 7 美金的成本，而内存只需要 0.015 美金的成本，成本方面相差了 466 倍，所以 CPU Cache 不像内存那样动辄以 GB 计算，它的大小是以 KB 或 MB 来计算的。</p><p>在 Linux 系统中，我们可以使用下图的方式来查看各级 CPU Cache 的大小，比如我这手上这台服务器，离 CPU 核心最近的 L1 Cache 是 32KB，其次是 L2 Cache 是 256KB，最大的 L3 Cache 则是 3MB。</p><p>其中，<strong>L1 Cache 通常会分为「数据缓存」和「指令缓存」</strong>，这意味着数据和指令在 L1 Cache 这一层是分开缓存的，上图中的&nbsp;<code>index0</code>&nbsp;也就是数据缓存，而&nbsp;<code>index1</code>&nbsp;则是指令缓存，它两的大小通常是一样的。</p><p>另外，你也会注意到，L3 Cache 比 L1 Cache 和 L2 Cache 大很多，这是因为&nbsp;<strong>L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。</strong></p><p>程序执行时，会先将内存中的数据加载到共享的 L3 Cache 中，再加载到每个核心独有的 L2 Cache，最后进入到最快的 L1 Cache，之后才会被 CPU 读取。它们之间的层级关系，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/CPU-Cache.png"></p><p>越靠近 CPU 核心的缓存其访问速度越快，CPU 访问 L1 Cache 只需要&nbsp;<code>2~4</code>&nbsp;个时钟周期，访问 L2 Cache 大约&nbsp;<code>10~20</code>&nbsp;个时钟周期，访问 L3 Cache 大约&nbsp;<code>20~60</code>&nbsp;个时钟周期，而访问内存速度大概在&nbsp;<code>200~300</code>&nbsp;个 时钟周期之间。如下表格：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E8%A1%A8%E6%A0%BC.png"></p><p><strong>所以，CPU 从 L1 Cache 读取数据的速度，相比从内存读取的速度，会快&nbsp;<code>100</code>&nbsp;多倍</strong></p><h2 id="CPU-Cache-的数据结构和读取过程是什么样的？"><a href="#CPU-Cache-的数据结构和读取过程是什么样的？" class="headerlink" title="CPU Cache 的数据结构和读取过程是什么样的？"></a>CPU Cache 的数据结构和读取过程是什么样的？</h2><p>我们先简单了解下 CPU Cache 的结构，CPU Cache 是由很多个 Cache Line 组成的，Cache Line 是 CPU 从内存读取数据的基本单位，而 Cache Line 是由各种标志（Tag）+ 数据块（Data Block）组成，你可以在下图清晰的看到：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/Cache%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为&nbsp;<strong>Cache Line（缓存块）</strong>。</p><p>你可以在你的 Linux 系统，用下面这种方式来查看 CPU 的 Cache Line，你可以看我服务器的 L1 Cache Line 大小是 64 字节，也就意味着&nbsp;<strong>L1 Cache 一次载入数据的大小是 64 字节</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E6%9F%A5%E7%9C%8BCPULine%E5%A4%A7%E5%B0%8F.png"></p><p>比如，有一个&nbsp;<code>int array[100]</code>&nbsp;的数组，当载入&nbsp;<code>array[0]</code>&nbsp;时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会<strong>顺序加载</strong>数组元素到&nbsp;<code>array[15]</code>，意味着&nbsp;<code>array[0]~array[15]</code>&nbsp;数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。</p><p>事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%80%BB%E8%BE%91.png"></p><p>这样的访问机制，跟我们使用「内存作为硬盘的缓存」的逻辑是一样的，如果内存有缓存的数据，则直接返回，否则要访问龟速一般的硬盘。</p><p>那 CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？我们从最简单、基础的<strong>直接映射 Cache（<em>Direct Mapped Cache</em>）</strong>&nbsp;说起，来看看整个 CPU Cache 的数据结构和访问逻辑。</p><p>前面，我们提到 CPU 访问内存数据时，是一小块一小块数据读取的，具体这一小块数据的大小，取决于&nbsp;<code>coherency_line_size</code>&nbsp;的值，一般 64 字节。在内存中，这一块的数据我们称为<strong>内存块（<em>Block</em>）</strong>，读取的时候我们要拿到数据所在内存块的地址。</p><p>对于直接映射 Cache 采用的策略，就是把内存块的地址始终「映射」在一个 CPU Cache Line（缓存块） 的地址，至于映射关系实现方式，则是使用「取模运算」，取模运算的结果就是内存块地址对应的 CPU Cache Line（缓存块） 的地址。</p><p>举个例子，内存共被划分为 32 个内存块，CPU Cache 共有 8 个 CPU Cache Line，假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Cache Line 中的话，则是一定映射在 7 号 CPU Cache Line 中，因为&nbsp;<code>15 % 8</code>&nbsp;的值是 7。</p><p>机智的你肯定发现了，使用取模方式映射的话，就会出现多个内存块对应同一个 CPU Cache Line，比如上面的例子，除了 15 号内存块是映射在 7 号 CPU Cache Line 中，还有 7 号、23 号、31 号内存块都是映射到 7 号 CPU Cache Line 中。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E6%B1%82%E6%A8%A1%E6%98%A0%E5%B0%84%E7%AD%96%E7%95%A5.png"></p><p>因此，为了区别不同的内存块，在对应的 CPU Cache Line 中我们还会存储一个<strong>组标记（Tag）</strong>。这个组标记会记录当前 CPU Cache Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。</p><p>除了组标记信息外，CPU Cache Line 还有两个信息：</p><ul><li>一个是，从内存加载过来的实际存放<strong>数据（<em>Data</em>）</strong>。</li><li>另一个是，<strong>有效位（<em>Valid bit</em>）</strong>，它是用来标记对应的 CPU Cache Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Cache Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。</li></ul><p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Cache Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<strong>字（<em>Word</em>）</strong>。那怎么在对应的 CPU Cache Line 中数据块中找到所需的字呢？答案是，需要一个<strong>偏移量（Offset）</strong>。</p><p>因此，一个内存的访问地址，包括<strong>组标记、CPU Cache Line 索引、偏移量</strong>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E7%9B%B4%E6%8E%A5Cache%E6%98%A0%E5%B0%84.png"></p><p>如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：</p><ol><li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li><li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li><li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li><li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li></ol><p>到这里，相信你对直接映射 Cache 有了一定认识，但其实除了直接映射 Cache 之外，还有其他通过内存地址找到 CPU Cache 中的数据的策略，比如全相连 Cache （<em>Fully Associative Cache</em>）、组相连 Cache （<em>Set Associative Cache</em>）等，这几种策策略的数据结构都比较相似，我们理解了直接映射 Cache 的工作方式，其他的策略如果你有兴趣去看，相信很快就能理解的了。</p><h2 id="如何写出让-CPU-跑得更快的代码？"><a href="#如何写出让-CPU-跑得更快的代码？" class="headerlink" title="如何写出让 CPU 跑得更快的代码？"></a>如何写出让 CPU 跑得更快的代码？</h2><p>我们知道 CPU 访问内存的速度，比访问 CPU Cache 的速度慢了 100 多倍，所以如果 CPU 所要操作的数据在 CPU Cache 中的话，这样将会带来很大的性能提升。访问的数据在 CPU Cache 中的话，意味着<strong>缓存命中</strong>，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。</p><p>于是，「如何写出让 CPU 跑得更快的代码？」这个问题，可以改成「如何写出 CPU 缓存命中率高的代码？」。</p><p>在前面我也提到， L1 Cache 通常分为「数据缓存」和「指令缓存」，这是因为 CPU 会分别处理数据和指令，比如&nbsp;<code>1+1=2</code>&nbsp;这个运算，<code>+</code>&nbsp;就是指令，会被放在「指令缓存」中，而输入数字&nbsp;<code>1</code>&nbsp;则会被放在「数据缓存」里。</p><p>因此，<strong>我们要分开来看「数据缓存」和「指令缓存」的缓存命中率</strong>。</p><h3 id="如何提升数据缓存的命中率？"><a href="#如何提升数据缓存的命中率？" class="headerlink" title="如何提升数据缓存的命中率？"></a>如何提升数据缓存的命中率？</h3><p>假设要遍历二维数组，有以下两种形式，虽然代码执行结果是一样，但你觉得哪种形式效率最高呢？为什么高呢？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84.png"></p><p>经过测试，形式一&nbsp;<code>array[i][j]</code>&nbsp;执行时间比形式二&nbsp;<code>array[j][i]</code>&nbsp;快好几倍。</p><p>之所以有这么大的差距，是因为二维数组&nbsp;<code>array</code>&nbsp;所占用的内存是连续的，比如长度&nbsp;<code>N</code>&nbsp;的值是&nbsp;<code>2</code>&nbsp;的话，那么内存中的数组元素的布局顺序是这样的：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E9%A1%BA%E5%BA%8F.png"></p><p>形式一用&nbsp;<code>array[i][j]</code>&nbsp;访问数组元素的顺序，正是和内存中数组元素存放的顺序一致。当 CPU 访问&nbsp;<code>array[0][0]</code>&nbsp;时，由于该数据不在 Cache 中，于是会「顺序」把跟随其后的 3 个元素从内存中加载到 CPU Cache，这样当 CPU 访问后面的 3 个数组元素时，就能在 CPU Cache 中成功地找到数据，这意味着缓存命中率很高，缓存命中的数据不需要访问内存，这便大大提高了代码的性能。</p><p>而如果用形式二的&nbsp;<code>array[j][i]</code>&nbsp;来访问，则访问的顺序就是：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E5%BD%A2%E5%BC%8F%E4%BA%8C%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F.png"></p><p>你可以看到，访问的方式跳跃式的，而不是顺序的，那么如果 N 的数值很大，那么操作&nbsp;<code>array[j][i]</code>&nbsp;时，是没办法把&nbsp;<code>array[j+1][i]</code>&nbsp;也读入到 CPU Cache 中的，既然&nbsp;<code>array[j+1][i]</code>&nbsp;没有读取到 CPU Cache，那么就需要从内存读取该数据元素了。很明显，这种不连续性、跳跃式访问数据元素的方式，可能不能充分利用到了 CPU Cache 的特性，从而代码的性能不高。</p><p>那访问&nbsp;<code>array[0][0]</code>&nbsp;元素时，CPU 具体会一次从内存中加载多少元素到 CPU Cache 呢？这个问题，在前面我们也提到过，这跟 CPU Cache Line 有关，它表示&nbsp;<strong>CPU Cache 一次性能加载数据的大小</strong>，可以在 Linux 里通过&nbsp;<code>coherency_line_size</code>&nbsp;配置查看 它的大小，通常是 64 个字节。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E6%9F%A5%E7%9C%8BCPULine%E5%A4%A7%E5%B0%8F.png"></p><p>也就是说，当 CPU 访问内存数据时，如果数据不在 CPU Cache 中，则会一次性会连续加载 64 字节大小的数据到 CPU Cache，那么当访问&nbsp;<code>array[0][0]</code>&nbsp;时，由于该元素不足 64 字节，于是就会往后<strong>顺序</strong>读取&nbsp;<code>array[0][0]~array[0][15]</code>&nbsp;到 CPU Cache 中。顺序访问的&nbsp;<code>array[i][j]</code>&nbsp;因为利用了这一特点，所以就会比跳跃式访问的&nbsp;<code>array[j][i]</code>&nbsp;要快。</p><p><strong>因此，遇到这种遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升，</strong></p><h3 id="如何提升指令缓存的命中率？"><a href="#如何提升指令缓存的命中率？" class="headerlink" title="如何提升指令缓存的命中率？"></a>如何提升指令缓存的命中率？</h3><p>提升数据的缓存命中率的方式，是按照内存布局顺序访问，那针对指令的缓存该如何提升呢？</p><p>我们以一个例子来看看，有一个元素为 0 到 100 之间随机数字组成的一维数组：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%95%B0%E7%BB%84.png"></p><p>接下来，对这个数组做两个操作：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/%E6%8E%92%E5%BA%8Fand%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86.png"></p><ul><li>第一个操作，循环遍历数组，把小于 50 的数组元素置为 0；</li><li>第二个操作，将数组排序；</li></ul><p>那么问题来了，你觉得先遍历再排序速度快，还是先排序再遍历速度快呢？</p><p>在回答这个问题之前，我们先了解 CPU 的<strong>分支预测器</strong>。对于 if 条件语句，意味着此时至少可以选择跳转到两段不同的指令执行，也就是 if 还是 else 中的指令。那么，<strong>如果分支预测可以预测到接下来要执行 if 里的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快</strong>。</p><p>当数组中的元素是随机的，分支预测就无法有效工作，而当数组元素都是是顺序的，分支预测器会动态地根据历史命中数据对未来进行预测，这样命中率就会很高。</p><p>因此，先排序再遍历速度会更快，这是因为排序之后，数字是从小到大的，那么前几次循环命中&nbsp;<code>if &lt; 50</code>&nbsp;的次数会比较多，于是分支预测就会缓存&nbsp;<code>if</code>&nbsp;里的&nbsp;<code>array[i] = 0</code>&nbsp;指令到 Cache 中，后续 CPU 执行该指令就只需要从 Cache 读取就好了。</p><p>如果你肯定代码中的&nbsp;<code>if</code>&nbsp;中的表达式判断为&nbsp;<code>true</code>&nbsp;的概率比较高，我们可以使用显示分支预测工具，比如在 C/C++ 语言中编译器提供了&nbsp;<code>likely</code>&nbsp;和&nbsp;<code>unlikely</code>&nbsp;这两种宏，如果&nbsp;<code>if</code>&nbsp;条件为&nbsp;<code>ture</code>&nbsp;的概率大，则可以用&nbsp;<code>likely</code>&nbsp;宏把&nbsp;<code>if</code>&nbsp;里的表达式包裹起来，反之用&nbsp;<code>unlikely</code>&nbsp;宏。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/likely.png"></p><p>实际上，CPU 自身的动态分支预测已经是比较准的了，所以只有当非常确信 CPU 预测的不准，且能够知道实际的概率情况时，才建议使用这两种宏。</p><h3 id="如何提升多核-CPU-的缓存命中率？"><a href="#如何提升多核-CPU-的缓存命中率？" class="headerlink" title="如何提升多核 CPU 的缓存命中率？"></a>如何提升多核 CPU 的缓存命中率？</h3><p>在单核 CPU，虽然只能执行一个线程，但是操作系统给每个线程分配了一个时间片，时间片用完了，就调度下一个线程，于是各个线程就按时间片交替地占用 CPU，从宏观上看起来各个线程同时在执行。</p><p>而现代 CPU 都是多核心的，线程可能在不同 CPU 核心来回切换执行，这对 CPU Cache 不是有利的，虽然 L3 Cache 是多核心之间共享的，但是 L1 和 L2 Cache 都是每个核心独有的，<strong>如果一个线程在不同核心来回切换，各个核心的缓存命中率就会受到影响</strong>，相反如果线程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，缓存命中率高就意味着 CPU 可以减少访问 内存的频率。</p><p>当有多个同时执行「计算密集型」的线程，为了防止因为切换到不同的核心，而导致缓存命中率下降的问题，我们可以把<strong>线程绑定在某一个 CPU 核心上</strong>，这样性能可以得到非常可观的提升。</p><p>在 Linux 上提供了&nbsp;<code>sched_setaffinity</code>&nbsp;方法，来实现将线程绑定到某个 CPU 核心这一功能。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98/sched_setaffinity.png"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>由于随着计算机技术的发展，CPU 与 内存的访问速度相差越来越多，如今差距已经高达好几百倍了，所以 CPU 内部嵌入了 CPU Cache 组件，作为内存与 CPU 之间的缓存层，CPU Cache 由于离 CPU 核心很近，所以访问速度也是非常快的，但由于所需材料成本比较高，它不像内存动辄几个 GB 大小，而是仅有几十 KB 到 MB 大小。</p><p>当 CPU 访问数据的时候，先是访问 CPU Cache，如果缓存命中的话，则直接返回数据，就不用每次都从内存读取速度了。因此，缓存命中率越高，代码的性能越好。</p><p>但需要注意的是，当 CPU 访问数据时，如果 CPU Cache 没有缓存该数据，则会从内存读取数据，但是并不是只读一个数据，而是一次性读取一块一块的数据存放到 CPU Cache 中，之后才会被 CPU 读取。</p><p>内存地址映射到 CPU Cache 地址里的策略有很多种，其中比较简单是直接映射 Cache，它巧妙的把内存地址拆分成「索引 + 组标记 + 偏移量」的方式，使得我们可以将很大的内存地址，映射到很小的 CPU Cache 地址里。</p><p>要想写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：</p><ul><li>对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；</li><li>对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；</li></ul><p>另外，对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。</p><h1 id="2-4-CPU-缓存一致性"><a href="#2-4-CPU-缓存一致性" class="headerlink" title="2.4 CPU 缓存一致性"></a>2.4 CPU 缓存一致性</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%8F%90%E7%BA%B2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决python安装包问题</title>
      <link href="/2022/09/07/jie-jue-python-an-zhuang-bao-wen-ti/"/>
      <url>/2022/09/07/jie-jue-python-an-zhuang-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>之前使用 Python 的时候还可以正常使用 pip 安装 软件包，现在好像是官网让墙了，所以需要设置国内的镜像才能访问成功。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="1-单次修改源"><a href="#1-单次修改源" class="headerlink" title="1. 单次修改源"></a>1. 单次修改源</h2><p>以Torch为例，常规下载方式为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> torch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改为阿里源：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> -i https://mirrors.aliyun.com/pypi/simple torchpip <span class="token function">install</span> pywinauto -i http://pypi.douban.com/simple --trusted-host pypi.douban.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-修改默认源"><a href="#2-修改默认源" class="headerlink" title="2. 修改默认源"></a>2. 修改默认源</h2><p>如果不想在每一次下载都指定源，可以直接修改默认源。</p><h3 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1 Linux"></a>2.1 Linux</h3><p>linux下运行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> ~/.pip/pip.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后写入如下内容并保存（以阿里源为例）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>global<span class="token punctuation">]</span> trusted-host <span class="token operator">=</span>  mirrors.aliyun.com index-url <span class="token operator">=</span> https://mirrors.aliyun.com/pypi/simple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2 Windows"></a>2.2 Windows</h3><p>在user目录下创建pip文件夹，pip文件夹下并创建pip.ini文件，文件内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>global<span class="token punctuation">]</span>index-url <span class="token operator">=</span> https://pypi.tuna.tsinghua.edu.cn/simple<span class="token punctuation">[</span>install<span class="token punctuation">]</span>trusted-host <span class="token operator">=</span> pypi.tuna.tsinghua.edu.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面&nbsp;&nbsp;index-url 取值为镜像源地址&nbsp;</p><p>　　&nbsp; trusted-host 取值为镜像源的域名</p><p><strong>2，国内常用镜像源如下</strong>：</p><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p><p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p><p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a> </p><p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><p><strong>目前感觉比较好用的是豆瓣的镜像</strong></p><h1 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h1><p>安装包时，显示 pip 版本过低</p><p><strong>WARNING: There was an error checking the latest version of pip.</strong></p><p><strong>报错内容翻译</strong>：警告：检查最新版本的pip时出错。</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>升级 pip 命令</p><ul><li><p>python -m pip install –upgrade pip</p></li><li><p>pip install –upgrade pip</p></li><li><p>python3 -m pip install –upgrade pip</p></li><li><p>python -m pip install -U –force-reinstall pip</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装问题 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用快捷键</title>
      <link href="/2022/09/06/typora-chang-yong-kuai-jie-jian/"/>
      <url>/2022/09/06/typora-chang-yong-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora免费版下载</title>
      <link href="/2022/09/06/typora-mian-fei-ban-xia-zai/"/>
      <url>/2022/09/06/typora-mian-fei-ban-xia-zai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora-旧版本不能使用-This-beta-version-of-Typora-is-expired-please-download-and-install-a-newer；一劳永逸解决方法"><a href="#Typora-旧版本不能使用-This-beta-version-of-Typora-is-expired-please-download-and-install-a-newer；一劳永逸解决方法" class="headerlink" title="Typora 旧版本不能使用,This beta version of Typora is expired, please download and install a newer；一劳永逸解决方法"></a>Typora 旧版本不能使用,This beta version of Typora is expired, please download and install a newer；一劳永逸解决方法</h1><h2 id="下载一个之前的版本"><a href="#下载一个之前的版本" class="headerlink" title="下载一个之前的版本"></a>下载一个之前的版本</h2><p><a href="https://typora.io/">Typora — a markdown editor, markdown reader.</a></p><h2 id="打开注册表"><a href="#打开注册表" class="headerlink" title="打开注册表"></a>打开注册表</h2><p>cmd–&gt;regedit</p><h2 id="修改-Typora-权限"><a href="#修改-Typora-权限" class="headerlink" title="修改 Typora 权限"></a>修改 Typora 权限</h2><p><strong>计算机\HKEY_CURRENT_USER\Software\Typora</strong></p><p><img src="https://img-blog.csdnimg.cn/601d251bc2654d2d8d32e4b6b3baf5c4.png" alt="在这里插入图片描述"></p><p><strong>右键Typora选择权限打开，组或用户名选择Administrators 然后选择拒绝</strong></p><p><img src="https://img-blog.csdnimg.cn/fd58e04d579b48b2b3220bb7f6691eb8.png" alt="在这里插入图片描述"></p><p><strong>再次打开Typora即可正常打开。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo解决无法显示图片的几种方案</title>
      <link href="/2022/09/06/hexo-jie-jue-wu-fa-xian-shi-tu-pian-de-ji-chong-fang-an/"/>
      <url>/2022/09/06/hexo-jie-jue-wu-fa-xian-shi-tu-pian-de-ji-chong-fang-an/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解决Hexo无法显示图片的几种方案"><a href="#解决Hexo无法显示图片的几种方案" class="headerlink" title="解决Hexo无法显示图片的几种方案"></a>解决Hexo无法显示图片的几种方案</h1><p><a href="%5B%E8%A7%A3%E5%86%B3Hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88_weixin_42030522%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_hexo%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%87%BA%E6%9D%A5%5D(https://blog.csdn.net/weixin_42030522/article/details/123075824)">文章链接</a></p><p>在搭建hexo博客的时候会遇见图片上传是否麻烦，使用markdown编写博客时我们习惯将图片保存到本地，使用‘![]{}’的格式+相对路径去插入图片，但是在使用<code>hexo d</code>的时候相对路径会被转换导致最后发布上去的博客图片无法查看。下面提供几种解决方案：</p><h2 id="使用hexo图片格式"><a href="#使用hexo图片格式" class="headerlink" title="使用hexo图片格式"></a>使用hexo图片格式</h2><p>查看hexo官网，可以看到官网推荐将<code>post_asset_folder</code>属性置为true，在新建博客<code>hexo n “xxx”</code>的时候会在根目录下创建一个同名的文件夹，将需要插入的图片放到这个目录。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/50a5055c5616e76e1fe9759104686c4a.png"></p><p>在markdown文件中使用如下格式进行图片的访问：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">{% asset_path slug %}{% asset_img slug [title] %}{% asset_link slug [title] %}{% asset_img example.jpg This is an example image %}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如此就能够在hexo中访问到图片，但是这种方式，我们在VScode或者Typora种编写文档的时候是无法查看到图片的，无法渲染。</p><p>为了解决无法渲染和不习惯的图片插入格式，可以使用hexo-asset-image。</p><p>在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p><h2 id="搭建阿里云图床-typora配置实现对象存储"><a href="#搭建阿里云图床-typora配置实现对象存储" class="headerlink" title="搭建阿里云图床+typora配置实现对象存储"></a>搭建阿里云图床+typora配置实现对象存储</h2><p>第二种方式使用图床，将图片上传到对象存储，好处是方便！！！</p><ol><li>首先申请一个对象存储OSS，登录阿里云-&gt;进入工作台-&gt;对象存储OSS</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/419fd6b62542b4e05d22c06bf1a4d5b9.png"></p><ol start="2"><li>点击创建Bucket：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/5d5cdbe4b37ac6de8a80d42d219afe0b.png" alt="image-20220222172433826"></p><ol start="3"><li>修改以下部分：</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/8b468cb9eafb72e672cb2f4b640490e4.png" alt="image-20220222184456883"></p><ol start="4"><li>开通完成后，先购买资源包（对象存储的下载和访问会消耗流量费用，建议购买一个资源包，半年也就5块钱不到）</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/2a393d8b44497c0e6c1eadac56431c65.png" alt="image-20220222184734852"></p><p>以上对象存储部分就申请好了，下面就是整合到PicGo</p><ol start="5"><li>下载typroa</li></ol><p>这里提供一个typroa的下载地址，当然还是建议付费，支持开发者。</p><p>链接：<a href="https://pan.baidu.com/s/1PpMt21LcWAH4MJrNvaWxWQ">https://pan.baidu.com/s/1PpMt21LcWAH4MJrNvaWxWQ</a></p><p>提取码：8jkp</p><ol start="6"><li>安装PicGo-Core插件</li></ol><p>下载好后依次点击：文件-&gt;偏好设置-&gt;图像，按照如下配置后点击下载或更新。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0fc2cbe188fcf9712868de9fd3a1888b.png" alt="image-20220222185817030"></p><ol start="7"><li>设置配置文件</li></ol><p>点击打开配置文件：按照如下配置</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"picBed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"uploader"</span><span class="token operator">:</span> <span class="token string">"aliyun"</span><span class="token punctuation">,</span>      <span class="token property">"aliyun"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"accessKeyId"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//ram的accessKey</span>      <span class="token property">"accessKeySecret"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//ram的accessKey</span>      <span class="token property">"bucket"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 桶名</span>      <span class="token property">"area"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 地域节点</span>      <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"img/"</span><span class="token punctuation">,</span> <span class="token comment">// 存储路径</span>       <span class="token property">"customUrl"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// Bucket域名，注意要加 http://或者 https://</span>       <span class="token property">"options"</span><span class="token operator">:</span> <span class="token string">""</span> <span class="token comment">// 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"picgoPlugins"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来就需要找到上面的配置：</p><p>首先是accessKey：访问accessKey管理</p><p><img src="https://img-blog.csdnimg.cn/img_convert/057bb3d5d551b0ebaa2dbf655a3fe54b.png" alt="image-20220222190413130"></p><p>然后会出现创建新的AccessKey：可以直接点击继续使用就是用当前用户进行创建AccessKey，不过还是建议使用子用户，规划一下权限。创建好后记得立马将显示的accessKeyId和accessKeySecret记录下来，后续没有地方可以查看，若是遗忘只能重新创建。</p><p>其余字段在对象存储-&gt;bucket列表-&gt;概览，分别是bucket、area、customUrl的值，其中area只需要三级域名也就是.aliyuncs.com之前的部分，customUrl则需要添加http://</p><p><img src="https://img-blog.csdnimg.cn/img_convert/223ea89d0111906427c10fb592ff5064.png" alt="image-20220222192511266"></p><p>剩下字段可以不配置。</p><ol start="8"><li>验证</li></ol><p>配置好后，就可以进行测试是否配置成功，点击验证图片上传选项，typora会将icon上传到对象存储中，可以自行去阿里云控制台查看是否有文件。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0fc2cbe188fcf9712868de9fd3a1888b.png" alt="image-20220222185817030"></p><ol start="9"><li>大功告成</li></ol><p>完成后，就可以直接在typora中复制图片或者使用快捷键ctrl+shift+i进行图片插入。typora会自动将图片上传到对象存储并将路径改为对象存储中的路径。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客技巧：添加自定义html页面</title>
      <link href="/2022/09/06/hexo-bo-ke-ji-qiao-tian-jia-zi-ding-yi-html-ye-mian/"/>
      <url>/2022/09/06/hexo-bo-ke-ji-qiao-tian-jia-zi-ding-yi-html-ye-mian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo博客技巧：添加自定义html页面"><a href="#Hexo博客技巧：添加自定义html页面" class="headerlink" title="Hexo博客技巧：添加自定义html页面"></a>Hexo博客技巧：添加自定义html页面</h1><p><a href="https://blog.csdn.net/weixin_58068682/article/details/116611715">Hexo博客技巧：添加自定义html页面_Chak Aciano的博客-CSDN博客_hexo 自定义页面</a></p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>1.首先在博客根目录的<code>source</code>文件夹下，新建一个文件夹用于存放要部署的HTML文件：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a666785c4c0c7e435463e454d6369083.png#pic_center" alt="在这里插入图片描述"></p><p>我这里建了一个叫<code>HTML</code>的文件夹，里面的子文件夹可以存放各个HTML文件，当然也可以只创建一个主文件夹，直接在里面放HTML文件。</p><p>2.然后在博客根目录的配置文件<code>_config.yml</code>文件里，设置跳过渲染：</p><ul><li>单个文件，就写：</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"># 跳过渲染skip_render<span class="token operator">:</span>   - <span class="token string">"xxxx.html"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果只创建了一个文件夹，要跳过它目录下所有文件的渲染，就写：</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"># 跳过文件夹下所有文件skip_render<span class="token operator">:</span>   - <span class="token string">"文件夹名/*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如果父文件夹下还有子文件夹，就写：</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"># 跳过子文件夹skip_render<span class="token operator">:</span>   - <span class="token string">"文件夹名/子文件夹名/*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>或更简单粗暴的方式：</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json"># 跳过文件夹下所有子文件夹和文件skip_render<span class="token operator">:</span>   - <span class="token string">"文件夹名/**"</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.最后处理css、js文件</p><p>因为hexo部署的是静态文件，所有文章的md文件会被渲染成html文件，<br>hexo会帮我们把所有css、js文件都加到文章里，我们之前跳过了渲染，所以就需要手动把css、js整合到html文件里</p><p>一般我们的代码就是这种结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f947011dca4437d5789c4a1f48f6c42.png#pic_center" alt="在这里插入图片描述"></p><p>下面处理分两部分：</p><ul><li>css：找到<code>index.html</code>文件里的语句,如：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css/xxx.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ 然后在css文件夹中找到对应的文件<code>xxx.css</code>，复制文件内容，把上面的代码改为：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"> css代码内容 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>js：找到<code>index.html</code>文件里的语句，如：</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/xxx.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ 然后在js文件夹中找到对应的文件<code>xxx.js</code>，复制文件内容，把上面的代码改为：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> js代码内容 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.检验成果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>部署后来到<a href="https://xxxxx.github.io/%E5%AD%98%E6%94%BEhtml%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/xxx.html">https://xxxxx.github.io/存放html文件的文件夹/xxx.html</a></p><p>即可查看到你的自定义html页面了！</p><p>建议在部署前先试试在本地能否打开，如果不行再按上文修改一次。</p><h2 id="其他的优化"><a href="#其他的优化" class="headerlink" title="其他的优化"></a>其他的优化</h2><p>如果想将这些html的界面放到导航菜单栏上，修改主题配置文件_config.butterfly.yml对应的导航菜单栏代码即可，这里将我的代码放出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>   <span class="token key atrule">主页</span><span class="token punctuation">:</span> / <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>home   <span class="token key atrule">时间轴</span><span class="token punctuation">:</span> /archives/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>archive   <span class="token key atrule">标签</span><span class="token punctuation">:</span> /tags/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>tags   <span class="token key atrule">分类</span><span class="token punctuation">:</span> /categories/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>folder<span class="token punctuation">-</span>open   <span class="token key atrule">Demo||fas fa-file-code</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> all html demo <span class="token punctuation">|</span><span class="token punctuation">|</span> /Demo/ <span class="token punctuation">|</span><span class="token punctuation">|</span> far fa<span class="token punctuation">-</span>file<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 圈小猫 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/圈小猫.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 撕渔网 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/撕渔网.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 纸飞机 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/纸飞机.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 彩虹雨 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/彩虹雨.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 方块穿梭 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/方块穿梭.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 碰撞小球 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/碰撞小球.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 烟花效果 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/烟花效果.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code     <span class="token punctuation">-</span> 骇客帝国 <span class="token punctuation">|</span><span class="token punctuation">|</span> /HTML/骇客帝国.html <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>code   <span class="token key atrule">娱乐||fas fa-list</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> 音乐 <span class="token punctuation">|</span><span class="token punctuation">|</span> /music/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>music     <span class="token punctuation">-</span> 电影 <span class="token punctuation">|</span><span class="token punctuation">|</span> /movies/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>video   <span class="token key atrule">友链</span><span class="token punctuation">:</span> /link/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>link   <span class="token key atrule">关于</span><span class="token punctuation">:</span> /about/ <span class="token punctuation">|</span><span class="token punctuation">|</span> fas fa<span class="token punctuation">-</span>heart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="我的Demo"><a href="#我的Demo" class="headerlink" title="我的Demo"></a>我的Demo</h1><p>可在导航菜单Demo栏查看我部署在网站上的html。</p><p>顺便也做个表格练练手吧：</p><table><thead><tr><th>html文件名</th><th>对应链接地址</th></tr></thead><tbody><tr><td>圈小猫</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E5%9C%88%E5%B0%8F%E7%8C%AB.html">圈小猫.html</a></td></tr><tr><td>撕渔网</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E6%92%95%E6%B8%94%E7%BD%91.html">撕渔网.html</a></td></tr><tr><td>纸飞机</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E7%BA%B8%E9%A3%9E%E6%9C%BA.html">纸飞机.html</a></td></tr><tr><td>彩虹雨</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E5%BD%A9%E8%99%B9%E9%9B%A8.html">彩虹雨.html</a></td></tr><tr><td>方块穿梭</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E6%96%B9%E5%9D%97%E7%A9%BF%E6%A2%AD.html">方块穿梭.html</a></td></tr><tr><td>碰撞小球</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E7%A2%B0%E6%92%9E%E5%B0%8F%E7%90%83.html">碰撞小球.html</a></td></tr><tr><td>烟花效果</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C.html">烟花效果.html</a></td></tr><tr><td>骇客帝国</td><td><a href="https://amnesia-f.github.io/HTML/Demo/%E9%AA%87%E5%AE%A2%E5%B8%9D%E5%9B%BD.html">骇客帝国.html</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用说明</title>
      <link href="/2022/09/06/hexo-shi-yong-shuo-ming/"/>
      <url>/2022/09/06/hexo-shi-yong-shuo-ming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>给出hexo-theme-matery 的仓库和一些使用说明</strong></p><p>[github 地址](<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery/README_CN.md at develop · blinkfox/hexo-theme-matery · GitHub</a>)</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件方法与工程</title>
      <link href="/2022/09/06/ruan-jian-fang-fa-yu-gong-cheng/"/>
      <url>/2022/09/06/ruan-jian-fang-fa-yu-gong-cheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单记录一些课程上的笔记，只有上网课的内容，之后去学校了，也没有机会记录了。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-10-36-01-Snipaste_2022-09-06_10-29-41.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-10-40-43-Snipaste_2022-09-06_10-40-33.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-10-41-17-Snipaste_2022-09-06_10-41-09.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-10-47-26-Snipaste_2022-09-06_10-47-15.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-11-17-43-Snipaste_2022-09-06_11-17-22.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-11-31-25-Snipaste_2022-09-06_11-31-12.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-11-36-09-Snipaste_2022-09-06_11-35-49.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo图片加载不出来</title>
      <link href="/2022/09/06/hexo-tu-pian-jia-zai-bu-chu-lai/"/>
      <url>/2022/09/06/hexo-tu-pian-jia-zai-bu-chu-lai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习小林图解的时候遇到的问题，复制图片链接，在网站中加载不出来，在网页中却可以加载出来，现在这个问题还没有得到解决。</p><p>不过在寻找答案的过程中学习到了 <strong>html  访问图片资源403问题解决办法</strong></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>之前碰到一个问题，就是html中通过img标签引入一个图片地址，报403。但是这个图片地址直接复制出来在地址栏打开，却是看得到的。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6383319-956f8513b3992982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1081/format/webp"></p><ul><li>先说下解决方法：&nbsp;<strong>在HTML代码的head中添加一句<code>&lt;meta name="referrer" content="no-referrer" /&gt;</code>即可</strong>，后面再说下原理。</li></ul><h1 id="http请求中的referrer"><a href="#http请求中的referrer" class="headerlink" title="http请求中的referrer"></a>http请求中的referrer</h1><ul><li><p>http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。</p></li><li><p>服务器端在拿到这个referrer值后就可以进行相关的处理，比如图片资源，可以通过referrer值判断请求是否来自本站，若不是则返回403或者重定向返回其他信息，从而实现图片的防盗链。上面出现403就是因为，请求的是别人服务器上的资源，但把自己的referrer信息带过去了，被对方服务器拦截返回了403。</p></li><li><p>在前端可以通过meta来设置referrer policy(来源策略)，具体可以设置哪些值以及对应的结果参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy">这里</a>。所以针对上面的403情况的解决方法，就是把referrer设置成<code>no-referrer</code>，这样发送请求不会带上referrer信息，对方服务器也就无法拦截了。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6383319-ddebca90d19accd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1070/format/webp"></p><ul><li>浏览器中referrer默认的值是<code>no-referrer-when-downgrade</code>，就是除了降级请求的情况以外都会带上referrer信息。降级请求是指https协议的地址去请求http协议，所以上面403的情况还有另一种解决方法就是，请求的图片地址换成http协议，自己的地址使用http协议，这样降级请求也不会带上referrer。</li></ul><h1 id="nginx配置图片防盗链"><a href="#nginx配置图片防盗链" class="headerlink" title="nginx配置图片防盗链"></a>nginx配置图片防盗链</h1><ul><li>最后再说一下这种根据referrer拦截，在服务器如何配置。我自己服务器用的nginx，这里就说下nginx的配置。首先打开nginx的配置文件:<code>conf/nginx.conf</code>，在server下面添加如下:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location ~* <span class="token punctuation">\</span>.<span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>png<span class="token operator">|</span>jpeg<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>        valid_referers none  valid.url.com<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$invalid_referer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token builtin class-name">return</span> <span class="token number">403</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>首先第一句以文件格式后缀匹配出图片资源路径，然后通过<code>valid_referers</code>添加合法的referer地址，加上none，表示没有传referer也是合法的，最后referer不合法的情况返回403。如果想跳其他地址或返回其他图片资源可以这样：<code>rewrite xxx.xxx.com/xxx.jpg</code>。</li></ul><h1 id="orgin"><a href="#orgin" class="headerlink" title="orgin"></a>orgin</h1><ul><li>http头部中还有一个与referrer类似的叫orgin的字段，在发送跨域请求或预检请求(preflight request)时会带上这个参数，他用来表示发起请求的服务器地址，这个参数是必定会传的，然后服务器端用此字段来判断是否允许跨域。</li></ul><h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>图片的懒加载就是在页面打开的时候，不要一次性全部显示页面所有的图片，而是只显示当前视口内的图片，一般在移动端使用（PC端主要是前端分页或者后端分页）。</p><h2 id="为什么需要懒加载"><a href="#为什么需要懒加载" class="headerlink" title="为什么需要懒加载"></a>为什么需要懒加载</h2><p>对于一个页面加载速度影响最大的因素之一就是图片资源，如果一个页面图片太多（比如某宝，某东等），整个页面的图片大小可以到达几百兆，即使在百兆宽带，全部下载的话，也需要上十秒的时间，这对于用户耐心的考验是巨大的，更别说网络差的地方了。</p><p>因此，懒加载是必须要做的，对于页面未在可视区域内显示的图片先不做加载处理，只加载第一映入眼帘的图片，由于可视区域显示的图片少，加载速度就会大大提升，用户体验也会更好。</p><p>而且，用户可能只翻看一两页就退出了，剩下未查看的图片也就不需要加载了。这也相当于节省了带宽资源。</p><h2 id="懒加载实现原理"><a href="#懒加载实现原理" class="headerlink" title="懒加载实现原理"></a>懒加载实现原理</h2><p>由于浏览器会自动对页面中的img标签的src属性发送请求并下载图片。因此，通过html5自定义属性&nbsp;<code>data-xxx</code>先暂存src的值，然后在需要显示的时候，再将&nbsp;<code>data-xxx</code>的值重新赋值到img的src属性即可。</p><h1 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h1><p><strong>现在还没有解决这个问题，在浏览器中复制的图片都是复制图片的链接，粘贴到md文档中可以显示，但是上传到网页中无法显示</strong></p><ul><li>目前来说解决办法是，将图片保存在本地，然后粘贴到 md 文档中，这样就会上传到 github 图床中，然后在网页中就可以加载，但是这样来说太麻烦了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 未解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2022/09/06/bian-yi-yuan-li/"/>
      <url>/2022/09/06/bian-yi-yuan-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单记录一些课程上的笔记，只有上网课的内容，之后去学校了，也没有机会记录了。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-09-40-44-Snipaste_2022-09-06_09-40-12.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-09-40-50-Snipaste_2022-09-06_09-40-17.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解网络</title>
      <link href="/2022/09/05/tu-jie-wang-luo/"/>
      <url>/2022/09/05/tu-jie-wang-luo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h1 id="2-1-TCP-IP-网络模型有哪几层？"><a href="#2-1-TCP-IP-网络模型有哪几层？" class="headerlink" title="2.1 TCP/IP 网络模型有哪几层？"></a>2.1 TCP/IP 网络模型有哪几层？</h1><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套<strong>通用的网络协议</strong>。</p><p>这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP/IP 网络模型」分别对每一层进行介绍。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>（<em>Application Layer</em>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。</p><p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><img title="" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="" data-align="inline"><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个&nbsp;<strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png"></p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p><p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p><p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。</p><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p><p>举个例子，比如 10.100.122.0/24，后面的<code>/24</code>表示就是&nbsp;<code>255.255.255.0</code>&nbsp;子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。</p><p>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</p><p>将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="img"></p><p>将 255.255.255.0 取反后与IP地址进行进行<strong>按位与运算</strong>，就可以得到主机号。</p><p>大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="子网掩码计算器"></p><p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p><p>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号"></p><p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png"></p><p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。</p><p>什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="http://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png"></p><p>再给大家贴一下每一层的封装格式：</p><img title="" src="http://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt=""><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h1 id="2-2-键入网址到网页显示，期间发生了什么？"><a href="#2-2-键入网址到网页显示，期间发生了什么？" class="headerlink" title="2.2 键入网址到网页显示，期间发生了什么？"></a>2.2 键入网址到网页显示，期间发生了什么？</h1><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-11-14-43-2.webp"></p><h2 id="孤单小弟-——-HTTP"><a href="#孤单小弟-——-HTTP" class="headerlink" title="孤单小弟 —— HTTP"></a>孤单小弟 —— HTTP</h2><blockquote><p>浏览器做的第一步工作是解析 URL</p></blockquote><p>首先浏览器做的第一步工作就是要对&nbsp;<code>URL</code>&nbsp;进行解析，从而生成发送给&nbsp;<code>Web</code>&nbsp;服务器的请求信息。</p><p>让我们看看一条长长的 URL 里的各个元素的代表什么，见下图：</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/06-11-26-13-3.webp"></p><p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p><blockquote><p>要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？</p></blockquote><p>当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是&nbsp;<code>/index.html</code>&nbsp;或者&nbsp;<code>/default.html</code>&nbsp;这些文件，这样就不会发生混乱了。</p><blockquote><p>生产 HTTP 请求信息</p></blockquote><p>对&nbsp;<code>URL</code>&nbsp;进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg" alt="HTTP 的消息格式"></p><blockquote><p>一个孤单 HTTP 数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！</p></blockquote><h2 id="真实地址查询-——-DNS"><a href="#真实地址查询-——-DNS" class="headerlink" title="真实地址查询 —— DNS"></a>真实地址查询 —— DNS</h2><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给&nbsp;<code>Web</code>&nbsp;服务器。</p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p><p>所以，有一种服务器就专门保存了&nbsp;<code>Web</code>&nbsp;服务器域名与&nbsp;<code>IP</code>&nbsp;的对应关系，它就是&nbsp;<code>DNS</code>&nbsp;服务器。</p><p><strong>域名的层级关系</strong></p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如&nbsp;<code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>实际上域名最后还有一个点，比如&nbsp;<code>www.server.com.</code>，这个最后的一个点代表根域名。</p><p>也就是，<code>.</code>&nbsp;根域是在最顶层，它的下一层就是&nbsp;<code>.com</code>&nbsp;顶级域，再下面是&nbsp;<code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（server.com）</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构"></p><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p><p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p><p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><blockquote><p>域名解析的工作流程</p></blockquote><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程"></p><p>DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<strong>只指路不带路</strong>。</p><blockquote><p>那是不是每次解析域名都要经过那么多的步骤呢？</p></blockquote><p>当然不是了，还有缓存这个东西的嘛。</p><p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p><blockquote><p>数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”</p></blockquote><h2 id="指南好帮手-——-协议栈"><a href="#指南好帮手-——-协议栈" class="headerlink" title="指南好帮手 —— 协议栈"></a>指南好帮手 —— 协议栈</h2><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg"></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括&nbsp;<code>ICMP</code>&nbsp;协议和&nbsp;<code>ARP</code>&nbsp;协议。</p><ul><li><code>ICMP</code>&nbsp;用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code>&nbsp;用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><blockquote><p>数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找找 TCP 大佬！”</p></blockquote><h2 id="可靠传输-——-TCP"><a href="#可靠传输-——-TCP" class="headerlink" title="可靠传输 —— TCP"></a>可靠传输 —— TCP</h2><p>HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。</p><blockquote><p>TCP 包头格式</p></blockquote><p>我们先看看 TCP 报文头部的格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg" alt="TCP 包头格式"></p><p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p><p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。</p><p>接下来还有一些<strong>状态位</strong>。例如&nbsp;<code>SYN</code>&nbsp;是发起一个连接，<code>ACK</code>&nbsp;是回复，<code>RST</code>&nbsp;是重新连接，<code>FIN</code>&nbsp;是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p><blockquote><p>TCP 传输数据之前，要先三次握手建立连接</p></blockquote><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><ul><li><p>一开始，客户端和服务端都处于&nbsp;<code>CLOSED</code>&nbsp;状态。先是服务端主动监听某个端口，处于&nbsp;<code>LISTEN</code>&nbsp;状态。</p></li><li><p>然后客户端主动发起连接&nbsp;<code>SYN</code>，之后处于&nbsp;<code>SYN-SENT</code>&nbsp;状态。</p></li><li><p>服务端收到发起的连接，返回&nbsp;<code>SYN</code>，并且&nbsp;<code>ACK</code>&nbsp;客户端的&nbsp;<code>SYN</code>，之后处于&nbsp;<code>SYN-RCVD</code>&nbsp;状态。</p></li><li><p>客户端收到服务端发送的&nbsp;<code>SYN</code>&nbsp;和&nbsp;<code>ACK</code>&nbsp;之后，发送对&nbsp;<code>SYN</code>&nbsp;确认的&nbsp;<code>ACK</code>，之后处于&nbsp;<code>ESTABLISHED</code>&nbsp;状态，因为它一发一收成功了。</p></li><li><p>服务端收到&nbsp;<code>ACK</code>&nbsp;的&nbsp;<code>ACK</code>&nbsp;之后，处于&nbsp;<code>ESTABLISHED</code>&nbsp;状态，因为它也一发一收了。</p></li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><blockquote><p>如何查看 TCP 的连接状态？</p></blockquote><p>TCP 的连接状态查看，在 Linux 可以通过&nbsp;<code>netstat -napt</code>&nbsp;命令查看。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg" alt="TCP 连接状态查看"></p><blockquote><p>TCP 分割数据</p></blockquote><p>如果 HTTP 请求消息比较长，超过了&nbsp;<code>MSS</code>&nbsp;的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg" alt="MTU 与 MSS"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为&nbsp;<code>1500</code>&nbsp;字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被以&nbsp;<code>MSS</code>&nbsp;的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="数据包分割"></p><blockquote><p>TCP 报文生成</p></blockquote><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是&nbsp;<code>80</code>， HTTPS 默认端口号是&nbsp;<code>443</code>）。</p><p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg" alt="TCP 层报文"></p><blockquote><p>此时，遇上了 TCP 的 数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”</p></blockquote><h2 id="远程定位-——-IP"><a href="#远程定位-——-IP" class="headerlink" title="远程定位 —— IP"></a>远程定位 —— IP</h2><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><blockquote><p>IP 包头格式</p></blockquote><p>我们先看看 IP 报文头部的格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg" alt="IP 包头格式"></p><p>在 IP 协议里面需要有<strong>源地址 IP</strong>&nbsp;和&nbsp;<strong>目标地址 IP</strong>：</p><ul><li>源地址IP，即是客户端输出的 IP 地址；</li><li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为&nbsp;<code>06</code>（十六进制），表示协议为 TCP。</p><blockquote><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p></blockquote><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p><p>在 Linux 操作系统，我们可以使用&nbsp;<code>route -n</code>&nbsp;命令查看当前系统的路由表。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/15.jpg" alt="路由表"></p><p>举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是&nbsp;<code>192.168.10.200</code>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg" alt="路由规则判断"></p><ol><li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行&nbsp;<strong>与运算</strong>，得到结果为&nbsp;<code>192.168.10.0</code>，但是第一个条目的&nbsp;<code>Destination</code>&nbsp;是&nbsp;<code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行&nbsp;<strong>与运算</strong>，得到的结果为&nbsp;<code>192.168.10.0</code>，与第二条目的&nbsp;<code>Destination 192.168.10.0</code>&nbsp;匹配成功，所以将使用&nbsp;<code>eth1</code>&nbsp;网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是&nbsp;<code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p><p>第三条目比较特殊，它目标地址和子网掩码都是&nbsp;<code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code>&nbsp;即是路由器的 IP 地址。</p><blockquote><p>IP 报文生成</p></blockquote><p>至此，网络包的报文如下图。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg" alt="IP 层报文"></p><blockquote><p>此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</p></blockquote><h2 id="两点传输-——-MAC"><a href="#两点传输-——-MAC" class="headerlink" title="两点传输 —— MAC"></a>两点传输 —— MAC</h2><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上&nbsp;<strong>MAC 头部</strong>。</p><blockquote><p>MAC 包头格式</p></blockquote><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg" alt="MAC 包头格式"></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code>&nbsp;： IP 协议</li><li><code>0806</code>&nbsp;： ARP 协议</li></ul><blockquote><p>MAC 发送方和接收方如何确认?</p></blockquote><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p><p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给&nbsp;<code>Gateway</code>&nbsp;列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>不知道对方 MAC 地址？不知道就喊呗。</p><p>此时就需要&nbsp;<code>ARP</code>&nbsp;协议帮我们找到路由器的 MAC 地址。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg" alt="ARP 广播"></p><p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了</p><blockquote><p>好像每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>放心，在后续操作系统会把本次查询结果放到一块叫做&nbsp;<strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。<br>也就是说，在发包时：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><blockquote><p>查看 ARP 缓存内容</p></blockquote><p>在 Linux 系统中，我们可以使用&nbsp;<code>arp -a</code>&nbsp;命令来查看 ARP 缓存的内容。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg" alt="ARP 缓存内容"></p><blockquote><p>MAC 报文生成</p></blockquote><p>至此，网络包的报文如下图</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg" alt="MAC 层报文"></p><blockquote><p>此时，加上了 MAC 头部的数据包万分感谢，说道 ：“感谢 MAC 大佬，我知道我下一步要去哪了！我现在有很多头部兄弟，相信我可以到达最终的目的地！”。 带着众多头部兄弟的数据包，终于准备要出门了。</p></blockquote><h2 id="出口-——-网卡"><a href="#出口-——-网卡" class="headerlink" title="出口 —— 网卡"></a>出口 —— 网卡</h2><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包"></p><ul><li>起始帧分界符是一个用来表示包起始位置的标记</li><li>末尾的&nbsp;<code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><blockquote><p>唉，真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！</p></blockquote><h2 id="送别者-——-交换机"><a href="#送别者-——-交换机" class="headerlink" title="送别者 —— 交换机"></a>送别者 —— 交换机</h2><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><blockquote><p>交换机的包接收操作</p></blockquote><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的&nbsp;<code>FCS</code>&nbsp;校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg" alt="交换机的 MAC 地址表"></p><p>举个例子，如果收到的包的接收方 MAC 地址为&nbsp;<code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于&nbsp;<code>3</code>&nbsp;号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><blockquote><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p><p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p><p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>以下两个属于广播地址：</p><ul><li>MAC 地址中的&nbsp;<code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的&nbsp;<code>255.255.255.255</code></li></ul><blockquote><p>数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”</p></blockquote><h2 id="出境大门-——-路由器"><a href="#出境大门-——-路由器" class="headerlink" title="出境大门 —— 路由器"></a>出境大门 —— 路由器</h2><blockquote><p>路由器与交换机的区别</p></blockquote><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><p>不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><blockquote><p>路由器基本原理</p></blockquote><p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><blockquote><p>路由器的包接收操作</p></blockquote><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的&nbsp;<code>FCS</code>&nbsp;进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><blockquote><p>查询路由表确定输出端口</p></blockquote><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的&nbsp;<code>IP</code>&nbsp;头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" alt="路由器转发"></p><p>具体的工作流程根据上图，举个例子。</p><p>假设地址为&nbsp;<code>10.10.1.101</code>&nbsp;的计算机要向地址为&nbsp;<code>192.168.1.100</code>&nbsp;的服务器发送一个包，这个包先到达图中的路由器。</p><p>判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p><p>路由匹配和前面讲的一样，每个条目的子网掩码和&nbsp;<code>192.168.1.100</code>&nbsp;IP 做&nbsp;<strong>&amp; 与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。</p><p>如第二条目的子网掩码&nbsp;<code>255.255.255.0</code>&nbsp;与&nbsp;<code>192.168.1.100</code>&nbsp;IP 做&nbsp;<strong>&amp; 与运算</strong>后，得到结果是&nbsp;<code>192.168.1.0</code>&nbsp;，这与第二条目的目标地址&nbsp;<code>192.168.1.0</code>&nbsp;匹配，该第二条目记录就会被作为转发目标。</p><p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为&nbsp;<code>0.0.0.0</code>&nbsp;的记录表示「默认路由」。</p><blockquote><p>路由器的发送操作</p></blockquote><p>接下来就会进入包的<strong>发送操作</strong>。</p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过&nbsp;<code>ARP</code>&nbsp;协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写&nbsp;<code>0800</code>&nbsp;（十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><blockquote><p>数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了目的地了。数据包感慨万千的说道：“多谢这一路上，各路大侠的相助！”</p></blockquote><h2 id="互相扒皮-——-服务器-与-客户端"><a href="#互相扒皮-——-服务器-与-客户端" class="headerlink" title="互相扒皮 —— 服务器 与 客户端"></a>互相扒皮 —— 服务器 与 客户端</h2><p>数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？</p><p>服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg" alt="网络分层模型"></p><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p><p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p><p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p><h2 id="一个数据包臭不要脸的感受"><a href="#一个数据包臭不要脸的感受" class="headerlink" title="一个数据包臭不要脸的感受"></a>一个数据包臭不要脸的感受</h2><blockquote><p>下面内容的 「我」，代表「臭美的数据包角色」。注：（括号的内容）代表我的吐槽，三连呸！</p></blockquote><p>我一开始我虽然孤单、不知所措，但没有停滞不前。我依然满怀信心和勇气开始了征途。（<strong>你当然有勇气，你是应用层数据，后面有底层兄弟当靠山，我呸！</strong>）</p><p>我很庆幸遇到了各路神通广大的大佬，有可靠传输的 TCP、有远程定位功能的 IP、有指明下一站位置的 MAC 等（<strong>你当然会遇到，因为都被计算机安排好的，我呸！</strong>）。</p><p>这些大佬都给我前面加上了头部，使得我能在交换机和路由器的转发下，抵达到了目的地！（<strong>哎，你也不容易，不吐槽了，放过你！</strong>）</p><p>这一路上的经历，让我认识到了网络世界中各路大侠协作的重要性，是他们维护了网络世界的秩序，感谢他们！（<strong>我呸，你应该感谢众多计算机科学家！</strong>）</p><h2 id="读者问答"><a href="#读者问答" class="headerlink" title="读者问答"></a>读者问答</h2><blockquote><p>读者问：“笔记本的是自带交换机的吗？交换机现在我还不知道是什么”</p></blockquote><p>笔记本不是交换机，交换机通常是2个网口以上。</p><p>现在家里的路由器其实有了交换机的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。</p><blockquote><p>读者问：“如果知道你电脑的mac地址，我可以直接给你发消息吗？”</p></blockquote><p>Mac地址只能是两个设备之间传递时使用的，如果你要从大老远给我发消息，是离不开 IP 的。</p><blockquote><p>读者问：“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？</p></blockquote><p>在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 arp 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。</p><p>转发的过程中，源IP地址和目标IP地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p><h1 id="2-3-Linux-系统是如何收发网络包的？"><a href="#2-3-Linux-系统是如何收发网络包的？" class="headerlink" title="2.3 Linux 系统是如何收发网络包的？"></a>2.3 Linux 系统是如何收发网络包的？</h1><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（<em>Open System Interconnection Reference Model</em>），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p><p>每一层负责的职能都不同，如下：</p><ul><li><p>应用层，负责给应用程序提供统一的接口；</p></li><li><p>表示层，负责把数据转换成兼容另一个系统能识别的格式；</p></li><li><p>会话层，负责建立、管理和终止表示层实体之间的通信会话；</p></li><li><p>传输层，负责端到端的数据传输；</p></li><li><p>网络层，负责数据的路由、转发、分片；</p></li><li><p>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</p></li><li><p>物理层，负责在物理网络中传输数据帧；</p></li></ul><p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。</p><p>事实上，我们比较常见，也比较实用的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p><p>TCP/IP 网络模型共有 4 层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：</p><ul><li>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</li><li>传输层，负责端到端的通信，比如 TCP、UDP 等；</li><li>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</li><li>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；</li></ul><p>TCP/IP 网络模型相比 OSI 网络模型简化了不少，也更加易记，它们之间的关系如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/OSI%E4%B8%8ETCP.png"></p><p>不过，我们常说的七层和四层负载均衡，是用 OSI 网络模型来描述的，七层对应的是应用层，四层对应的是传输层。</p><h2 id="Linux-网络协议栈"><a href="#Linux-网络协议栈" class="headerlink" title="Linux 网络协议栈"></a>Linux 网络协议栈</h2><p>我们可以把自己的身体比作应用层中的数据，打底衣服比作传输层中的 TCP 头，外套比作网络层中 IP 头，帽子和鞋子分别比作网络接口层的帧头和帧尾。</p><p>在冬天这个季节，当我们要从家里出去玩的时候，自然要先穿个打底衣服，再套上保暖外套，最后穿上帽子和鞋子才出门，这个过程就好像我们把 TCP 协议通信的网络包发出去的时候，会把应用层的数据按照网络协议栈层层封装和处理。</p><p>你从下面这张图可以看到，应用层数据在每一层的封装格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png"></p><p>其中：</p><ul><li>传输层，给应用数据前面增加了 TCP 头；</li><li>网络层，给 TCP 数据包前面增加了 IP 头；</li><li>网络接口层，给 IP 数据包前后分别增加了帧头和帧尾；</li></ul><p>这些新增的头部和尾部，都有各自的作用，也都是按照特定的协议格式填充，这每一层都增加了各自的协议头，那自然网络包的大小就增大了，但物理链路并不能传输任意大小的数据包，所以在以太网中，规定了最大传输单元（MTU）是&nbsp;<code>1500</code>&nbsp;字节，也就是规定了单次传输的最大 IP 包大小。</p><p>当网络包超过 MTU 的大小，就会在网络层分片，以确保分片后的 IP 包不会超过 MTU 大小，如果 MTU 越小，需要的分包就越多，那么网络吞吐能力就越差，相反的，如果 MTU 越大，需要的分包就越少，那么网络吞吐能力就越好。</p><p>知道了 TCP/IP 网络模型，以及网络包的封装原理后，那么 Linux 网络协议栈的样子，你想必猜到了大概，它其实就类似于 TCP/IP 的四层结构：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png"></p><p>从上图的的网络协议栈，你可以看到：</p><ul><li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li><li>Socket 层的下面就是传输层、网络层和网络接口层；</li><li>最下面的一层，则是网卡驱动程序和硬件网卡设备；</li></ul><h2 id="Linux-接收网络包的流程"><a href="#Linux-接收网络包的流程" class="headerlink" title="Linux 接收网络包的流程"></a>Linux 接收网络包的流程</h2><p>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p><blockquote><p>那应该怎么告诉操作系统这个网络包已经到达了呢？</p></blockquote><p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p><p>但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p><p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了&nbsp;<strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后&nbsp;<code>poll</code>&nbsp;的方法来轮询数据。</p><p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>硬件中断处理函数会做如下的事情：</p><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><p>至此，硬件中断处理函数的工作就已经完成。</p><p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p><blockquote><p>软中断的处理</p></blockquote><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</p><p>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><blockquote><p>网络协议栈</p></blockquote><p>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</p><p>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</p><p>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</p><p>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p><p>至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png"></p><h2 id="Linux-发送网络包的流程"><a href="#Linux-发送网络包的流程" class="headerlink" title="Linux 发送网络包的流程"></a>Linux 发送网络包的流程</h2><p>如上图的右半部分，发送网络包的流程正好和接收流程相反。</p><p>首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</p><p>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理。</p><p>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 sk_buff 副本</strong>&nbsp;，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p><p>接着，对 sk_buff 填充 TCP 头。这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p><p>你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p><p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中&nbsp;<code>data</code>&nbsp;的指针，比如：</p><ul><li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。</li><li>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。</li></ul><p>你可以从下面这张图看到，当发送报文时，data 指针的移动过程。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/sk_buff.jpg"></p><p>至此，传输层的工作也就都完成了</p><p>然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p><p>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。</p><p>这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p><p>当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</p><p>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。</p><blockquote><p>发送网络数据的时候，涉及几次内存拷贝操作？</p></blockquote><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>电脑与电脑之间通常都是通过话网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个七层的 OSI 网络模型，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP/IP 模型，Linux 网络协议栈就是按照了该模型来实现的。</p><p>TCP/IP 模型主要分为应用层、传输层、网络层、网络接口层四层，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。</p><p>当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。</p><p>而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。</p><h1 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h1><h1 id="3-1-HTTP-常见面试题"><a href="#3-1-HTTP-常见面试题" class="headerlink" title="3.1 HTTP 常见面试题"></a>3.1 HTTP 常见面试题</h1><ol><li>HTTP 基本概念</li><li>Get 与 Post</li><li>HTTP 特性</li><li>HTTP 缓存技术</li><li>HTTPS 与 HTTP</li><li>HTTP/1.1、HTTP/2、HTTP/3 演变</li></ol><p><img src="https://img-blog.csdnimg.cn/6b9bfd38d2684b3f9843ebabf8771212.png" alt="提纲"></p><h2 id="HTTP-基本概念"><a href="#HTTP-基本概念" class="headerlink" title="HTTP 基本概念"></a>HTTP 基本概念</h2><h3 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h3><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText&nbsp;<strong>T</strong>ransfer&nbsp;<strong>P</strong>rotocol。</p><blockquote><p>能否详细解释「超文本传输协议」？</p></blockquote><p>HTTP的名字「超文本协议传输」，它可以拆成三个部分：</p><ul><li>超文本</li><li>传输</li><li>协议</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3-HTTP%E4%B8%89%E9%83%A8%E5%88%86.png" alt="三个部分"></p><p><em>1. 「协议」</em></p><p>在生活中，我们也能随处可见「协议」，例如：</p><ul><li>刚毕业时会签一个「三方协议」；</li><li>找房子时会签一个「租房协议」；<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/4-%E7%A7%9F%E6%88%BF%E5%92%8C%E4%B8%89%E6%96%B9%E5%8D%8F%E8%AE%AE.png" alt="三方协议和租房协议"></li></ul><p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:</p><ul><li>「<strong>协</strong>」字，代表的意思是必须有<strong>两个以上的参与者</strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</li><li>「<strong>议</strong>」字，代表的意思是对参与者的一种<strong>行为约定和规范</strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。</li></ul><p>针对 HTTP&nbsp;<strong>协议</strong>，我们可以这么理解。</p><p>HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</p><p><em>2. 「传输」</em></p><p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。</p><p>别轻视了这个简单的动作，它至少包含两项重要的信息。</p><p>HTTP 协议是一个<strong>双向协议</strong>。</p><p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5-%E8%AF%B7%E6%B1%82%E5%BA%94%E7%AD%94.png" alt="请求 - 应答"></p><p>数据虽然是在 A 和 B 之间传输，但允许中间有<strong>中转或接力</strong>。</p><p>就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; — &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。</p><p>而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</p><p>针对<strong>传输</strong>，我们可以进一步理解了 HTTP。</p><p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p><p><em>3. 「超文本」</em></p><p>HTTP 传输的内容是「超文本」。</p><p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p><p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</p><p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p><p>OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：</p><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><blockquote><p>那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议 ，这种说法正确吗？</p></blockquote><p>这种说法是<strong>不正确</strong>的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用<strong>两点之间</strong>的描述会更准确。</p><h3 id="HTTP-常见的状态码有哪些？"><a href="#HTTP-常见的状态码有哪些？" class="headerlink" title="HTTP 常见的状态码有哪些？"></a>HTTP 常见的状态码有哪些？</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="五大类 HTTP 状态码"></p><p><code>1xx</code>&nbsp;类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code>&nbsp;类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li><p>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非&nbsp;<code>HEAD</code>&nbsp;请求，服务器返回的响应头都会有 body 数据。</p></li><li><p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul><p><code>3xx</code>&nbsp;类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p></li></ul><p>301 和 302 都会在响应头里使用字段&nbsp;<code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code>&nbsp;类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li><p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li><li><p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p></li><li><p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ul><p><code>5xx</code>&nbsp;类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li><p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p></li><li><p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p></li><li><p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p></li><li><p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</p></li></ul><h3 id="HTTP-常见字段有哪些？"><a href="#HTTP-常见字段有哪些？" class="headerlink" title="HTTP 常见字段有哪些？"></a>HTTP 常见字段有哪些？</h3><p><em>Host</em>&nbsp;字段</p><p>客户端发送请求时，用来指定服务器的域名。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/7-HOST%E5%AD%97%E6%AE%B5.png"></p><pre class="line-numbers language-none"><code class="language-none">Host: www.A.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有了&nbsp;<code>Host</code>&nbsp;字段，就可以将请求发往「同一台」服务器上的不同网站。</p><p><em>Content-Length 字段</em></p><p>服务器在返回数据时，会有&nbsp;<code>Content-Length</code>&nbsp;字段，表明本次回应的数据长度。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/8-content-length%E5%AD%97%E6%AE%B5.png"></p><pre class="line-numbers language-none"><code class="language-none">Content-Length: 1000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p><p><em>Connection 字段</em></p><p><code>Connection</code>&nbsp;字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/9-connection%E5%AD%97%E6%AE%B5.png"></p><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定&nbsp;<code>Connection</code>&nbsp;首部字段的值为&nbsp;<code>Keep-Alive</code>。</p><pre class="line-numbers language-none"><code class="language-none">Connection: keep-alive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><p><em>Content-Type 字段</em></p><p><code>Content-Type</code>&nbsp;字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/10-content-type%E5%AD%97%E6%AE%B5.png"></p><pre class="line-numbers language-none"><code class="language-none">Content-Type: text/html; charset=utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用&nbsp;<code>Accept</code>&nbsp;字段声明自己可以接受哪些数据格式。</p><pre class="line-numbers language-none"><code class="language-none">Accept: */*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>Content-Encoding 字段</em></p><p><code>Content-Encoding</code>&nbsp;字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png"></p><pre class="line-numbers language-none"><code class="language-none">Content-Encoding: gzip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p><p>客户端在请求时，用&nbsp;<code>Accept-Encoding</code>&nbsp;字段说明自己可以接受哪些压缩方法。</p><pre class="line-numbers language-none"><code class="language-none">Accept-Encoding: gzip, deflate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h2><h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</p><p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/12-Get%E8%AF%B7%E6%B1%82.png" alt="GET 请求"></p><p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p><p>比如，你在我文章底部，敲入了留言后点击「提交」（<strong>暗示你们留言</strong>），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/13-Post%E8%AF%B7%E6%B1%82.png" alt="POST 请求"></p><h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><p>先说明下安全和幂等的概念：</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong>&nbsp;因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p><p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存</p><p>注意， 上面是从 RFC 规范定义的语义来分析的。</p><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li><li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li></ul><p>曾经有个笑话，有人写了个博客，删除博客用的是GET请求，他觉得没人访问就连鉴权都没做。然后Google服务器爬虫爬了一遍，他所有博文就没了。。。</p><p>如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。</p><p>因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。</p><p>所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。</p><blockquote><p>GET 请求可以带 body 吗？</p></blockquote><p>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。</p><p>另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p><h2 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h2><h3 id="HTTP-缓存有哪些实现方式？"><a href="#HTTP-缓存有哪些实现方式？" class="headerlink" title="HTTP 缓存有哪些实现方式？"></a>HTTP 缓存有哪些实现方式？</h3><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。</p><p>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h3 id="什么是强制缓存？"><a href="#什么是强制缓存？" class="headerlink" title="什么是强制缓存？"></a>什么是强制缓存？</h3><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><p>如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。</p><p><img src="https://img-blog.csdnimg.cn/1cb6bc37597e4af8adfef412bfc57a42.png"></p><p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control的优先级高于 Expires</strong>&nbsp;。</p><p>Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h3 id="什么是协商缓存？"><a href="#什么是协商缓存？" class="headerlink" title="什么是协商缓存？"></a>什么是协商缓存？</h3><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是&nbsp;<code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png"></p><p>上图就是一个协商缓存的过程，所以<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的&nbsp;<code>If-Modified-Since</code>&nbsp;字段与响应头部中的&nbsp;<code>Last-Modified</code>&nbsp;字段实现，这两个字段的意思是：</p><ul><li>响应头部中的&nbsp;<code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的&nbsp;<code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的&nbsp;<code>If-None-Match</code>&nbsp;字段与响应头部中的&nbsp;<code>ETag</code>&nbsp;字段，这两个字段的意思是：</p><ul><li>响应头部中&nbsp;<code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的&nbsp;<code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p><p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<strong>这时 Etag 的优先级更高</strong>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。</p><p><strong>为什么 ETag 的优先级更高</strong>?这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code>&nbsp;能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>下图是强制缓存和协商缓存的工作流程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png"></p><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li><li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li>服务器再次收到请求后，<strong>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</strong>：<ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li></ul><h2 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h2><h3 id="HTTP（1-1）-的优点有哪些？"><a href="#HTTP（1-1）-的优点有哪些？" class="headerlink" title="HTTP（1.1） 的优点有哪些？"></a>HTTP（1.1） 的优点有哪些？</h3><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p><p><em>1. 简单</em></p><p>HTTP 基本的报文格式就是&nbsp;<code>header + body</code>，头部信息也是&nbsp;<code>key-value</code>&nbsp;简单文本的形式，<strong>易于理解</strong>，降低了学习和使用的门槛。</p><p><em>2. 灵活和易于扩展</em></p><p>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong>。</p><p>同时 HTTP 由于是工作在应用层（&nbsp;<code>OSI</code>&nbsp;第七层），则它<strong>下层可以随意变化</strong>。</p><p>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</p><p><em>3. 应用广泛和跨平台</em></p><p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有<strong>跨平台</strong>的优越性。</p><h3 id="HTTP（1-1）-的缺点有哪些？"><a href="#HTTP（1-1）-的缺点有哪些？" class="headerlink" title="HTTP（1.1） 的缺点有哪些？"></a>HTTP（1.1） 的缺点有哪些？</h3><p>HTTP 协议里有优缺点一体的<strong>双刃剑</strong>，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</p><p><em>1. 无状态双刃剑</em></p><p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p><p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p><p>这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是<strong>酸爽</strong>！</p><p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用&nbsp;<strong>Cookie</strong>&nbsp;技术。</p><p><code>Cookie</code>&nbsp;通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>相当于，<strong>在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了</strong>，</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/14-cookie%E6%8A%80%E6%9C%AF.png" alt="Cookie 技术"></p><p><em>2. 明文传输双刃剑</em></p><p>明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p><p>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/15-%E4%BD%A0%E5%8F%B7%E6%B2%A1%E4%BA%86.png"></p><p><em>3. 不安全</em></p><p>HTTP 比较严重的缺点就是不安全：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li></ul><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</p><h3 id="HTTP-1-1-的性能如何？"><a href="#HTTP-1-1-的性能如何？" class="headerlink" title="HTTP/1.1 的性能如何？"></a>HTTP/1.1 的性能如何？</h3><p>HTTP 协议是基于&nbsp;<strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p><p><em>1. 长连接</em></p><p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="短连接与长连接"></p><p>当然，如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。</p><p><em>2. 管道网络传输</em></p><p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="管道网络传输"></p><p>但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p><p>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。</p><p>所以，<strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><blockquote><p>TIP</p><p>注意!</p><p>实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以<strong>后面所有文章讨论HTTP/1.1 都是建立在没有使用管道化的前提</strong>。大家知道有这个功能，但是没有被使用就行了。</p></blockquote><p><em>3. 队头阻塞</em></p><p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p><p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/18-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.png" alt="队头阻塞"></p><p>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。</p><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><h3 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h3><ol><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><h3 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h3><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p><p>HTTP<strong>S</strong>&nbsp;在 HTTP 与 TCP 层之间加入了&nbsp;<code>SSL/TLS</code>&nbsp;协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。</p><blockquote><p>HTTPS 是如何解决上面的三个风险的？</p></blockquote><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><p><em>1. 混合加密</em></p><p>通过<strong>混合加密</strong>的方式可以保证信息的<strong>机密性</strong>，解决了窃听的风险。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="混合加密"></p><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><p><em>2. 摘要算法 + 数字签名</em></p><p>为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。</p><p>对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><p>那么，在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png"></p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><p>举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。</p><p>但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。</p><p>那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p><p>那为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p><ul><li>一个是公钥，这个是可以公开给所有人的；</li><li>一个是私钥，这个必须由本人管理，不可泄露。</li></ul><p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p><p>流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p><p>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><p>引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥，你老师持有着公钥。</p><p>这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。</p><p><em>3. 数字证书</em></p><p>前面我们知道：</p><ul><li>可以通过哈希算法来保证消息的完整性；</li><li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li></ul><p>但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p><p>还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。</p><p>但是我们还可以自己伪造出一对公私钥啊！</p><p>你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。</p><p>但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是你父亲写的请假条，又允许你请假了。</p><p>好家伙，为了一个请假，真的是斗智斗勇。</p><p>后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。</p><p>正所谓魔高一丈，道高一尺。</p><p>既然伪造公私钥那么随意，所以你爸把他的公钥注册到<strong>警察局</strong>，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个<strong>数字证书，也就是说这个数字证书包含你爸爸的公钥。</strong></p><p>这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。</p><p>老师拿到了数字证书后，<strong>首先会去警察局验证这个数字证书是否合法</strong>，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。</p><p><strong>由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的</strong>，于是老师就可以安心的用这个公钥解密出清教条，如果能解密出，就证明是你爸爸写的请假条。</p><p>正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。</p><p>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p>数字证书的工作流程，我也画了一张图，方便大家理解：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程"></p><p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p><h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS 是如何建立连接的？其间交互了什么？"></a>HTTPS 是如何建立连接的？其间交互了什么？</h3><p>SSL/TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p><p>SSL/TLS 的「握手阶段」涉及<strong>四次</strong>通信，&nbsp;<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247487650&amp;idx=1&amp;sn=dfee83f6773a589c775ccd6f40491289&amp;scene=21#wechat_redirect">基于 RSA 握手过程的 HTTPS&nbsp;(opens new window)</a>见下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程"></p><p>SSL/TLS 协议建立的详细流程：</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是&nbsp;<code>ClientHello</code>&nbsp;请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是&nbsp;<code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><em>3.客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><blockquote><p>客户端校验数字证书的流程是怎样的？</p></blockquote><p>接下来，详细说一下实际中数字证书签发和验证流程。</p><p>如下图图所示，为数字证书签发和验证流程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png"></p><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/baidu%E8%AF%81%E4%B9%A6.png"></p><p>对于这种三级层级关系的证书的验证过程如下：</p><ul><li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p></li><li><p>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</p></li><li><p>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</p></li></ul><p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</p><p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.png"></p><p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%B3%BB%E7%BB%9F%E6%A0%B9%E8%AF%81%E4%B9%A6.png"></p><p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png"></p><p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p><p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p><h3 id="HTTPS-的应用数据是如何保证完整性的？"><a href="#HTTPS-的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS 的应用数据是如何保证完整性的？"></a>HTTPS 的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png"></p><p>具体过程如下：</p><ul><li><p>首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。</p></li><li><p>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</p></li><li><p>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</p></li><li><p>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</p></li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><p>如果你想详细了解记录协议是如何分片、压缩、计算 MAC 值、分组加密，可以看这篇：<a href="https://blog.csdn.net/zhanyiwp/article/details/105627799">理解SSL/TLS系列 (四) 记录协议</a></p><h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>之前有读者在字节面试的时候，被问到：<strong>HTTPS 一定安全可靠吗？</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png"></p><p>具体过程如下：</p><ul><li>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</li><li>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</li><li>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</li><li>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</li></ul><p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p><p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。</p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA.png"></p><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。</p><p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><blockquote><p>为什么抓包工具能截取 HTTPS 数据？</p></blockquote><p>很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。</p><p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p><ol><li>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</li><li>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</li></ol><p>中间人要拿到私钥只能通过如下方式：</p><ol><li>去网站服务端拿到私钥；</li><li>去CA处拿域名签发私钥；</li><li>自己签发证书，切要被浏览器信任；</li></ol><p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p><p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p><p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p><blockquote><p>如何避免被中间人抓取数据？</p></blockquote><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p><p>当然，我们还可以通过&nbsp;<strong>HTTPS 双向认证</strong>来避免这种问题。</p><p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png"></p><p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><h2 id="HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3 演变"></a>HTTP/1.1、HTTP/2、HTTP/3 演变</h2><h3 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP/1.1 相比 HTTP/1.0 提高了什么性能？"></a>HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p><ul><li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP/1.1 还是有性能瓶颈：</p><ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩&nbsp;<code>Body</code>&nbsp;的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h3 id="HTTP-2-做了什么优化？"><a href="#HTTP-2-做了什么优化？" class="headerlink" title="HTTP/2 做了什么优化？"></a>HTTP/2 做了什么优化？</h3><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png" alt="HTT/1 ~ HTTP/2"></p><p>那 HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><p><em>1. 头部压缩</em></p><p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的&nbsp;<code>HPACK</code>&nbsp;算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p><em>2. 二进制格式</em></p><p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png" alt="HTTP/1 与 HTTP/2"></p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p>比如状态码 200 ，在 HTTP/1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/http1.png" alt="img"></p><p>在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP/1.1 节省了 2 个字节，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/h2c.png" alt="img"></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/h2c.png" alt="img"></p><p>Header: :status: 200 OK 的编码内容为：1000 1000，那么表达的含义是什么呢？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/index.png"></p><ol><li>最前面的 1 标识该 Header 是静态表中已经存在的 KV。（至于什么是静态表，可以看这篇：<a href="https://xiaolincoding.com/network/2_http/http2.html">HTTP/2 牛逼在哪？&nbsp;(opens new window)</a>）</li><li>在静态表理，“:status: 200 ok” 静态表编码是 8，二进制即是 1000。</li></ol><p>因此，整体加起来就是 1000 1000。</p><p><em>3. 并发传输</em></p><p>我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p><p>而 HTTP/2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png"></p><p>从上图可以看到，1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。</p><p><strong>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应</strong>。</p><p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg"></p><p><em>4、服务器推送</em></p><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID 是偶数（数字 2 和4）。</p><p><img src="https://img-blog.csdnimg.cn/83445581dafe409d8cfd2c573b2781ac.png"></p><p>再比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/push.png" alt="img"></p><p>如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><blockquote><p>HTTP/2 有什么缺陷？</p></blockquote><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2%E9%98%BB%E5%A1%9E.jpeg"></p><p>举个例子，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif" alt="img"></p><p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。</p><p>所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><h3 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP/3 做了哪些优化？"></a>HTTP/3 做了哪些优化？</h3><p>前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p><ul><li>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li></ul><p>HTTP/2 队头阻塞的问题是因为 TCP，所以&nbsp;<strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="HTTP/1 ~ HTTP/3"></p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的&nbsp;<strong>QUIC 协议</strong>&nbsp;可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有以下 3 个特点。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><p><em>1、无队头阻塞</em></p><p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg"></p><p><em>2、更快的连接建立</em></p><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS"></p><p>甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT（下图的右下角）：</p><p><img src="https://img-blog.csdnimg.cn/4cad213f5125432693e0e2a512c2d1a1.png"></p><p><em>3、连接迁移</em></p><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEwLmpwZw?x-oss-process=image/format,png" alt="TCP 四元组"></p><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong>&nbsp;TCP + TLS + HTTP/2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><p>HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</p><h2 id="读者问答-1"><a href="#读者问答-1" class="headerlink" title="读者问答"></a>读者问答</h2><blockquote><p>读者问：“https和http相比，就是传输的内容多了对称加密，可以这么理解吗？”</p></blockquote><ol><li><p>建立连接时候：https 比 http多了 TLS 的握手过程；</p></li><li><p>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</p></li></ol><blockquote><p>读者问：“ 我看文中 TLS 和 SSL 没有做区分，这两个需要区分吗？”</p></blockquote><p>这两实际上是一个东西。</p><p>SSL 是洋文 “<em>Secure Sockets Layer</em>&nbsp;的缩写，中文叫做「安全套接层」。它是在上世纪 90 年代中期，由网景公司设计的。</p><p>到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是 “<em>Transport Layer Security</em>” 的缩写），中文叫做 「传输层安全协议」。</p><p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p><blockquote><p>读者问：“为啥 ssl 的握手是 4 次？”</p></blockquote><p>SSL/TLS 1.2 需要 4 握手，需要 2 个 RTT 的时延，我文中的图是把每个交互分开画了，实际上把他们合在一起发送，就是 4 次握手：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/29-TLS1.2-%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>另外， SSL/TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只需要 3 次握手：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/30-TLS1.3.png" alt="T"></p><h1 id="3-2-HTTP-1-1如何优化？"><a href="#3-2-HTTP-1-1如何优化？" class="headerlink" title="3.2 HTTP/1.1如何优化？"></a>3.2 HTTP/1.1如何优化？</h1><p>问你一句：「<strong>你知道 HTTP/1.1 该如何优化吗？</strong>」</p><p>我们可以从下面这三种优化思路来优化 HTTP/1.1 协议：</p><ul><li><em>尽量避免发送 HTTP 请求</em>；</li><li><em>在需要发送 HTTP 请求时，考虑如何减少请求次数</em>；</li><li><em>减少服务器的 HTTP 响应的数据大小</em>；</li></ul><p>下面，就针对这三种思路具体看看有哪些优化方法。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96http1.1%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="如何避免发送-HTTP-请求？"><a href="#如何避免发送-HTTP-请求？" class="headerlink" title="如何避免发送 HTTP 请求？"></a>如何避免发送 HTTP 请求？</h2><p>这个思路你看到是不是觉得很奇怪，不发送 HTTP 请求，那客户端还怎么和服务器交互数据？小林你这不是耍流氓嘛？</p><p>冷静冷静，你说的没错，客户端当然要向服务器发送请求的。</p><p>但是，对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。</p><p>所以，避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p><p>那缓存是如何做到的呢？</p><p>客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。</p><p>这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本地磁盘的速度肯定比网络请求快得多，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE.png" alt="img"></p><p>聪明的你可能想到了，万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？</p><p>放心，这个问题 HTTP 设计者早已考虑到。</p><p>所以，服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。</p><p>如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是老样子，那么你觉得还要在服务器的响应带上这个资源吗？</p><p>很显然不带的话，可以提高 HTTP 协议的性能，那具体如何做到呢？</p><p>只需要客户端在重新发送请求时，在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。</p><p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。</p><p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器<strong>仅返回不含有包体的 <code>304 Not Modified</code> 响应</strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png" alt="img"></p><p>缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。</p><h2 id="如何减少-HTTP-请求次数？"><a href="#如何减少-HTTP-请求次数？" class="headerlink" title="如何减少 HTTP 请求次数？"></a>如何减少 HTTP 请求次数？</h2><p>减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：</p><ul><li><em>减少重定向请求次数</em>；</li><li><em>合并请求</em>；</li><li><em>延迟发送请求</em>；</li></ul><h3 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h3><p>我们先来看看什么是<strong>重定向请求</strong>？</p><p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 <code>302</code> 响应码和 <code>Location</code> 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。</p><p>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。</p><p>另外，服务端这一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img"></p><p>如果<strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="img"></p><p>而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.png" alt="img"></p><p>除了 <code>302</code> 重定向响应码，还有其他一些重定向的响应码，你可以从下图看到：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E9%87%8D%E5%AE%9A%E5%90%91%E5%93%8D%E5%BA%94%E7%A0%81.png" alt="img"></p><p>其中，<code>301</code> 和 <code>308</code> 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用 url2 替代 url1 访问服务器的资源。</p><h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着<strong>减少了重复发送的 HTTP 头部</strong>。</p><p>另外由于 HTTP/1.1 是请求响应模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防止单个请求的阻塞，所以一般浏览器会同时发起 5-6 个请求，每一个请求都是不同的 TCP 连接，那么如果合并了请求，也就会<strong>减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间</strong>。</p><p>接下来，具体看看合并请求的几种方式。</p><p>有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 <code>CSS Image Sprites</code> 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/css%E7%B2%BE%E7%81%B5.png" alt="图来源于：墨染枫林的CSDN"></p><p>这种方式就是<strong>通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销</strong>。</p><p>除了将小图片合并成大图片的方式，还有服务端使用 <code>webpack</code> 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。</p><p>另外，还可以将图片的二进制数据用 <code>base64</code> 编码后，以 URL 的形式嵌入到 HTML 文件，跟随 HTML 文件一并发送.</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&lt;image src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA ... /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图片，就不用再发起图片相关的请求，这样便减少了请求的次数。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/base64%E5%9B%BE%E7%89%87.png" alt="图来源于：陈健平的CSDN "></p><p>可以看到，<strong>合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求</strong>。</p><p>但是这样的合并请求会带来新的问题，<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗。</p><h3 id="延迟发送请求"><a href="#延迟发送请求" class="headerlink" title="延迟发送请求"></a>延迟发送请求</h3><p>不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「<strong>按需获取</strong>」的方式，来减少第一时间的 HTTP 请求次数。</p><p>请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h2 id="如何减少-HTTP-响应的数据大小？"><a href="#如何减少-HTTP-响应的数据大小？" class="headerlink" title="如何减少 HTTP 响应的数据大小？"></a>如何减少 HTTP 响应的数据大小？</h2><p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据大小会比较大，也就是服务器返回的资源会比较大。</p><p>于是，我们可以考虑对响应的资源进行<strong>压缩</strong>，这样就可以减少响应的数据大小，从而提高网络传输的效率。</p><p>压缩的方式一般分为 2 种，分别是：</p><ul><li><em>无损压缩</em>；</li><li><em>有损压缩</em>；</li></ul><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。</p><p>首先，我们针对代码的语法规则进行压缩，因为通常代码文件都有很多换行符或者空格，这些是为了帮助程序员更好的阅读，但是机器执行时并不要这些符，把这些多余的符号给去除掉。</p><p>接下来，就是无损压缩了，需要对原始资源建立统计模型，利用这个统计模型，将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示，生成二进制比特序列一般是「霍夫曼编码」算法。</p><p>gzip 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 <code>Accept-Encoding</code> 字段告诉服务器：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Accept-Encoding: gzip, deflate, br<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 <code>content-encoding</code> 字段告诉客户端该资源使用的压缩算法。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">content-encoding: gzip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>gzip 的压缩效率相比 Google 推出的 Brotli 算法还是差点意思，也就是上文中的 br，所以如果可以，服务器应该选择压缩效率更高的 br 压缩算法。</p><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近。</p><p>有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。</p><p>可以通过 HTTP 请求头部中的 <code>Accept</code> 字段里的「 q 质量因子」，告诉服务器期望的资源质量。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Accept: audio/*; q=0.2, audio/basic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于图片的压缩，目前压缩比较高的是 Google 推出的 <strong>WebP 格式</strong>，它与常见的 Png 格式图片的压缩比例对比如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/webp%E4%B8%8Epng.png" alt="来源于：https://isparta.github.io/compare-webp/index.html"></p><p>可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。</p><p>关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。</p><p>比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用<strong>增量数据</strong>来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这次主要从 3 个方面介绍了优化 HTTP/1.1 协议的思路。</p><p>第一个思路是，通过<strong>缓存技术</strong>来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。</p><p>第二个思路是，<strong>减少 HTTP 请求的次数</strong>，有以下的方法：</p><ol><li>将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；</li><li>将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；</li><li>按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。</li></ol><p>第三思路是，通过<strong>压缩响应资源</strong>，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。</p><p>不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议，后续我们再来介绍 HTTP/2 和 HTTP/3 协议。</p><h1 id="3-3-HTTPS-RSA-握手解析"><a href="#3-3-HTTPS-RSA-握手解析" class="headerlink" title="3.3 HTTPS RSA 握手解析"></a>3.3 HTTPS RSA 握手解析</h1><p>我前面讲，简单给大家介绍了的 HTTPS 握手过程，但是还不够细！</p><p>只讲了比较基础的部分，所以这次我们再来深入一下 HTTPS，用<strong>实战抓包</strong>的方式，带大家再来窥探一次 HTTPS。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https%E6%8F%90%E7%BA%B2.png" alt="img"></p><p>对于还不知道对称加密和非对称加密的同学，你先复习我以前的这篇文章<a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">「硬核！30 张图解 HTTP 常见的面试题」， (opens new window)</a>本篇文章默认大家已经具备了这些知识。</p><h2 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h2><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。</p><p>所以安全上存在以下三个风险：</p><ul><li><em>窃听风险</em>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><em>篡改风险</em>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><em>冒充风险</em>，比如冒充淘宝网站，用户钱容易没。</li></ul><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="img"></p><p>TLS 协议是如何解决 HTTP 的风险的呢？</p><ul><li><em>信息加密</em>： HTTP 交互信息是被加密的，第三方就无法被窃取；</li><li><em>校验机制</em>：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li><li><em>身份证书</em>：证明淘宝是真的淘宝网；</li></ul><p>可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E6%8F%A1%E6%89%8B.png" alt="img"></p><p>上图简要概述了 TLS 的握手过程，其中每一个「框」都是一个记录（<em>record</em>），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p><p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><p>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</p><p>接下来，我们就以最简单的 <code>RSA</code> 密钥交换算法，来看看它的 TLS 握手过程。</p><h2 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h2><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p><p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/tls%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="img"></p><p>对应 Wireshark 的抓包，我也画了一幅图，你可以从下图很清晰地看到该过程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/https_rsa.png" alt="img"></p><p>那么，接下来针对每一个 TLS 握手做进一步的介绍。</p><h3 id="TLS-第一次握手"><a href="#TLS-第一次握手" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h3><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/clienthello.png" alt="img"></p><p>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（*Client Random*）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p><h3 id="TLS-第二次握手"><a href="#TLS-第二次握手" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h3><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（*Server Random*）</strong>。</p><p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/serverhello.png" alt="img"></p><p>可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p><p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p><ul><li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li><li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li><li>摘要算法 SHA256 用于消息认证和产生随机数；</li></ul><p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。</p><p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</p><p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/certificate.png" alt="img"></p><p>随后，服务端发了「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/serverhellodone.png" alt="img"></p><h3 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h3><p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p><h4 id="数字证书和-CA-机构"><a href="#数字证书和-CA-机构" class="headerlink" title="数字证书和 CA 机构"></a>数字证书和 CA 机构</h4><p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p><ul><li>公钥；</li><li>持有者信息；</li><li>证书认证机构（CA）的信息；</li><li>CA 对这份文件的数字签名及使用的算法；</li><li>证书有效期；</li><li>还有一些其他额外信息；</li></ul><p>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</p><p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？</p><p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p><p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p><h4 id="数字证书签发和验证流程"><a href="#数字证书签发和验证流程" class="headerlink" title="数字证书签发和验证流程"></a>数字证书签发和验证流程</h4><p>如下图图所示，为数字证书签发和验证流程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" alt="img"></p><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/baidu%E8%AF%81%E4%B9%A6.png" alt="img"></p><p>对于这种三级层级关系的证书的验证过程如下：</p><ul><li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p></li><li><p>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</p></li><li><p>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</p></li></ul><p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</p><p>总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.png" alt="img"></p><p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%B3%BB%E7%BB%9F%E6%A0%B9%E8%AF%81%E4%B9%A6.png" alt="img"></p><p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png" alt="img"></p><p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p><p>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p><h3 id="TLS-第三次握手"><a href="#TLS-第三次握手" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h3><p>客户端验证完证书后，认为可信则继续往下走。</p><p>接着，客户端就会生成一个新的<strong>随机数 (*pre-master*)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Client Key Exchange</strong>」消息传给服务端。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/clietnkeyexchange.png" alt="img"></p><p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p><p>至此，<strong>客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong>。</p><p>于是，双方根据已经得到的三个随机数，生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。</p><p>生成完「会话密钥」后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/cipherspecmessage.png" alt="img"></p><p>然后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/encryptd.png" alt="img"></p><p>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p><h3 id="TLS-第四次握手"><a href="#TLS-第四次握手" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h3><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p><p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p><h2 id="RSA-算法的缺陷"><a href="#RSA-算法的缺陷" class="headerlink" title="RSA 算法的缺陷"></a>RSA 算法的缺陷</h2><p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。</p><p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p><p>为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓。</p><h1 id="3-4-HTTPS-ECDHE-握手解析"><a href="#3-4-HTTPS-ECDHE-握手解析" class="headerlink" title="3.4 HTTPS ECDHE 握手解析"></a>3.4 HTTPS ECDHE 握手解析</h1><p>HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。</p><p>其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。</p><p>我在上一篇已经介绍了 <a href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">RSA 握手的过程 (opens new window)</a>，今天这一篇就「从理论再到实战抓包」介绍 <strong>ECDHE 算法</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ecdhe%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><p>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。</p><p>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。</p><p>是不是听到这个数学概念就怂了？不怕，这次不会说离散对数推导的过程，只简单提一下它的数学公式。</p><p>离散对数是「离散 + 对数」的两个数学概念的组合，所以我们先来复习一遍对数。</p><p>要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。</p><p>举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下图所示：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0.png" alt="img"></p><p>那么对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6，计算过程如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E6%B1%82%E5%AF%B9%E6%95%B0.png" alt="img"></p><p>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，</p><p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。离散对数的概念如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" alt="img"></p><p>上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</p><p><strong>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</strong></p><h2 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h2><p>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。</p><p>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。</p><p>然后小红和小明各自生成一个随机整数作为<strong>私钥</strong>，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。</p><p>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出<strong>公钥</strong>：</p><ul><li>小红的公钥记作 A，A = G ^ a ( mod P )；</li><li>小明的公钥记作 B，B = G ^ b ( mod P )；</li></ul><p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。</p><p>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。</p><p>然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/dh%E7%AE%97%E6%B3%95.png" alt="img"></p><p>这个 K 就是小红和小明之间用的<strong>对称加密密钥</strong>，可以作为会话密钥使用。</p><p>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。</p><p>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。</p><h2 id="DHE-算法"><a href="#DHE-算法" class="headerlink" title="DHE 算法"></a>DHE 算法</h2><p>根据私钥生成的方式，DH 算法分为两种实现：</p><ul><li>static DH 算法，这个是已经被废弃了；</li><li>DHE 算法，现在常用的；</li></ul><p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。</p><p>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 <strong>static DH 算法不具备前向安全性</strong>。</p><p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。</p><p>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为<strong>每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」</strong>。</p><h2 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h2><p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。</p><p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p><p>小红和小明使用 ECDHE 密钥交换算法的过程：</p><ul><li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li><li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li><li>双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li></ul><p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p><h2 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h2><p>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。</p><p>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_tls%E6%8F%A1%E6%89%8B.png" alt="img"></p><p>细心的小伙伴应该发现了，<strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p><p>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p><p>接下来，分析每一个 ECDHE 握手过程。</p><h3 id="TLS-第一次握手-1"><a href="#TLS-第一次握手-1" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h3><p>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（*Client Random*）</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_clinethello.png" alt="img"></p><h3 id="TLS-第二次握手-1"><a href="#TLS-第二次握手-1" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h3><p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（*Server Random*）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_serverhello.png" alt="img"></p><p>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。</p><p>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p><ul><li>密钥协商算法使用 ECDHE；</li><li>签名算法使用 RSA；</li><li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li><li>摘要算法使用 SHA384；</li></ul><p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_certificate.png" alt="img"></p><p>这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_serverkey.png" alt="img"></p><p>这个过程服务器做了三件事：</p><ul><li>选择了<strong>名为 x25519 的椭圆曲线</strong>，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；</li><li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li><li>根据基点 G 和私钥计算出<strong>服务端的椭圆曲线公钥</strong>，这个会公开给客户端。</li></ul><p>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。</p><p>随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_serverhellodone.png" alt="img"></p><p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成会话密钥的材料。</p><h3 id="TLS-第三次握手-1"><a href="#TLS-第三次握手-1" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h3><p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。</p><p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成<strong>客户端的椭圆曲线公钥</strong>，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_clientkeyexchange.png" alt="img"></p><p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，<strong>但实际应用中，x 还不是最终的会话密钥</strong>。</p><p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？</p><p><strong>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。</p><p>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。</p><p>算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_schangecipherspec.png" alt="img"></p><p>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/ech_encryptedhandshakemessage.png" alt="img"></p><h3 id="TLS-第四次握手-1"><a href="#TLS-第四次握手-1" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h3><p>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>RSA 和 ECDHE 握手过程的区别：</p><ul><li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li><li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li><li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li></ul><h1 id="3-5-HTTPS-如何优化？"><a href="#3-5-HTTPS-如何优化？" class="headerlink" title="3.5 HTTPS 如何优化？"></a>3.5 HTTPS 如何优化？</h1><p>由裸数据传输的 HTTP 协议转成加密数据传输的 HTTPS 协议，给应用数据套了个「保护伞」，提高安全性的同时也带来了性能消耗。</p><p>因为 HTTPS 相比 HTTP 协议多一个 TLS 协议握手过程，<strong>目的是为了通过非对称加密握手协商或者交换出对称加密密钥</strong>，这个过程最长可以花费掉 2 RTT，接着后续传输的应用数据都得使用对称加密密钥来加密/解密。</p><p>为了数据的安全性，我们不得不使用 HTTPS 协议，至今大部分网址都已从 HTTP 迁移至 HTTPS 协议，因此针对 HTTPS 的优化是非常重要的。</p><p>这次，就从多个角度来优化 HTTPS。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96https%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="分析性能损耗"><a href="#分析性能损耗" class="headerlink" title="分析性能损耗"></a>分析性能损耗</h2><p>既然要对 HTTPS 优化，那得清楚哪些步骤会产生性能消耗，再对症下药。</p><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><p>对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。</p><p>而第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗，比如：</p><ul><li>对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥；</li><li>客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销；</li><li>双方计算 Pre-Master，也就是对称加密密钥；</li></ul><p>为了大家更清楚这些步骤在 TLS 协议握手的哪一个阶段，我画出了这幅图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97.png" alt="img"></p><h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><p>玩游戏时，如果我们怎么都战胜不了对方，那么有一个最有效、最快的方式来变强，那就是「充钱」，如果还是不行，那说明你充的钱还不够多。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/%E5%85%85%E9%92%B1.jpg" alt="img"></p><p>对于计算机里也是一样，软件都是跑在物理硬件上，硬件越牛逼，软件跑的也越快，所以如果要优化 HTTPS 优化，最直接的方式就是花钱买性能参数更牛逼的硬件。</p><p>但是花钱也要花对方向，<strong>HTTPS 协议是计算密集型，而不是 I/O 密集型</strong>，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上。</p><p>一个好的 CPU，可以提高计算性能，因为 HTTPS 连接过程中就有大量需要计算密钥的过程，所以这样可以加速 TLS 握手过程。</p><p>另外，如果可以，应该选择可以<strong>支持 AES-NI 特性的 CPU</strong>，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。</p><p>如果你的服务器是 Linux 系统，那么你可以使用下面这行命令查看 CPU 是否支持 AES-NI 指令集：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/aesni_intel.png" alt="img"></p><p>如果我们的 CPU 支持 AES-NI 特性，那么对于对称加密的算法应该选择 AES 算法。否则可以选择 ChaCha20 对称加密算法，因为 ChaCha20 算法的运算指令相比 AES 算法会对 CPU 更友好一点。</p><h2 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h2><p>如果公司预算充足对于新的服务器是可以考虑购买更好的 CPU，但是对于已经在使用的服务器，硬件优化的方式可能就不太适合了，于是就要从软件的方向来优化了。</p><p>软件的优化方向可以分层两种，一个是<strong>软件升级</strong>，一个是<strong>协议优化</strong>。</p><p>先说第一个软件升级，软件升级就是将正在使用的软件升级到最新版本，因为最新版本不仅提供了最新的特性，也优化了以前软件的问题或性能。比如：</p><ul><li>将 Linux 内核从 2.x 升级到 4.x；</li><li>将 OpenSSL 从 1.0.1 升级到 1.1.1；</li><li>…</li></ul><p>看似简单的软件升级，对于有成百上千服务器的公司来说，软件升级也跟硬件升级同样是一个棘手的问题，因为要实行软件升级，会花费时间和人力，同时也存在一定的风险，也可能会影响正常的线上服务。</p><p>既然如此，我们把目光放到协议优化，也就是在现有的环节下，通过较小的改动，来进行优化。</p><h2 id="协议优化"><a href="#协议优化" class="headerlink" title="协议优化"></a>协议优化</h2><p>协议的优化就是对「密钥交换过程」进行优化。</p><h3 id="密钥交换算法优化"><a href="#密钥交换算法优化" class="headerlink" title="密钥交换算法优化"></a>密钥交换算法优化</h3><p>TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。</p><p>总之使用 <strong>RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高</strong>。</p><p>因此如果可以，尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong>。</p><p>ECDHE 算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不同，应该尽量<strong>选择 x25519 曲线</strong>，该曲线是目前最快的椭圆曲线。</p><p>比如在 Nginx 上，可以使用 ssl_ecdh_curve 指令配置想使用的椭圆曲线，把优先使用的放在前面：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/ssl_ecdh_curve.png" alt="img"></p><p>对于对称加密算法方面，如果对安全性不是特别高的要求，可以<strong>选用 AES_128_GCM</strong>，它比 AES_256_GCM 快一些，因为密钥的长度短一些。</p><p>比如在 Nginx 上，可以使用 ssl_ciphers 指令配置想使用的非对称加密算法和对称加密算法，也就是密钥套件，而且把性能最快最安全的算法放在最前面：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/ssl_ciphers.png" alt="img"></p><h3 id="TLS-升级"><a href="#TLS-升级" class="headerlink" title="TLS 升级"></a>TLS 升级</h3><p>当然，如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，<strong>完成 TLS 握手只要 1 RTT</strong>，而且安全性更高。</p><p>在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/tls1.2and1.3.png" alt="img"></p><p>上图的右边部分就是 TLS 1.3 的握手过程，可以发现 <strong>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p><p>怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p><p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p><p>而且，TLS1.3 对密码套件进行“减肥”了， <strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</p><p>对于对称加密和签名算法，只支持目前最安全的几个密码套件，比如 openssl 中仅支持下面 5 种密码套件：</p><ul><li>TLS_AES_256_GCM_SHA384</li><li>TLS_CHACHA20_POLY1305_SHA256</li><li>TLS_AES_128_GCM_SHA256</li><li>TLS_AES_128_CCM_8_SHA256</li><li>TLS_AES_128_CCM_SHA256</li></ul><p>之所以 TLS1.3 仅支持这么少的密码套件，是因为 TLS1.2 由于支持各种古老且不安全的密码套件，中间人可以利用降级攻击，伪造客户端的 Client Hello 消息，替换客户端支持的密码套件为一些不安全的密码套件，使得服务器被迫使用这个密码套件进行 HTTPS 连接，从而破解密文。</p><h2 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h2><p>为了验证的服务器的身份，服务器会在 TLS 握手过程中，把自己的证书发给客户端，以此证明自己身份是可信的。</p><p>对于证书的优化，可以有两个方向：</p><ul><li>一个是<strong>证书传输</strong>，</li><li>一个是<strong>证书验证</strong>；</li></ul><h3 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h3><p>要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，<strong>对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多</strong>。</p><h3 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h3><p>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。</p><p>这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。</p><h4 id="CRL"><a href="#CRL" class="headerlink" title="CRL"></a>CRL</h4><p>CRL 称为证书吊销列表（<em>Certificate Revocation List</em>），这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/crl.png" alt="img"></p><p>但是 CRL 存在两个问题：</p><ul><li>第一个问题，由于 CRL 列表是由 CA 维护的，定期更新，如果一个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书，<strong>实时性较差</strong>；</li><li>第二个问题，<strong>随着吊销证书的增多，列表会越来越大，下载的速度就会越慢</strong>，下载完客户端还得遍历这么大的列表，那么就会导致客户端在校验证书这一环节的延时很大，进而拖慢了 HTTPS 连接。</li></ul><h4 id="OCSP"><a href="#OCSP" class="headerlink" title="OCSP"></a>OCSP</h4><p>因此，现在基本都是使用 OCSP ，名为在线证书状态协议（<em>Online Certificate Status Protocol</em>）来查询证书的有效性，它的工作方式是<strong>向 CA 发送查询请求，让 CA 返回证书的有效状态</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/ocsp.png" alt="img"></p><p>不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。</p><p>OCSP 需要向 CA 查询，因此也是要发生网络请求，而且还得看 CA 服务器的“脸色”，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大。</p><h4 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h4><p>于是为了解决这一个网络开销，就出现了 OCSP Stapling，其原理是：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/opscp-stapling.png" alt="img"></p><p>当有客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。</p><h2 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h2><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？</p><p>这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p><ul><li>第一种叫 Session ID；</li><li>第二种叫 Session Ticket；</li></ul><h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。</p><p>当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/sessionid.png" alt="img"></p><p>但是它有两个缺点：</p><ul><li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li><li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li></ul><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>为了解决 Session ID 的问题，就出现了 Session Ticket，<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。</p><p>客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。</p><p>客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/ticket.png" alt="img"></p><p>对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p><p>Session ID 和 Session Ticket <strong>都不具备前向安全性</strong>，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。</p><p>同时应对<strong>重放攻击</strong>也很困难，这里简单介绍下重放攻击工作的原理。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB.png" alt="img"></p><p>假设 Alice 想向 Bob 证明自己的身份。 Bob 要求 Alice 的密码作为身份证明，爱丽丝应尽全力提供（可能是在经过如哈希函数的转换之后）。与此同时，Eve 窃听了对话并保留了密码（或哈希）。</p><p>交换结束后，Eve（冒充 Alice ）连接到 Bob。当被要求提供身份证明时，Eve 发送从 Bob 接受的最后一个会话中读取的 Alice 的密码（或哈希），从而授予 Eve 访问权限。</p><p>重放攻击的危险之处在于，如果中间人截获了某个客户端的 Session ID 或 Session Ticket 以及 POST 报文，而一般 POST 请求会改变数据库的数据，中间人就可以利用此截获的报文，不断向服务器发送该报文，这样就会导致数据库的数据被中间人改变了，而客户是不知情的。</p><p>避免重放攻击的方式就是需要<strong>对会话密钥设定一个合理的过期时间</strong>。</p><h3 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h3><p>前面的 Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。</p><p>而 TLS1.3 更为牛逼，对于重连 TLS1.3 只需要 <strong>0 RTT</strong>，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 <strong>Pre-shared Key</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/0-RTT.png" alt="img"></p><p>同样的，Pre-shared Key 也有重放攻击的危险。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https%E4%BC%98%E5%8C%96/0-rtt-attack.png" alt="img"></p><p>如上图，假设中间人通过某种方式，截获了客户端使用会话重用技术的 POST 请求，通常 POST 请求是会改变数据库的数据，然后中间人就可以把截获的这个报文发送给服务器，服务器收到后，也认为是合法的，于是就恢复会话，致使数据库的数据又被更改，但是此时用户是不知情的。</p><p>所以，应对重放攻击可以给会话密钥设定一个合理的过期时间，以及只针对安全的 HTTP 请求如 GET/HEAD 使用会话重用。</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>对于硬件优化的方向，因为 HTTPS 是属于计算密集型，应该选择计算力更强的 CPU，而且最好选择<strong>支持 AES-NI 特性的 CPU</strong>，这个特性可以在硬件级别优化 AES 对称加密算法，加快应用数据的加解密。</p><p>对于软件优化的方向，如果可以，把软件升级成较新的版本，比如将 Linux 内核 2.X 升级成 4.X，将 openssl 1.0.1 升级到 1.1.1，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。</p><p>对于协议优化的方向：</p><ul><li>密钥交换算法应该选择 <strong>ECDHE 算法</strong>，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。</li><li>将 TLS1.2 升级 <strong>TLS1.3</strong>，因为 TLS1.3 的握手过程只需要 1 RTT，而且安全性更强。</li></ul><p>对于证书优化的方向：</p><ul><li>服务器应该选用 <strong>ECDSA 证书</strong>，而非 RSA 证书，因为在相同安全级别下，ECC 的密钥长度比 RSA 短很多，这样可以提高证书传输的效率；</li><li>服务器应该开启 <strong>OCSP Stapling</strong> 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；</li></ul><p>对于重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥，直接恢复会话，而不用再重新走完整的 TLS 握手过程。</p><p>常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。</p><p>这些会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全，而且有重放攻击的风险，所以应当对会话密钥设定一个合理的过期时间。</p><h1 id="3-6-HTTP-2-牛逼在哪？"><a href="#3-6-HTTP-2-牛逼在哪？" class="headerlink" title="3.6 HTTP/2 牛逼在哪？"></a>3.6 HTTP/2 牛逼在哪？</h1><p><strong>一起来看看 HTTP/2 牛逼在哪？</strong></p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/http2%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="HTTP-1-1-协议的性能问题"><a href="#HTTP-1-1-协议的性能问题" class="headerlink" title="HTTP/1.1 协议的性能问题"></a>HTTP/1.1 协议的性能问题</h2><p>我们得先要了解下 HTTP/1.1 协议存在的性能问题，因为 HTTP/2 协议就是把这些性能问题逐个攻破了。</p><p>现在的站点相比以前变化太多了，比如：</p><ul><li><em>消息的大小变大了</em>，从几 KB 大小的消息，到几 MB 大小的消息；</li><li><em>页面资源变多了</em>，从每个页面不到 10 个的资源，到每页超 100 多个资源；</li><li><em>内容形式变多样了</em>，从单纯到文本内容，到图片、视频、音频等内容；</li><li><em>实时性要求变高了</em>，对页面的实时性要求的应用越来越多；这些变化带来的最大性能问题就是 <strong>HTTP/1.1 的高延迟</strong>，延迟高必然影响的就是用户体验。主要原因如下几个：</li></ul><p>这些变化带来的最大性能问题就是 <strong>HTTP/1.1 的高延迟</strong>，延迟高必然影响的就是用户体验。主要原因如下几个：</p><ul><li><em>延迟难以下降</em>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li><li><em>并发连接有限</em>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li><li><em>队头阻塞问题</em>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li><li><em>HTTP 头部巨大且重复</em>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 cookie 的头部，而 cookie 的大小通常很大；</li><li><em>不支持服务器推送消息</em>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li></ul><p>为了解决 HTTP/1.1 性能问题，具体的优化手段你可以看这篇文章「<a href="https://xiaolincoding.com/network/2_http/http_optimize.html">HTTP/1.1如何优化？ (opens new window)</a>」，这里我举例几个常见的优化手段：</p><ul><li>将多张小图合并成一张大图供浏览器 JavaScript 来切割使用，这样可以将多个请求合并成一个请求，但是带来了新的问题，当某张小图片更新了，那么需要重新请求大图片，浪费了大量的网络带宽；</li><li>将图片的二进制数据通过 base64 编码后，把编码数据嵌入到 HTML 或 CSS 文件中，以此来减少网络请求次数；</li><li>将多个体积较小的 JavaScript 文件使用 webpack 等工具打包成一个体积更大的 JavaScript 文件，以一个请求替代了很多个请求，但是带来的问题，当某个 js 文件变化了，需要重新请求同一个包里的所有 js 文件；</li><li>将同一个页面的资源分散到不同域名，提升并发连接上限，因为浏览器通常对同一域名的 HTTP 连接最大只能是 6 个；</li></ul><p>尽管对 HTTP/1.1 协议的优化手段如此之多，但是效果还是不尽人意，因为这些手段都是对 HTTP/1.1 协议的“外部”做优化，<strong>而一些关键的地方是没办法优化的，比如请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等，要改变这些必须重新设计 HTTP 协议，于是 HTTP/2 就出来了！</strong></p><h2 id="兼容-HTTP-1-1"><a href="#兼容-HTTP-1-1" class="headerlink" title="兼容 HTTP/1.1"></a>兼容 HTTP/1.1</h2><p>HTTP/2 出来的目的是为了改善 HTTP 的性能。协议升级有一个很重要的地方，就是要<strong>兼容</strong>老版本的协议，否则新协议推广起来就相当困难，所幸 HTTP/2 做到了兼容 HTTP/1.1 。</p><p>那么，HTTP/2 是怎么做的呢？</p><p>第一点，HTTP/2 没有在 URI 里引入新的协议名，仍然用「http://」表示明文协议，用「https://」表示加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好的实现了协议的平滑升级。</p><p>第二点，只在应用层做了改变，还是基于 TCP 协议传输，应用层方面为了保持功能上的兼容，HTTP/2 把 HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。</p><p>但是，HTTP/2 在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>HTTP 协议的报文是由「Header + Body」构成的，对于 Body 部分，HTTP/1.1 协议可以使用头字段 「Content-Encoding」指定 Body 的压缩方式，比如用 gzip 压缩，这样可以节约带宽，但报文中的另外一部分 Header，是没有针对它的优化手段。</p><p>HTTP/1.1 报文中 Header 部分存在的问题：</p><ul><li>含很多固定的字段，比如Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要<strong>压缩</strong>；</li><li>大量的请求和响应的报文里有很多字段值都是重复的，这样会使得大量带宽被这些冗余的数据占用了，所以有必须要<strong>避免重复性</strong>；</li><li>字段是 ASCII 编码的，虽然易于人类观察，但效率低，所以有必要改成<strong>二进制编码</strong>；</li></ul><p>HTTP/2 对 Header 部分做了大改造，把以上的问题都解决了。</p><p>HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法，HPACK 算法主要包含三个组成部分：</p><ul><li>静态字典；</li><li>动态字典；</li><li>Huffman 编码（压缩算法）；</li></ul><p>客户端和服务器两端都会建立和维护「<strong>字典</strong>」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong>。</p><h3 id="静态表编码"><a href="#静态表编码" class="headerlink" title="静态表编码"></a>静态表编码</h3><p>HTTP/2 为高频出现在头部的字符串和字段建立了一张<strong>静态表</strong>，它是写入到 HTTP/2 框架里的，不会变化的，静态表里共有 <code>61</code> 组，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E8%A1%A8.png" alt="img"></p><p>表中的 <code>Index</code> 表示索引（Key），<code>Header Value</code> 表示索引对应的 Value，<code>Header Name</code> 表示字段的名字，比如 Index 为 2 代表 GET，Index 为 8 代表状态码 200。</p><p>你可能注意到，表中有的 Index 没有对应的 Header Value，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。</p><p>这么说有点抽象，我们来看个具体的例子，下面这个 <code>server</code> 头部字段，在 HTTP/1.1 的形式如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">server: nghttpx\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>算上冒号空格和末尾的\r\n，共占用了 17 字节，**而使用了静态表和 Huffman 编码，可以将它压缩成 8 字节，压缩率大概 47 %**。</p><p>我抓了个 HTTP/2 协议的网络包，你可以从下图看到，高亮部分就是 <code>server</code> 头部字段，只用了 8 个字节来表示 <code>server</code> 头部数据。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E7%BC%96%E7%A0%81.png" alt="img"></p><p>根据 RFC7541 规范，如果头部字段属于静态表范围，并且 Value 是变化，那么它的 HTTP/2 头部前 2 位固定为 <code>01</code>，所以整个头部格式如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A8.png" alt="img"></p><p>HTTP/2 头部由于基于<strong>二进制编码</strong>，就不需要冒号空格和末尾的\r\n作为分隔符，于是改用表示字符串长度（Value Length）来分割 Index 和 Value。</p><p>接下来，根据这个头部格式来分析上面抓包的 <code>server</code> 头部的二进制数据。</p><p>首先，从静态表中能查到 <code>server</code> 头部字段的 Index 为 54，二进制为 110110，再加上固定 01，头部格式第 1 个字节就是 <code>01110110</code>，这正是上面抓包标注的红色部分的二进制数据。</p><p>然后，第二个字节的首个比特位表示 Value 是否经过 Huffman 编码，剩余的 7 位表示 Value 的长度，比如这次例子的第二个字节为 <code>10000110</code>，首位比特位为 1 就代表 Value 字符串是经过 Huffman 编码的，经过 Huffman 编码的 Value 长度为 6。</p><p>最后，字符串 <code>nghttpx</code> 经过 Huffman 编码后压缩成了 6 个字节，Huffman 编码的原理是将高频出现的信息用「较短」的编码表示，从而缩减字符串长度。</p><p>于是，在统计大量的 HTTP 头部后，HTTP/2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，可以在 RFC7541 文档找到这张<strong>静态 Huffman 表</strong>，我就不把表的全部内容列出来了，我只列出字符串 <code>nghttpx</code> 中每个字符对应的 Huffman 编码，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/nghttpx.png" alt="img"></p><p>通过查表后，字符串 <code>nghttpx</code> 的 Huffman 编码在下图看到，共 6 个字节，每一个字符的 Huffman 编码，我用相同的颜色将他们对应起来了，最后的 7 位是补位的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/nghttpx2.png" alt="img"></p><p>最终，<code>server</code> 头部的二进制数据对应的静态头部格式如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A82.png" alt="img"></p><h3 id="动态表编码"><a href="#动态表编码" class="headerlink" title="动态表编码"></a>动态表编码</h3><p>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，它的 Index 从 <code>62</code> 起步，会在编码解码的时候随时更新。</p><p>比如，第一次发送时头部中的「<code>user-agent</code> 」字段数据有上百个字节，经过 Huffman 编码发送出去后，客户端和服务器双方都会更新自己的动态表，添加一个新的 Index 号 62。<strong>那么在下一次发送的时候，就不用重复发这个字段的数据了，只用发 1 个字节的 Index 号就好了，因为双方都可以根据自己的动态表获取到字段的数据</strong>。</p><p>所以，使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。</p><p>因此，随着在同一 HTTP/2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。</p><p>理想很美好，现实很骨感。动态表越大，占用的内存也就越大，如果占用了太多内存，是会影响服务器性能的，因此 Web 服务器都会提供类似 <code>http2_max_requests</code> 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP/2 连接来释放内存。</p><p>综上，HTTP/2 头部的编码通过「静态表、动态表、Huffman 编码」共同完成的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%A4%B4%E9%83%A8%E7%BC%96%E7%A0%81.png" alt="img"></p><h2 id="二进制帧"><a href="#二进制帧" class="headerlink" title="二进制帧"></a>二进制帧</h2><p>HTTP/2 厉害的地方在于将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。</p><p>你可以从下图看到，HTTP/1.1 的响应 和 HTTP/2 的区别：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png" alt="img"></p><p>HTTP/2 把响应报文划分成了两类<strong>帧（*Frame*）</strong>，图中的 HEADERS（首部）和 DATA（消息负载） 是帧的类型，也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。</p><p>比如状态码 200 ，在 HTTP/1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/http1.png" alt="img"></p><p>在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP/1.1 节省了 2 个字节，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/h2c.png" alt="img"></p><p>Header: :status: 200 OK 的编码内容为：1000 1000，那么表达的含义是什么呢？</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/index.png" alt="img"></p><ol><li>最前面的 1 标识该 Header 是静态表中已经存在的 KV。</li><li>我们再回顾一下之前的静态表内容，“:status: 200 ok”其静态表编码是8，即1000。</li></ol><p>因此，整体加起来就是 1000 1000。</p><p>HTTP/2 <strong>二进制帧</strong>的结构如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="img"></p><p>帧头（Frame Header）很小，只有 9 个字节，帧开头的前 3 个字节表示帧数据（Frame Playload）的<strong>长度</strong>。</p><p>帧长度后面的一个字节是表示<strong>帧的类型</strong>，HTTP/2 总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类，如下表格：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E7%B1%BB%E5%9E%8B.png" alt="img"></p><p>帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息，比如：</p><ul><li><strong>END_HEADERS</strong> 表示头数据结束标志，相当于 HTTP/1 里头后的空行（“\r\n”）；</li><li><strong>END_Stream</strong> 表示单方向数据发送结束，后续不会再有数据帧。</li><li><strong>PRIORITY</strong> 表示流的优先级；</li></ul><p>帧头的最后 4 个字节是<strong>流标识符</strong>（Stream ID），但最高位被保留不用，只有 31 位可以使用，因此流标识符的最大值是 2^31，大约是 21 亿，它的作用是用来标识该 Frame 属于哪个 Stream，接收方可以根据这个信息从乱序的帧里找到相同 Stream ID 的帧，从而有序组装信息。</p><p>最后面就是<strong>帧数据</strong>了，它存放的是通过 <strong>HPACK 算法</strong>压缩过的 HTTP 头部和包体。</p><h2 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h2><p>知道了 HTTP/2 的帧结构后，我们再来看看它是如何实现<strong>并发传输</strong>的。</p><p>我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p><p>而 HTTP/2 就很牛逼了，通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。</p><p>为了理解 HTTP/2 的并发是怎样实现的，我们先来理解 HTTP/2 中的 Stream、Message、Frame 这 3 个概念。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" alt="img"></p><p>你可以从上图中看到：</p><ul><li>1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</li><li>Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</li><li>Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</li></ul><p>因此，我们可以得出个结论：多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream2.png" alt="img"></p><p>在 HTTP/2 连接上，<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p><p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg" alt="img"></p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>，因为服务端可以主动推送资源给客户端， 客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>比如下图，Stream 1 是客户端向服务端请求的资源，属于客户端建立的 Stream，所以该 Stream 的 ID 是奇数（数字1）；Stream 2 和 4 都是服务端主动向客户端推送的资源，属于服务端建立的 Stream，所以这两个 Stream 的 ID 是偶数（数字 2 和4）。</p><p><img src="https://img-blog.csdnimg.cn/83445581dafe409d8cfd2c573b2781ac.png" alt="img"></p><p>同一个连接中的 Stream ID 是不能复用的，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 <code>GOAWAY</code>，用来关闭 TCP 连接。</p><p>在 Nginx 中，可以通过 <code>http2_max_concurrent_Streams</code> 配置来设置 Stream 的上限，默认是 128 个。</p><p>HTTP/2 通过 Stream 实现的并发，比 HTTP/1.1 通过 TCP 连接实现并发要牛逼的多，<strong>因为当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。</strong></p><p>HTTP/2 还可以对每个 Stream 设置不同<strong>优先级</strong>，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。</p><h2 id="服务器主动推送资源"><a href="#服务器主动推送资源" class="headerlink" title="服务器主动推送资源"></a>服务器主动推送资源</h2><p>HTTP/1.1 不支持服务器主动推送资源给客户端，都是由客户端向服务器发起请求后，才能获取到服务器响应的资源。</p><p>比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/push.png" alt="img"></p><p>如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><p>在 Nginx 中，如果你希望客户端访问 /test.html 时，服务器直接推送 /test.css，那么可以这么配置：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">location</span> /test.html</span> <span class="token punctuation">{</span>   <span class="token directive"><span class="token keyword">http2_push</span> /test.css</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那 HTTP/2 的推送是怎么实现的？</p><p>客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/push2.png" alt="img"></p><p>如上图，在 Stream 1 中通知客户端 CSS 资源即将到来，然后在 Stream 2 中发送 CSS 资源，注意 Stream 1 和 2 是可以<strong>并发</strong>的。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>HTTP/2 协议其实还有很多内容，比如流控制、流状态、依赖关系等等。</p><p>这次主要介绍了关于 HTTP/2 是如何提升性能的几个方向，它相比 HTTP/1 大大提高了传输效率、吞吐能力。</p><p>第一点，对于常见的 HTTP 头部通过<strong>静态表和 Huffman 编码</strong>的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立<strong>动态表</strong>，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。</p><p>不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP/2 连接时长或者请求次数。</p><p>第二点，<strong>HTTP/2 实现了 Stream 并发</strong>，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 可以并发，即使乱序发送帧也没问题，比如发送 A 请求帧1-&gt; B 请求帧1-&gt; A 请求帧2 -&gt; B 请求帧2，但是同一个 Stream 里的帧必须严格有序。</p><p>另外，可以根据资源的渲染顺序来设置 Stream 的<strong>优先级</strong>，从而提高用户体验。</p><p>第三点，<strong>服务器支持主动推送资源</strong>，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。</p><p>HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p><p>有没有什么解决方案呢？既然是 TCP 协议自身的问题，那干脆放弃 TCP 协议，转而使用 UDP 协议作为传输层协议，这个大胆的决定， HTTP/3 协议做了！</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="img"></p><h1 id="3-7-HTTP-3-强势来袭"><a href="#3-7-HTTP-3-强势来袭" class="headerlink" title="3.7 HTTP/3 强势来袭"></a>3.7 HTTP/3 强势来袭</h1><p>HTTP/3 现在还没正式推出，不过自 2017 年起， HTTP/3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。</p><p>所以，这次 HTTP/3 介绍不会涉及到包格式，只说它的特性。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/HTTP3%E6%8F%90%E7%BA%B2.png" alt="img"></p><h2 id="美中不足的-HTTP-2"><a href="#美中不足的-HTTP-2" class="headerlink" title="美中不足的 HTTP/2"></a>美中不足的 HTTP/2</h2><p>HTTP/2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP/1.1 的性能，而美中不足的是 HTTP/2 协议是基于 TCP 实现的，于是存在的缺陷有三个。</p><ul><li>队头阻塞；</li><li>TCP 与 TLS 的握手时延迟；</li><li>网络迁移需要重新连接；</li></ul><h3 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h3><p>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</p><p>比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 和 Stream 4 请求。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p><p>因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</p><p>举个例子，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif" alt="img"></p><p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。</p><h3 id="TCP-与-TLS-的握手时延迟"><a href="#TCP-与-TLS-的握手时延迟" class="headerlink" title="TCP 与 TLS 的握手时延迟"></a>TCP 与 TLS 的握手时延迟</h3><p>发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/TCP%2BTLS.gif" alt="img"></p><p>另外， TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生”减速”效果。</p><h3 id="网络迁移需要重新连接"><a href="#网络迁移需要重新连接" class="headerlink" title="网络迁移需要重新连接"></a>网络迁移需要重新连接</h3><p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</p><p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP/2 在怎么设计都无法逃脱。要解决这个问题，就必须把<strong>传输层协议替换成 UDP</strong>，这个大胆的决定，HTTP/3 做了！</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="HTTP/1 ~ HTTP/3"></p><h2 id="QUIC-协议的特点"><a href="#QUIC-协议的特点" class="headerlink" title="QUIC 协议的特点"></a>QUIC 协议的特点</h2><p>我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。</p><p>而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。</p><p>当然，HTTP/3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 <strong>QUIC 协议</strong>，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p><p>QUIC 协议的优点有很多，这里举例几个，比如：</p><ul><li>无队头阻塞；</li><li>更快的连接建立；</li><li>连接迁移；</li></ul><h3 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h3><p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</p><p>不过 QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。</p><p>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p><h3 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h3><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</p><p>如下图右边部分，HTTP/3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/0-rtt.gif" alt="img"></p><h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>在前面我们提到，基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzEwLmpwZw?x-oss-process=image/format,png" alt="TCP 四元组"></p><p>那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><h2 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h2><p>了解完 QUIC 协议的特点后，我们再来看看 HTTP/3 协议在 HTTP 这一层做了什么变化。</p><p>HTTP/3 同 HTTP/2 一样采用二进制帧的结构，不同的地方在于 HTTP/2 的二进制帧里需要定义 Stream，而 HTTP/3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP/3 的帧的结构也变简单了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http3/http3frame.png" alt="img"></p><p>从上图可以看到，HTTP/3 帧头只有两个字段：类型和长度。</p><p>根据帧类型的不同，大体上分为数据帧和控制帧两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p><p>HTTP/3 在头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP/2 中的 HPACK 编码方式相似，HTTP/3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。</p><p>对于静态表的变化，HTTP/2 中的 HPACK 的静态表只有 61 项，而 HTTP/3 中的 QPACK 的静态表扩大到 91 项。</p><p>HTTP/2 和 HTTP/3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</p><p>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</p><p>可以看到，<strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong>。</p><p>HTTP/3 的 QPACK 解决了这一问题，那它是如何解决的呢？</p><p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p><ul><li>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>HTTP/2 虽然具有多个流并发传输的能力，但是传输层是 TCP 协议，于是存在以下缺陷：</p><ul><li><strong>队头阻塞</strong>，HTTP/2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；</li><li><strong>TCP 和 TLS 握手时延</strong>，TCL 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li><li><strong>连接迁移需要重新连接</strong>，移动设备从 4G 网络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li></ul><p>HTTP/3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。</p><p>QUIC 协议的特点：</p><ul><li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；</li><li><strong>建立连接速度快</strong>，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li><li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li></ul><p>另外 HTTP/3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP/2 的 HPACK 队头阻塞问题。</p><p><strong>期待，HTTP/3 正式推出的那一天！</strong></p><h1 id="3-8-既然有-HTTP-协议，为什么还要有-RPC？"><a href="#3-8-既然有-HTTP-协议，为什么还要有-RPC？" class="headerlink" title="3.8 既然有 HTTP 协议，为什么还要有 RPC？"></a>3.8 既然有 HTTP 协议，为什么还要有 RPC？</h1><p>我想起了我刚工作的时候，第一次接触RPC协议，当时就很懵，<strong>我HTTP协议用的好好的，为什么还要用RPC协议？</strong></p><p>于是就到网上去搜。</p><p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p><p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p><p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p><h2 id="从-TCP-聊起"><a href="#从-TCP-聊起" class="headerlink" title="从 TCP 聊起"></a>从 TCP 聊起</h2><p>作为一个程序员，假设我们需要在A电脑的进程发一段数据到B电脑的进程，我们一般会在代码里使用socket 进行编程。</p><p>这时候，我们可选项一般也就TCP和UDP二选一。TCP可靠，UDP不可靠。除非是马总这种神级程序员（早期QQ大量使用UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选TCP就对了。</p><p>类似下面这样。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span>SOCK_STREAM<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP协议</strong>。</p><p>在定义了socket之后，我们就可以愉快的对这个socket进行操作，比如用<code>bind()</code>绑定IP端口，用<code>connect()</code>发起建连。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/23cc66a7f4cb06afe13842b4b339e28b.gif" alt="握手建立连接流程"></p><p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p><p>光这样一个纯裸的TCP连接，就可以做到收发数据了，那是不是就够了？</p><p>不行，这么用会有问题。</p><h2 id="使用纯裸-TCP-会有什么问题"><a href="#使用纯裸-TCP-会有什么问题" class="headerlink" title="使用纯裸 TCP 会有什么问题"></a>使用纯裸 TCP 会有什么问题</h2><p>八股文常背，TCP是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3fcad07ba7ae92299b32224da8583363.png" alt="TCP是什么"></p><p>这三个特点真的概括的<strong>非常精辟</strong>，这个八股文我们没白背。</p><p>每个特点展开都能聊一篇文章，而今天我们需要关注的是<strong>基于字节流</strong>这一点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 <strong>01 串</strong>。纯裸TCP收发的这些 01 串之间是<strong>没有任何边界</strong>的，你根本不知道到哪个地方才算一条完整消息。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/254d845f9de05c19536d8343d268595a.png" alt="01二进制字节流"></p><p>正因为这个没有<strong>任何边界</strong>的特点，所以当我们选择使用TCP发送”夏洛”和”特烦恼”的时候，接收端收到的就是”夏洛特烦恼”，这时候接收端没发区分你是想要表达”夏洛”+”特烦恼”还是”夏洛特”+”烦恼”。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/cd7c006cb4180bf751c4afd268ed44f0.png" alt="消息对比"></p><p>这就是所谓的<strong>粘包问题</strong>，之前也写过一篇专门的<a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html">文章 (opens new window)</a>聊过这个问题。</p><p>说这个的目的是为了告诉大家，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些<strong>自定义的规则</strong>，用于区分<strong>消息边界</strong>。</p><p>于是我们会把每条要发送的数据都包装一下，比如加入<strong>消息头</strong>，<strong>消息头里写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的<strong>消息体</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9428feed1ff22156fc136d17a129527b.png" alt="消息边界长度标志"></p><p>而这里头提到的<strong>消息头</strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong></p><p>每个使用TCP的项目都可能会定义一套类似这样的协议解析标准，他们可能<strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC。</strong></p><h2 id="HTTP-和-RPC"><a href="#HTTP-和-RPC" class="headerlink" title="HTTP 和 RPC"></a>HTTP 和 RPC</h2><p>我们回过头来看网络的分层图。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/da970d16a205fb48d6a8bea14498814d.png" alt="四层网络协议"></p><p><strong>TCP是传输层的协议</strong>，而基于TCP造出来的HTTP和<strong>各类</strong>RPC协议，它们都只是定义了不同消息格式的<strong>应用层协议</strong>而已。</p><p><strong>HTTP</strong>协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），又叫做<strong>超文本传输协议</strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/809c33f7090c08b78d494445e39ae1b4.png" alt="HTTP调用"></p><p>而<strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p><p>举个例子，我们平时调用一个<strong>本地方法</strong>就像下面这样。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">res = localFunc(req)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2b2ea6d26af9ded517043e528b032307.png" alt="RPC可以像调用本地方法那样调用远端方法"></p><p>基于这个思路，大佬们造出了非常多款式的RPC协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p><p>值得注意的是，虽然大部分RPC协议底层使用TCP，但实际上<strong>它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/054e9738bc492a6fb6e9a71737d95fc0.png" alt="基于TCP协议的HTTP和RPC协议"></p><p>到这里，我们回到文章标题的问题。</p><blockquote><p>既然有HTTP协议，为什么还要有RPC？</p></blockquote><p>其实，<code>TCP</code>是<strong>70年</strong>代出来的协议，而<code>HTTP</code>是<strong>90年代</strong>才开始流行的。而直接使用裸TCP会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有<strong>80年代</strong>出来的<code>RPC</code>。</p><p>所以我们该问的不是<strong>既然有HTTP协议为什么要有RPC</strong>，而是<strong>为什么有RPC还要有HTTP协议</strong>。</p><blockquote><p>那既然有 RPC 了，为什么还要有HTTP呢？</p></blockquote><p>现在电脑上装的各种<strong>联网</strong>软件，比如xx管家，xx卫士，它们都作为<strong>客户端（client）需要跟服务端（server）建立连接收发消息</strong>，此时都会用到应用层协议，在这种 client/server (c/s) 架构下，它们可以使用自家造的RPC协议，因为它只管连自己公司的服务器就ok了。</p><p>但有个软件不同，<strong>浏览器（browser）</strong>，不管是chrome还是IE，它们不仅要能访问自家公司的<strong>服务器（server）</strong>，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP就是那个时代用于统一 <strong>browser/server (b/s)</strong> 的协议。</p><p>也就是说在多年以前，<strong>HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。**很多软件同时支持多端，比如某度云盘，既要支持**网页版**，还要支持</strong>手机端和pc端**，如果通信协议都用HTTP的话，那服务器只用同一套就够了。而RPC就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><p>那这么说的话，<strong>都用HTTP得了，还用什么RPC？</strong></p><p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p><h2 id="HTTP-和-RPC-有什么区别"><a href="#HTTP-和-RPC-有什么区别" class="headerlink" title="HTTP 和 RPC 有什么区别"></a>HTTP 和 RPC 有什么区别</h2><p>我们来看看RPC和HTTP区别比较明显的几个点。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道<strong>IP地址和端口</strong>。这个找到服务对应的IP端口的过程，其实就是<strong>服务发现</strong>。</p><p>在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS服务</strong>去解析得到它背后的IP地址，默认80端口。</p><p>而<strong>RPC</strong>的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如<strong>consul或者etcd，甚至是redis</strong>。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如<strong>CoreDNS</strong>。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h3 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h3><p>以主流的<strong>HTTP1.1</strong>协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p><p>而<strong>RPC</strong>协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ec5c8e28d3ea308c6db2ac991a12ea80.png" alt="connection_pool"></p><p><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池</strong>，比如<strong>go</strong>就是这么干的。</p><p>可以看出这一块两者也没太大区别，所以也不是关键。</p><h3 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h3><p>基于TCP传输的消息，说到底，无非都是<strong>消息头header和消息体body。</strong></p><p><strong>header</strong>是用于标记一些特殊信息，其中最重要的是<strong>消息体长度</strong>。</p><p><strong>body</strong>则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如<strong>json，protobuf。</strong></p><p>这个将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dba2bc3af0938d2c087f85acc191fd3f.png" alt="序列化和反序列化"></p><p>对于主流的HTTP1.1，虽然它现在叫<strong>超文本</strong>协议，支持音频视频，但HTTP设计初是用于做网页<strong>文本</strong>展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用<strong>json</strong>来<strong>序列化</strong>结构体数据。</p><p>我们可以随便截个图直观看下。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/324cbe84c303a3b975e50329f5cdbf8b.png" alt="HTTP报文"></p><p>可以看到这里面的内容非常多的<strong>冗余</strong>，显得<strong>非常啰嗦</strong>。最明显的，像<code>header</code>里的那些信息，其实如果我们约定好头部的第几位是content-type，就<strong>不需要每次都真的把”content-type”这个字段都传过来</strong>，类似的情况其实在<code>body</code>的json结构里也特别明显。</p><p>而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f4cef7331cabcfe56d9d6434f7ef907f.png" alt="HTTP原理"></p><p>当然上面说的HTTP，其实<strong>特指的是现在主流使用的HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以<strong>性能可能比很多RPC协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p><blockquote><p>那么问题又来了，为什么既然有了HTTP2，还要有RPC协议？</p></blockquote><p>这个是由于 HTTP2 是2015年出来的。那时候很多公司内部的RPC协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><ul><li><p>纯裸TCP是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP和各类RPC协议就是在TCP之上定义的应用层协议。</p></li><li><p><strong>RPC本质上不算是协议，而是一种调用方式</strong>，而像gRPC和thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，<strong>不一定非得基于TCP协议</strong>。</p></li><li><p>从发展历史来说，<strong>HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合</strong>。很多软件同时支持多端，所以对外一般用HTTP协议，而内部集群的微服务之间则采用RPC协议进行通讯。</p></li><li><p>RPC其实比HTTP出现的要早，且比目前主流的HTTP1.1<strong>性能</strong>要更好，所以大部分公司内部都还在使用RPC。</p></li><li><p><strong>HTTP2.0</strong>在<strong>HTTP1.1</strong>的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java格式化输出</title>
      <link href="/2022/09/04/java-ge-shi-hua-shu-chu/"/>
      <url>/2022/09/04/java-ge-shi-hua-shu-chu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、System-out-printf"><a href="#一、System-out-printf" class="headerlink" title="一、System.out.printf()"></a>一、System.out.printf()</h1><p>Java SE5推出了C语言printf()风格的<a href="https://so.csdn.net/so/search?q=%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA&amp;spm=1001.2101.3001.7020">格式化输出</a>功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%o\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"一个字符串：%s，一个浮点数：%f，一个整数：%d"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以一次输出多个变量，注意顺序即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二、System-out-format"><a href="#二、System-out-format" class="headerlink" title="二、System.out.format()"></a>二、System.out.format()</h1><p>Java SE5引入的format()方法模仿C的printf()方法，可用于PrintStream或者PrintWriter对象，包括System.out对象。用法基本上和System.out.printf()类似。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%o\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"一个字符串：%s，一个浮点数：%f，一个整数：%d"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以一次输出多个变量，注意顺序即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、Fomatter类"><a href="#三、Fomatter类" class="headerlink" title="三、Fomatter类"></a>三、Fomatter类</h1><p>Java中所有的格式化功能都由java.util.Formatter类处理。当你创建一个Formatter对象时 ，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Formatter</span></span><span class="token punctuation">;</span><span class="token comment">//使用Formatter类时需要导入java.util.Formatter</span><span class="token class-name">Formatter</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个Formatter对象，指定输出为System.out</span><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%o\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span>f<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"一个字符串：%s，一个浮点数：%f，一个整数：%d"</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span>pi<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以一次输出多个变量，注意顺序即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、String-format"><a href="#四、String-format" class="headerlink" title="四、String.format()"></a>四、String.format()</h1><p>String.format()是一个static方法，接收与Formatter.format()一样的参数，其返回值：String对象，适用于一次输出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str<span class="token operator">=</span><span class="token string">"Java"</span><span class="token punctuation">;</span><span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//"%"表示进行格式化输出，其后是格式的定义</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"f"表示格式化输出浮点数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"d"表示格式化输出十进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%o"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"o"表示格式化输出八进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"x"表示格式化输出十六进制整数</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"s"表示格式化输出字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化输出 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用中的问题</title>
      <link href="/2022/09/03/markdown-shi-yong-zhong-de-wen-ti/"/>
      <url>/2022/09/03/markdown-shi-yong-zhong-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>因为使用了GitHub作为图床，需要将图片上传，所以不可以插入截图，必须将图片保存下来。</p><p>复制网页上的图片时，可以插入，因为复制的是图片的链接，所以可以使用。</p><p><strong>注意</strong>：</p><ul><li>插入图片的路径不可以出现中文</li></ul><h1 id="快捷键使用"><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h1><p>现在还没有解决。感觉快捷键出现了冲突。</p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vpn软件的推荐</title>
      <link href="/2022/09/03/vpn-ruan-jian-de-tui-jian/"/>
      <url>/2022/09/03/vpn-ruan-jian-de-tui-jian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="白鲸加速器"><a href="#白鲸加速器" class="headerlink" title="白鲸加速器"></a>白鲸加速器</h1><p><a href="https://m.bjch110.com/">白鲸加速器 - 永远能连上的VPN (bjch110.com)</a></p><p>这个加速器其实也还可以，平时如果是访问 GitHub 的话，基本可以满足，然后可以看看推特，但是网速有些慢，看不了电报里面的东西。</p><p><strong>最重要的是现在是免费的，而且一个设备可以注册两个账号，然后一个账号可以使用一个月，邀请人可以增加时长，所以我现在已经可以免费使用一年了。</strong></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-09-57-Snipaste_2022-09-03_21-09-34.png"></p><h1 id="安易加速器"><a href="#安易加速器" class="headerlink" title="安易加速器"></a>安易加速器</h1><p><a href="https://www.anyi8.com/#feature">安易加速器 - 最稳定安全易用的高速VPN (anyi8.com)</a></p><p>这个加速器速度快，但是只能免费使用 10 天，但是不知道一个设备可以创建几个账号。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-10-28-Snipaste_2022-09-03_21-10-21.png"></p><h1 id="快连vpn"><a href="#快连vpn" class="headerlink" title="快连vpn"></a>快连vpn</h1><p>  <a href="https://letsvpn.world/?hl=zh">快连VPN 官方网站</a></p><p>这个加速器，感觉速度很快，但是之前有免费使用的机会，现在没有了。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-48-00-1.jpg"></p><h1 id="V2云加速"><a href="#V2云加速" class="headerlink" title="V2云加速"></a>V2云加速</h1><p>  <a href="https://www.v2board.co/#/dashboard">首页 | V2云加速 (v2board.co)</a></p><p>这个没有使用过，所以不知道速度怎么样，但是感觉应该还不错，而且价格也不是很贵。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-55-45-Snipaste_2022-09-03_21-55-36.png"></p><h1 id="Rrabits-Cloudgeek"><a href="#Rrabits-Cloudgeek" class="headerlink" title="Rrabits Cloudgeek"></a>Rrabits Cloudgeek</h1><p><a href="https://cloud.rrabits.com/">Rrabits Cloudgeek</a></p><p>这个VPN价格也不是很贵，而且它的特点是可以按照流量进行购买。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-59-10-Snipaste_2022-09-03_21-59-01.png"></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-21-59-48-Snipaste_2022-09-03_21-59-37.png"></p><h1 id="起飞VPN"><a href="#起飞VPN" class="headerlink" title="起飞VPN"></a>起飞VPN</h1><h1 id="老王VPN"><a href="#老王VPN" class="headerlink" title="老王VPN"></a>老王VPN</h1><h1 id="推荐的几个VPN"><a href="#推荐的几个VPN" class="headerlink" title="推荐的几个VPN"></a>推荐的几个VPN</h1><p><a href="https://zh.vpnmentor.com/greatvpn/?keyword=+vpn&amp;geo=200&amp;device=&amp;ad=&amp;cq_src=google_ads&amp;cq_cmp=335155063&amp;cq_term=+vpn&amp;cq_plac=&amp;cq_net=o&amp;cq_plt=gp&amp;adid=75728921972514&amp;msclkid=08220a974afd180ab6bd6984182ccdf5&amp;utm_source=bing&amp;utm_medium=cpc&amp;utm_campaign=B_ROW_ZH_ZH_VPN&amp;utm_term=+vpn&amp;utm_content=vpn%20%5Bphrase%5D">九月 2022年5月5大实至名归的最佳 VPN</a></p><p>这几个 VPN 应该都是国外的，速度比较快，但是价格比较高，但是支持30天退款，所以之后如果想使用的话，可以试试。</p><h1 id="连接VPN的几个常用软件"><a href="#连接VPN的几个常用软件" class="headerlink" title="连接VPN的几个常用软件"></a>连接VPN的几个常用软件</h1><ul><li><p>Clash</p></li><li><p>Shadowrocket</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window10设置开机自启应用</title>
      <link href="/2022/09/03/window10-she-zhi-kai-ji-zi-qi-ying-yong/"/>
      <url>/2022/09/03/window10-she-zhi-kai-ji-zi-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-设置软件开机禁止自启动"><a href="#1-设置软件开机禁止自启动" class="headerlink" title="1. 设置软件开机禁止自启动"></a>1. 设置软件开机禁止自启动</h1><p>1.1 右键开始按钮，在弹出的窗口中，选择 “任务管理器”；</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/03-20-32-54-Snipaste_2022-09-03_20-32-12.png"></p><p>1.2 如果是精简窗口，点击<strong>详细信息</strong></p><p><img src="https://pic4.zhimg.com/80/v2-61514e608199a8c66a7645f724a33343_1440w.jpg"></p><p>1.3 点击&nbsp;<strong>启动</strong></p><p><img src="https://pic1.zhimg.com/80/v2-760f72c04b58a013052260556f470534_1440w.jpg"></p><p>1.4 在启动标签，选中要启动或者禁止启动的应用。</p><p><img src="https://pic3.zhimg.com/80/v2-9dd9a99536e532868f05e0745fdbd86a_1440w.jpg"></p><h1 id="2-设置未在任务管理器中的软件开机自启动"><a href="#2-设置未在任务管理器中的软件开机自启动" class="headerlink" title="2.设置未在任务管理器中的软件开机自启动"></a>2.设置未在任务管理器中的软件开机自启动</h1><p>2.1 win+R 调出<strong>运行</strong>窗口，然后输入&nbsp;<em>shell:startup</em>，按enter键</p><img src="https://pic2.zhimg.com/80/v2-93590ace5d265d54d5e7069a3070d13d_1440w.jpg" title="" alt="" data-align="inline"><p>2.2 将要开机启动的程序快捷方式拖到弹出的文件夹中</p><p><img src="https://pic2.zhimg.com/80/v2-8c0a1c7c2aafa9ff3228a1f129fe40f5_1440w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java小知识</title>
      <link href="/2022/09/02/java-xiao-zhi-shi/"/>
      <url>/2022/09/02/java-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h1><p>在学习 Lambda 表达式时，我们提到如果接口中只有一个抽象方法（可以包含多个默认方法或多个 static 方法），那么该接口就是函数式接口。@FunctionalInterface 就是用来指定某个接口必须是函数式接口，所以 @FunInterface 只能修饰接口，不能修饰其它程序元素。</p><h2 id="函数式接口就是为-Java-8-的-Lambda-表达式准备的，Java-8-允许使用-Lambda-表达式创建函数式接口的实例，因此-Java-8-专门增加了-FunctionalInterface。"><a href="#函数式接口就是为-Java-8-的-Lambda-表达式准备的，Java-8-允许使用-Lambda-表达式创建函数式接口的实例，因此-Java-8-专门增加了-FunctionalInterface。" class="headerlink" title="函数式接口就是为&nbsp;Java&nbsp;8 的 Lambda 表达式准备的，Java 8 允许使用 Lambda 表达式创建函数式接口的实例，因此 Java 8 专门增加了 @FunctionalInterface。"></a>函数式接口就是为&nbsp;<a href="http://c.biancheng.net/java/">Java</a>&nbsp;8 的 Lambda 表达式准备的，Java 8 允许使用 Lambda 表达式创建函数式接口的实例，因此 Java 8 专门增加了 @FunctionalInterface。</h2><p>例如，如下程序使用 @FunctionalInterface 修饰了函数式接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FunInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C语言中文网"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我正在学习C语言中文网Java教程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只定义一个抽象方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译上面程序，可能丝毫看不出程序中的 @FunctionalInterface 有何作用，因为 @FunctionalInterface 注解的作用只是告诉编译器检查这个接口，保证该接口只能包含一个抽象方法，否则就会编译出错。  </p><p>@FunctionalInterface 注解主要是帮助程序员避免一些低级错误，例如，在上面的 FunInterface 接口中再增加一个抽象方法 abc()，编译程序时将出现如下错误提示：</p><p><code>“@FunctionInterface”批注无效；FunInterface不是functional接口</code></p><h2 id="Runnable-接口为函数式接口"><a href="#Runnable-接口为函数式接口" class="headerlink" title="Runnable 接口为函数式接口"></a>Runnable 接口为函数式接口</h2><p>使用 lambda 创建线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 零碎知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发学习</title>
      <link href="/2022/09/02/java-bing-fa-xue-xi/"/>
      <url>/2022/09/02/java-bing-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-并发编程"><a href="#java-并发编程" class="headerlink" title="java 并发编程"></a>java 并发编程</h1><h2 id="1-1-进程和线程"><a href="#1-1-进程和线程" class="headerlink" title="1.1 进程和线程"></a>1.1 进程和线程</h2><p><strong>进程</strong></p><ul><li><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</p></li><li><p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。<br>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p></li></ul><p><strong>线程</strong></p><ul><li><p>一个进程之内可以分为一到多个线程。</p></li><li><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p></li><li><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</p></li></ul><p><strong>对比</strong></p><ul><li><p>进程是相互独立的，而线程存在于进程内，是进程的一个子集</p></li><li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p></li><li><p>进程间通信复杂</p><ul><li><p>同一台计算机的进程通信成为 IPC (Inter-process communication)</p></li><li><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</p></li></ul></li><li><p>线程通信相对简单，因为他们共享进程内的内存，多个线程可以访问同一个共享变量</p></li><li><p>线程更轻量，线程上下文切换成本一般要比进程上下文低</p></li></ul><h2 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h2><ul><li><p>并发 (concurrent) 是同一时间应对多件事情的能力</p></li><li><p>并行 (paraller) 是同一时间动手做多件事情的能力</p></li></ul><h2 id="1-3-同步与异步"><a href="#1-3-同步与异步" class="headerlink" title="1.3 同步与异步"></a>1.3 同步与异步</h2><p><strong>从方法调用的角度来讲</strong></p><ul><li><p>同步：需要等待结果返回</p></li><li><p>异步：不需要等待结果返回</p></li></ul><p>注意：同步在多线程中还有另外一层意思，是让多个线程步调一致</p><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p></li></ol><ul><li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</p></li><li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</p></li></ul><ol start="3"><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="2-1-创建和运行线程"><a href="#2-1-创建和运行线程" class="headerlink" title="2.1 创建和运行线程"></a>2.1 创建和运行线程</h2><p><strong>方法一，直接使用 Thread</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建线程对象</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 要执行的任务</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 启动线程</span>t<span class="token punctuation">.</span>start<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 构造方法的参数是给线程指定名字，推荐</span><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token comment">// run 方法内实现了要执行的任务</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法二，使用 Runnable 配合 Thread</strong></p><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li><p>Thread 代表线程</p></li><li><p>Runnable 可运行的任务（线程要执行的代码）</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 要执行的任务</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 创建线程对象</span><span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> runnable <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动线程</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建任务对象</span><span class="token class-name">Runnable</span> task2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task2<span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Java 8 以后可以使用 lambda 精简代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建任务对象</span><span class="token class-name">Runnable</span> task2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task2<span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>原理之 Thread 与 Runnable 的关系<br>分析 Thread 的源码，理清它与 Runnable 的关系</li><li>小结<br>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><p><strong>方法三，FutureTask 配合 Thread</strong></p><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建任务对象</span><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> task3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task3<span class="token punctuation">,</span> <span class="token string">"t3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><span class="token class-name">Integer</span> result <span class="token operator">=</span> task3<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"结果是:{}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">19:22:27 [t3] c.ThreadStarter - hello19:22:27 [main] c.ThreadStarter - 结果是:100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-观察多个线程同时运行"><a href="#2-2-观察多个线程同时运行" class="headerlink" title="2.2 观察多个线程同时运行"></a>2.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li><p>交替执行</p></li><li><p>谁先谁后，不由我们控制</p></li></ul><h2 id="2-3-查看进程线程的方法"><a href="#2-3-查看进程线程的方法" class="headerlink" title="2.3 查看进程线程的方法"></a>2.3 查看进程线程的方法</h2><p>windows</p><ul><li><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p></li><li><p>tasklist 查看进程</p></li><li><p>taskkill 杀死进程</p></li></ul><p>linux</p><ul><li><p>ps -fe 查看所有进程</p></li><li><p>ps -fT -p 查看某个进程（PID）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写 H 切换是否显示线程</p></li><li><p>top -H -p 查看某个进程（PID）的所有线程</p></li></ul><p>Java</p><ul><li><p>jps 命令查看所有 Java 进程</p></li><li><p>jstack 查看某个 Java 进程（PID）的所有线程状态</p></li><li><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p></li></ul><p>jconsole 远程监控配置</p><ul><li>需要以如下方式运行你的 java 类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">java <span class="token operator">-</span><span class="token class-name">Djava</span><span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span>hostname<span class="token operator">=</span>`ip地址` <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote<span class="token punctuation">.</span>port<span class="token operator">=</span>`连接端口` <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote<span class="token punctuation">.</span>ssl<span class="token operator">=</span>是否安全连接 <span class="token operator">-</span><span class="token class-name">Dcom</span><span class="token punctuation">.</span>sun<span class="token punctuation">.</span>management<span class="token punctuation">.</span>jmxremote<span class="token punctuation">.</span>authenticate<span class="token operator">=</span>是否认证 java类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>修改 /etc/hosts 文件将 127.0.0.1 映射至主机名</li></ul><p>如果要认证访问，还需要做如下步骤</p><ul><li><p>复制 jmxremote.password 文件</p></li><li><p>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</p></li><li><p>连接时填入 controlRole（用户名），R&amp;D（密码）</p></li></ul><h2 id="2-4-原理–线程运行"><a href="#2-4-原理–线程运行" class="headerlink" title="2.4 原理–线程运行"></a>2.4 原理–线程运行</h2><p><strong>栈与栈帧</strong></p><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><p><strong>线程上下文切换（Thread Context Switch）</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li><p>线程的 cpu 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p></li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），<strong>它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</strong>。</p><h1 id="Java线程常用方法"><a href="#Java线程常用方法" class="headerlink" title="Java线程常用方法"></a>Java线程常用方法</h1><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th><th>注意</th></tr></thead><tbody><tr><td>start()</td><td></td><td>启动一个新线程，在新的线程中运行 run 方法中的代码</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻&nbsp;运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现&nbsp;IllegalThreadStateException</td></tr><tr><td>run()</td><td></td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象,来覆盖默认行为</td></tr><tr><td>join()</td><td></td><td>等待线程运行结束</td><td>用于进行线程的同步操作</td></tr><tr><td>join(long n)</td><td></td><td>等待线程运行结束,最多等待 n</td><td></td></tr><tr><td>getId()</td><td></td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>getName()</td><td></td><td>获取线程名</td><td></td></tr><tr><td>setName(String)</td><td></td><td>修改线程名</td><td></td></tr><tr><td>getPriority()</td><td></td><td>获取线程优先级</td><td>默认为 5 ，java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率。但不代表线程优先级高的一定能优先执行，具体看操作系统的调度。</td></tr><tr><td>getState()</td><td></td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：</td></tr><tr><td><br>NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td><td></td><td></td><td></td></tr><tr><td>isInterrupted()</td><td></td><td>判断是否被打&nbsp;断</td><td>不会清除 打断标记</td></tr><tr><td>isAlive()</td><td></td><td>线程是否存活&nbsp;（还没有运行完毕）</td><td></td></tr><tr><td>interrupt()</td><td></td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置打断标记</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是否被打断</td><td>否被打断 会清除 打断标记</td></tr><tr><td>currentThread()</td><td>static</td><td>获取当前正在执行的线程</td><td></td></tr><tr><td>sleep(long n)</td><td>static</td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu的时间片给其它线程</td><td></td></tr><tr><td>yield()</td><td>static</td><td>提示线程调度器让出当前线程对CPU的使用</td><td>主要是为了测试和调试</td></tr></tbody></table><h2 id="常用方法说明"><a href="#常用方法说明" class="headerlink" title="常用方法说明"></a>常用方法说明</h2><h3 id="start-run"><a href="#start-run" class="headerlink" title="start / run"></a>start / run</h3><ul><li><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程</p></li><li><p>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p></li></ul><h3 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep / yield"></a>sleep / yield</h3><p><strong>sleep</strong></p><ul><li><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p></li><li><p>. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ul><p><strong>yield</strong></p><ul><li><p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</p></li><li><p>具体的实现依赖于操作系统的任务调度器</p></li></ul><p><strong>线程优先级</strong></p><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><strong>为什么需要 join</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                r <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"结果为: %d \n"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ul><li><p>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10</p></li><li><p>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</p></li></ul><p>添加 <strong>t1.join()</strong> 后，输出 10</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li><p>需要等待结果返回，才能继续运行就是同步</p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-14-34-54-Snipaste_2022-09-04_14-34-37.png"></p><h3 id="有时效的-join"><a href="#有时效的-join" class="headerlink" title="有时效的 join"></a>有时效的 join</h3><p>可以设置等待的时间，时间结束后，不再等待。</p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p><strong>打断 sleep，wait，join 的线程</strong></p><p>这几个方法都会让线程进入阻塞状态</p><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> test1 <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出： False</p><p><strong>打断正常运行的线程</strong></p><p>打断正常运行的线程, 不会清空打断状态</p><p>输出： True</p><h3 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a>模式之两阶段终止</h3><h3 id="打断-park-线程"><a href="#打断-park-线程" class="headerlink" title="打断 park 线程"></a>打断 park 线程</h3><p>打断 park 线程, 不会清空打断状态</p><p>可以使用 Thread.interrupted() 清除打断状态</p><h2 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h2><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>stop()</td><td></td><td>停止线程运行</td></tr><tr><td>suspend()</td><td></td><td>挂起（暂停）线程运行</td></tr><tr><td>resume()</td><td></td><td>恢复线程运行</td></tr></tbody></table><h2 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"开始运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"开始运行..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"运行结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"daemon"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置该线程为守护线程</span>t1<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"运行结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出<br>&nbsp;&nbsp;&nbsp;&nbsp;08:26:38.123 [main] c.TestDaemon - 开始运行…<br>&nbsp;&nbsp;&nbsp;&nbsp;08:26:38.213 [daemon] c.TestDaemon - 开始运行…<br>&nbsp;&nbsp;&nbsp;&nbsp;08:26:39.215 [main] c.TestDaemon - 运行结束…</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>垃圾回收器线程就是一种守护线程</p></li><li><p>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</p></li></ul><h1 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h1><p>这是从 操作系统 层面来描述的</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-14-52-58-Snipaste_2022-09-04_14-52-48.png"></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li><p>【阻塞状态】</p><ul><li><p>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</p></li><li><p>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</p></li><li><p>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</p></li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h1 id="六种状态"><a href="#六种状态" class="headerlink" title="六种状态"></a>六种状态</h1><p>这是从 Java API 层面来描述的</p><p>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-15-00-09-Snipaste_2022-09-04_15-00-02.png"></p><ul><li><p>NEW 线程刚被创建，但是还没有调用 start() 方法</p></li><li><p>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线阻塞，在 Java 里无法区分，仍然认为是可运行）</p></li><li><p>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</p></li><li><p>TERMINATED 当线程代码运行结束</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-15-08-29-Snipaste_2022-09-04_15-08-12.png"></p><h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-15-10-48-Snipaste_2022-09-04_15-10-39.png"></p><h2 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span> <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题分析：</p><p>java 中对静态变量的自增、自减并不是原子操作。</p><p><strong>i++</strong>:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getstatic i <span class="token comment">// 获取静态变量i的值</span>iconst_1 <span class="token comment">// 准备常量1</span>iadd <span class="token comment">// 自增</span>putstatic i <span class="token comment">// 将修改后的值存入静态变量i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>i–</strong>:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getstatic i <span class="token comment">// 获取静态变量i的值</span>iconst_1 <span class="token comment">// 准备常量1</span>isub <span class="token comment">// 自减</span>putstatic i <span class="token comment">// 将修改后的值存入静态变量i</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：</p><h2 id="临界区-Ctitical-Section"><a href="#临界区-Ctitical-Section" class="headerlink" title="临界区 Ctitical Section"></a>临界区 Ctitical Section</h2><ul><li><p>一个程序运行多个线程本身是没有问题的</p></li><li><p>问题出在多个线程访问共享资源</p><ul><li><p>多个线程读共享资源其实也没有问题</p></li><li><p>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p></li></ul></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 临界区</span><span class="token punctuation">{</span> counter<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 临界区</span><span class="token punctuation">{</span> counter<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h2><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><h2 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h2><p>应用之互斥</p><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li><p>阻塞式的解决方案：synchronized，Lock</p></li><li><p>非阻塞式的解决方案：原子变量</p></li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p><strong>注意</strong></p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li><p>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p></li><li><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</p></li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span> <span class="token comment">// 线程1， 线程2(blocked)</span><span class="token punctuation">{</span> 临界区<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> room <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span> <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>room<span class="token punctuation">)</span> <span class="token punctuation">{</span> counter<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类比 房间 和 锁</strong></p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/04-16-13-45-Snipaste_2022-09-04_16-12-49.png"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p><p>为了加深理解，请思考下面的问题</p><ul><li><p>如果把 synchronized(obj) 放在 for 循环的外面，如何理解？– 原子性</p></li><li><p>如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？– 锁对象</p></li><li><p>如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？– 锁对象</p></li></ul><h2 id="面对对象改进"><a href="#面对对象改进" class="headerlink" title="面对对象改进"></a>面对对象改进</h2><p><strong>将进行改变的变量和操作封装为一个对象，对对象的方法添加 synchronized</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Room</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> value<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> value<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法上的-synchronized"><a href="#方法上的-synchronized" class="headerlink" title="方法上的 synchronized"></a>方法上的 synchronized</h2><p><strong>成员方法：</strong></p><ul><li>相当于锁住了 这个实例对象 this</li></ul><p><strong>类方法：</strong></p><ul><li>锁住了 这个类对象 ，Test.class</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 等价于</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 等价于</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线程“八锁”"><a href="#线程“八锁”" class="headerlink" title="线程“八锁”"></a>线程“八锁”</h1><p>观察到底锁住的到底是 this 还是 class， 判断线程启动的顺序。</p><h1 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h1><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><p><strong>局部变量是否线程安全？</strong></p><ul><li><p>局部变量是线程安全的</p></li><li><p>但局部变量引用的对象则未必</p><ul><li><p>如果该对象没有逃离方法的作用访问，它是线程安全的</p></li><li><p>如果该对象逃离方法的作用范围，需要考虑线程安全</p></li></ul></li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>每一个线程都会有自己的栈帧，都会复制一份局部变量，所以不存在共享。</p><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/05-11-21-08-Snipaste_2022-09-05_11-19-58.png"></p><h2 id="局部变量的引用"><a href="#局部变量的引用" class="headerlink" title="局部变量的引用"></a>局部变量的引用</h2><p><img src="https://raw.githubusercontent.com/zhang159-a/img/main/2022/09/05-11-20-25-Snipaste_2022-09-05_11-19-48.png"></p><p>可以通过添加 private 或 final 提供对外的封闭</p><p><strong>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</strong></p><h1 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h1><ul><li><p>String</p></li><li><p>Integer</p></li><li><p>StringBuffer</p></li><li><p>Random</p></li><li><p>Vector</p></li><li><p>Hashtable</p></li><li><p>java.util.concurrent 包下的类</p></li></ul><p>这里说他们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。</p><ul><li><p>它们的每个方法是原子的</p></li><li><p>但注意它们多个方法的组合不是原子的</p></li></ul><h2 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h2><p>String / Integer</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pop.xml文件出现错误</title>
      <link href="/2022/09/02/pop-xml-wen-jian-chu-xian-cuo-wu/"/>
      <url>/2022/09/02/pop-xml-wen-jian-chu-xian-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用-Idea-创建-maven-项目时，"><a href="#使用-Idea-创建-maven-项目时，" class="headerlink" title="使用 Idea 创建 maven 项目时，"></a>使用 Idea 创建 maven 项目时，</h1><h2 id="出现‘artifactId‘-with-value-‘xxx‘-does-not-match-a-valid-id-pattern的解决方法"><a href="#出现‘artifactId‘-with-value-‘xxx‘-does-not-match-a-valid-id-pattern的解决方法" class="headerlink" title="出现‘artifactId‘ with value ‘xxx‘ does not match a valid id pattern的解决方法"></a>出现‘artifactId‘ with value ‘xxx‘ does not match a valid id pattern的解决方法</h2><p><img src="https://img-blog.csdnimg.cn/8a155171d5c4487cba9e22e2edc490fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56CB5Yac56CU56m25YOn,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>查看pom.xml文件下的配置<br>显示其<code>artifictid</code>这一行出了错误</p><p>错误原因是含有中文或者空格，因为识别不到</p><p>artifictid的正则表达式为<code>[A-Za-z0-9_\-.]</code></p><p>所以只需要改掉其中文或者空格就可成功</p><p><img src="https://img-blog.csdnimg.cn/09eecf7b960c42ac9c0f5b8ced5e7f67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56CB5Yac56CU56m25YOn,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 安装说明</title>
      <link href="/2022/08/31/redis-an-zhuang-shuo-ming/"/>
      <url>/2022/08/31/redis-an-zhuang-shuo-ming/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis安装说明"><a href="#Redis安装说明" class="headerlink" title="Redis安装说明"></a>Redis安装说明</h1><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h1 id="1-单机安装Redis"><a href="#1-单机安装Redis" class="headerlink" title="1.单机安装Redis"></a>1.单机安装Redis</h1><h2 id="1-1-安装Redis依赖"><a href="#1-1-安装Redis依赖" class="headerlink" title="1.1.安装Redis依赖"></a>1.1.安装Redis依赖</h2><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum install -y gcc tcl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-上传安装包并解压"><a href="#1-2-上传安装包并解压" class="headerlink" title="1.2.上传安装包并解压"></a>1.2.上传安装包并解压</h2><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p>例如，我放到了/usr/local/src 目录：</p><p><img src="assets/image-20211211071712536.png" alt="image-20211211071712536"></p><p>解压缩：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tar -xzf redis-6.2.6.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压后：</p><p>进入redis目录：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cd redis-6.2.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行编译命令：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">make &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h2 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3.启动"></a>1.3.启动</h2><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="1-3-1-默认启动"><a href="#1-3-1-默认启动" class="headerlink" title="1.3.1.默认启动"></a>1.3.1.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><pre class="line-numbers language-none"><code class="language-none">redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图：</p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2.指定配置启动"></a>1.3.2.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>我们先将这个配置文件备份一份：</p><pre class="line-numbers language-none"><code class="language-none">cp redis.conf redis.conf.bck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后修改redis.conf文件中的一些配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><span class="token key attr-name">bind</span> <span class="token value attr-value">0.0.0.0</span><span class="token comment"># 守护进程，修改为yes后即可后台运行</span><span class="token key attr-name">daemonize</span> <span class="token value attr-value">yes </span><span class="token comment"># 密码，设置后访问Redis必须输入密码</span><span class="token key attr-name">requirepass</span> <span class="token value attr-value">123321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的其它常见配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 监听的端口</span><span class="token key attr-name">port</span> <span class="token value attr-value">6379</span><span class="token comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><span class="token key attr-name">dir</span> <span class="token value attr-value">.</span><span class="token comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><span class="token key attr-name">databases</span> <span class="token value attr-value">1</span><span class="token comment"># 设置redis能够使用的最大内存</span><span class="token key attr-name">maxmemory</span> <span class="token value attr-value">512mb</span><span class="token comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><span class="token key attr-name">logfile</span> <span class="token value attr-value">"redis.log"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动Redis：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 进入redis安装目录 cd /usr/local/src/redis-6.2.6# 启动redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 123321 shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-3-开机自启"><a href="#1-3-3-开机自启" class="headerlink" title="1.3.3.开机自启"></a>1.3.3.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vi /etc/systemd/system/redis.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重载系统服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们可以用下面这组命令来操作redis了：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行下面的命令，可以让redis开机自启：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl enable redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-Redis客户端"><a href="#2-Redis客户端" class="headerlink" title="2.Redis客户端"></a>2.Redis客户端</h1><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h2 id="2-1-Redis命令行客户端"><a href="#2-1-Redis命令行客户端" class="headerlink" title="2.1.Redis命令行客户端"></a>2.1.Redis命令行客户端</h2><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis-cli [options] [commonds]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><h2 id="2-2-图形化桌面客户端"><a href="#2-2-图形化桌面客户端" class="headerlink" title="2.2.图形化桌面客户端"></a>2.2.图形化桌面客户端</h2><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">GitHub - uglide/RedisDesktopManager: Cross-platform Developer GUI for Redis</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">Releases · lework/RedisDesktopManager-Windows · GitHub</a></p><h3 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1.安装"></a>2.2.1.安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p>解压缩后，运行安装程序即可安装：</p><p>此处略。</p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p>双击即可运行：</p><h3 id="2-2-2-建立连接"><a href="#2-2-2-建立连接" class="headerlink" title="2.2.2.建立连接"></a>2.2.2.建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p>在弹出的窗口中填写Redis服务信息：</p><p>点击确定后，在左侧菜单会出现这个链接：</p><p>点击即可建立连接了：</p><p>Redis默认有16个仓库，编号从0至15. 通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 选择 0号库select 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装说明 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day07</title>
      <link href="/2022/08/31/yi-yuan-ji-lu-day07/"/>
      <url>/2022/08/31/yi-yuan-ji-lu-day07/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天妈妈出院了，现在基本上没有什么事情了，只是不能工作，然后不能吃一些油腻的东西。今天回来是因为妹妹明天要去上学了，所以今天回来给她收拾收拾东西。妹妹要去郑州西亚斯学院，一个城堡学校。</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量声明：静态语言有别于动态语言的重要特征</title>
      <link href="/2022/08/28/bian-liang-sheng-ming-jing-tai-yu-yan-you-bie-yu-dong-tai-yu-yan-de-chong-yao-te-zheng/"/>
      <url>/2022/08/28/bian-liang-sheng-ming-jing-tai-yu-yan-you-bie-yu-dong-tai-yu-yan-de-chong-yao-te-zheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天我们将深入 Go 语法细节，学习静态语言有别于动态语言的一个重要特征：变量声明。那么变量声明究竟解决的是什么问题呢？我们先从变量这个概念说起。</p><p>在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为变量。</p><p>但这并不代表我们可以通过变量随意引用或修改内存，变量所绑定的内存区域是要有一个明确的边界的。也就是说，通过这样一个变量，我们究竟可以操作 4 个字节内存还是 8 个字节内存，又或是 256 个字节内存，编程语言的编译器或解释器需要明确地知道。</p><p>那么，编程语言的编译器或解释器是如何知道一个变量所能引用的内存区域边界呢？</p><p>其实，动态语言和静态语言有不同的处理方式。动态语言（比如 Python、Ruby 等）的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。</p><p>而静态编程语言在这方面的“体验略差”。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了“变量声明”。通过变量声明，语言使用者可以显式告知编译器一个变量的边界信息。在具体实现层面呢，这个边界信息由变量的类型属性赋予。</p><p>作为身处静态编程语言阵营的 Go 语言，它沿袭了静态语言的这一要求：<strong>使用变量之前需要先进行变量声明。</strong></p><p>首先，让我们先来看看 Go 语言的变量声明方法。</p><h1 id="Go-语言的变量声明方法"><a href="#Go-语言的变量声明方法" class="headerlink" title="Go 语言的变量声明方法"></a>Go 语言的变量声明方法</h1><p>我们前面说过，Go 是静态语言，所有变量在使用前必须先进行声明。声明的意义在于告诉编译器该变量可以操作的内存的边界信息，而这种边界通常又是由变量的类型信息提供的。</p><p>在 Go 语言中，有一个通用的变量声明方法是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/cf/03/cf0a619528dd03893edbb83f3c4dd303.jpg?wh=1487x770"></p><p>这个变量声明分为四个部分：</p><ul><li><p>var 是修饰变量声明的关键字；</p></li><li><p>a 为变量名；</p></li><li><p>int 为该变量的类型；</p></li><li><p>10 是变量的初值。</p></li></ul><p>你看啊，其实 Go 语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型的前面。这样做有什么好处呢？我先不说，我想请你思考一下。这个类型为变量提供了边界信息，在 Go 语言中，无论什么类型的变量，都可以使用这种形式进行变量声明。</p><p>但是，如果你没有显式为变量赋予初值，Go 编译器会为变量赋予这个类型的零值：</p><p><code>var a int // a的初值为int类型的零值: 0</code></p><p>什么是类型的零值呢？Go 语言的每种原生类型都有它的默认值（这些原生类型我们后面再讲），这个默认值就是这个类型的零值。这里我给你写了 Go 规范定义的内置原生类型的默认值（即零值）：</p><p><img src="https://static001.geekbang.org/resource/image/92/23/92242134ff5ccdaed32854d01690ab23.jpg?wh=1920x687"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland 运行错误</title>
      <link href="/2022/08/28/goland-yun-xing-cuo-wu/"/>
      <url>/2022/08/28/goland-yun-xing-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>解决Goland运行Go程序报错：该版本的 %1 与你运行的 Windows 版本不兼容</p><p><code>Error running 'go build awesomeProject (1)': Cannot run program "C:\Users\erbin\AppData\Local\Temp\___go_build_awesomeProject__1_.exe" (in directory "G:\Language Proctice\Goworks\src\awesomeProject"): CreateProcess error=216, 该版本的 %1 与你运行的 Windows 版本不兼容。请查看计算机的系统信息，然后联系软件发布者。</code></p><p>此时代码为</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> awesomeProject<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>在go中，应用程序的入口包要为main，而编译源码没有main包时，将无法编译输出可执行的文件，也就会导致这里的错误</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>将main函数所在的包名改为main，改之后如下</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 Spring Bean 定义常见错误</title>
      <link href="/2022/08/27/03-spring-bean-ding-yi-chang-jian-cuo-wu/"/>
      <url>/2022/08/27/03-spring-bean-ding-yi-chang-jian-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有 Spring 关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以定义一个 Bean 就变得格外重要了。</p><p>当然，对于这么重要的工作，Spring 自然给我们提供了很多简单易用的方式。然而，这种简单易用得益于 Spring 的“约定大于配置”，但我们往往不见得会对所有的约定都了然于胸，所以仍然会在 Bean 的定义上犯一些经典的错误。</p><p>接下来我们就来了解下那些经典错误以及它们背后的原理，你也可以对照着去看看自己是否也曾犯过，后来又是如何解决的。</p><h1 id="案例-1：隐式扫描不到-Bean-的定义"><a href="#案例-1：隐式扫描不到-Bean-的定义" class="headerlink" title="案例 1：隐式扫描不到 Bean 的定义"></a>案例 1：隐式扫描不到 Bean 的定义</h1><p>在构建 Web 服务时，我们常使用 Spring Boot 来快速构建。例如，使用下面的包结构和相关代码来完成一个简易的 Web 版 HelloWorld：</p><p><img src="https://static001.geekbang.org/resource/image/63/48/63f7d08fb89653e12b9946c4dca31c48.png?wh=375*93"></p><p>其中，负责启动程序的 Application 类定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>puzzle<span class="token punctuation">.</span>class1<span class="token punctuation">.</span>example1<span class="token punctuation">.</span>application</span><span class="token comment">//省略 import</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提供接口的 HelloWorldController 代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>puzzle<span class="token punctuation">.</span>class1<span class="token punctuation">.</span>example1<span class="token punctuation">.</span>application</span><span class="token comment">//省略 import</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"hi"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码即可实现一个简单的功能：访问<a href="http://localhost:8080/hi">http://localhost:8080/hi</a> 返回 helloworld。两个关键类位于同一个包（即 application）中。其中 HelloWorldController 因为添加了 @RestController，最终被识别成一个 Controller 的 Bean。</p><p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次和结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：</p><p><img src="https://static001.geekbang.org/resource/image/f6/30/f6080f4e2b10e7f54e79040b8362c230.png?wh=405*115"></p><p>实际上，我们没有改变任何代码，只是改变了包的结构，但是我们会发现这个 Web 应用失效了，即不能识别出 HelloWorldController 了。也就是说，我们找不到 HelloWorldController 这个 Bean 了。这是为何？</p><h2 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h2><p>要了解 HelloWorldController 为什么会失效，就需要先了解之前是如何生效的。对于 Spring Boot 而言，关键点在于 Application.java 中使用了 SpringBootApplication 注解。而这个注解继承了另外一些注解，具体定义如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span><span class="token comment">//省略非关键代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从定义可以看出，SpringBootApplication 开启了很多功能，其中一个关键功能就是 ComponentScan，参考其配置如下：</p><p><code>@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)</code></p><p>当 Spring Boot 启动时，ComponentScan 的启用意味着会去扫描出所有定义的 Bean，那么扫描什么位置呢？这是由 ComponentScan 注解的 basePackages 属性指定的，具体可参考如下定义：</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 5分钟轻松了解Spring基础知识</title>
      <link href="/2022/08/27/02-5-fen-zhong-qing-song-liao-jie-spring-ji-chu-zhi-shi/"/>
      <url>/2022/08/27/02-5-fen-zhong-qing-song-liao-jie-spring-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在进行“传统的”Java 编程时，对象与对象之间的关系都是紧密耦合的，例如服务类 Service 使用组件 ComponentA，则可能写出这样的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">ComponentA</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentA</span><span class="token punctuation">(</span><span class="token string">"first component"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在没有 Spring 之前，你应该会觉得这段代码并没有多大问题，毕竟大家都这么写，而且也没有什么更好的方式。就像只有一条大路可走时，大家都朝一个方向走，你大概率不会反思是不是有捷径。</p><p>而随着项目的开发推进，你会发现检验一个方式好不好的硬性标准之一，就是看它有没有拥抱变化的能力。假设有一天，我们的 ComponentA 类的构造器需要更多的参数了，你会发现，上述代码到处充斥着这行需要改进的代码：</p><p><code>private ComponentA component = new ComponentA("first component");</code></p><p>此时你可能会想了，那我用下面这种方式来构造 Service 就可以了吧？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">ComponentA</span> component；    <span class="token keyword">public</span> <span class="token class-name">Service</span><span class="token punctuation">(</span><span class="token class-name">ComponentA</span> component<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然不行，你忽略了一点，你在构建 Service 对象的时候，不还得使用 new 关键字来构建 Component？需要修改的调用处并不少！</p><p>很明显，这是一个噩梦。那么，除了这点，还有没有别的不好的地方呢？上面说的是非单例的情况，如果 ComponentA 本身是一个单例，会不会好些？毕竟我们可能找一个地方 new 一次 ComponentA 实例就足够了，但是你可能会发现另外一些问题。</p><p>下面是一段用“双重检验锁”实现的 CompoentA 类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComponentA</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">ComponentA</span> INSTANCE<span class="token punctuation">;</span>           <span class="token keyword">private</span> <span class="token class-name">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>           <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ComponentA</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">ComponentA</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      INSTANCE<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实写了这么多代码，最终我们只是要一个单例而已。而且假设我们有 ComponentB、ComponentC、ComponentD 等，那上面的重复性代码不都得写一遍？也是烦的不行，不是么？</p><p>除了上述两个典型问题，还有不易于测试、不易扩展功能（例如支持 AOP）等缺点。说白了，所有问题的根源（之一）<strong>就是对象与对象之间耦合性太强了。</strong></p><h1 id="所以-Spring-的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？"><a href="#所以-Spring-的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？" class="headerlink" title="所以 Spring 的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？"></a>所以 Spring 的引入，解决了上面这些零零种种的问题。那么它是怎么解决的呢？</h1><p>这里套用一个租房的场景。我们为什么喜欢通过中介来租房子呢？因为省事呀，只要花点小钱就不用与房东产生直接的“纠缠”了。</p><p>Spring 就是这个思路，它就像一个“中介”公司。当你需要一个依赖的对象（房子）时，你直接把你的需求告诉 Spring（中介）就好了，它会帮你搞定这些依赖对象，按需创建它们，而无需你的任何额外操作。</p><p>不过，在 Spring 中，房东和租房者都是对象实例，只不过换了一个名字叫 Bean 而已。</p><p>可以说，通过一套稳定的生产流程，作为“中介”的 Spring 完成了生产和预装（牵线搭桥）这些 Bean 的任务。此时，你可能想了解更多。例如，如果一个 Bean（租房者）需要用到另外一个 Bean（房子）时，具体是怎么操作呢？</p><p>本质上只能从 Spring“中介”里去找，有时候我们直接根据名称（小区名）去找，有时候则根据类型（户型），各种方式不尽相同。你就把 Spring 理解成一个 Map 型的公司即可，实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Bean</span><span class="token punctuation">&gt;</span></span> beanMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Bean</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> beanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上述代码所示，Bean 所属公司提供了对于 Map 的操作来完成查找，找到 Bean 后装配给其它对象，这就是依赖查找、自动注入的过程。</p><p>那么回过头看，这些 Bean 又是怎么被创建的呢？</p><p>对于一个项目而言，不可避免会出现两种情况：一些对象是需要 Spring 来管理的，另外一些（例如项目中其它的类和依赖的 Jar 中的类）又不需要。所以我们得有一个办法去标识哪些是需要成为 Spring Bean，因此各式各样的注解才应运而生，例如 <strong>Component 注解</strong>等。</p><p>那有了这些注解后，谁又来做“发现”它们的工作呢？直接配置指定自然不成问题，但是很明显“自动发现”更让人省心。此时，我们往往需要一个扫描器，可以模拟写下这样一个扫描器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationScan</span> <span class="token punctuation">{</span>        <span class="token comment">//通过扫描包名来找到Bean</span>    <span class="token keyword">void</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token class-name">String</span> packages<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">//</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了扫描器，我们就知道哪些类是需要成为 Bean。</p><p>那怎么实例化为 Bean（也就是一个对象实例而已）呢？很明显，只能通过反射来做了。不过这里面的方式可能有多种：</p><ul><li><p>java.lang.Class.newInsance()</p></li><li><p>java.lang.reflect.Constructor.newInstance()</p></li><li><p>ReflectionFactory.newConstructorForSerialization()</p></li></ul><p><strong>有了创建，有了装配，一个 Bean 才能成为自己想要的样子。</strong></p><p>而需求总是源源不断的，我们有时候想记录一个方法调用的性能，有时候我们又想在方法调用时输出统一的调用日志。诸如此类，我们肯定不想频繁再来个散弹式的修改。所以我们有了 AOP，帮忙拦截方法调用，进行功能扩展。拦截谁呢？在 Spring 中自然就是 Bean 了。</p><p>其实 AOP 并不神奇，结合刚才的 Bean（中介）公司来讲，假设我们判断出一个 Bean 需要“增强”了，我们直接让它从公司返回的时候，就使用一个代理对象作为返回不就可以了么？示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Bean</span><span class="token punctuation">&gt;</span></span> beanMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Bean</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//查找是否创建过</span>       <span class="token class-name">Bean</span> bean <span class="token operator">=</span> beanMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>bean <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> bean<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//创建一个Bean</span>       <span class="token class-name">Bean</span> bean <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//判断要不要AOP</span>       <span class="token keyword">boolean</span> needAop <span class="token operator">=</span> <span class="token function">judgeIfNeedAop</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">try</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>needAop<span class="token punctuation">)</span>              <span class="token comment">//创建代理对象</span>              bean <span class="token operator">=</span> <span class="token function">createProxyObject</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> bean<span class="token punctuation">;</span>           <span class="token keyword">else</span><span class="token operator">:</span>              <span class="token keyword">return</span> bean       <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>           beanMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么怎么知道一个对象要不要 AOP？既然一个对象要 AOP，它肯定被标记了一些“规则”，例如拦截某个类的某某方法，示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AopConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.spring.puzzle.ComponentA.execute()) "</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recordPayPerformance</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>      <span class="token comment">//</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，很明显了，假设你的 Bean 名字是 ComponentA，那么就应该返回 ComponentA 类型的代理对象了。至于这些规则是怎么建立起来的呢？你看到它上面使用的各种注解大概就能明白其中的规则了，无非就是扫描注解，根据注解创建规则。</p><p>以上即为 Spring 的一些核心思想，包括 Bean 的构建、自动注入和 AOP，这中间还会掺杂无数的细节，不过这不重要，抓住这个核心思想对你接下来理解各种类型的错误案例才是大有裨益的！</p><p>虽然说 Spring 容器上手简单，可以仅仅通过学习一些有限的注解，即可达到快速使用的目的。但在工程实践中，我们依然会从中发现一些常见的错误。尤其当你对 Spring 的生命周期还没有深入了解时，类初始化及销毁过程中潜在的约定就不会很清楚。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 贴心&quot;保姆&quot;Spring罢工了怎么办</title>
      <link href="/2022/08/27/01-tie-xin-bao-mu-spring-ba-gong-liao-zen-me-ban/"/>
      <url>/2022/08/27/01-tie-xin-bao-mu-spring-ba-gong-liao-zen-me-ban/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring 就是这样，它有很多隐性的约定，而这些约定并不一定是你所熟悉的。所以，当你遇到问题时，很有可能就抓狂了。一方面我们得益于它所带来的轻松，因为不需要了解太多我们也能工作；另一方面也会崩溃于问题来临之时无法快速解决，因为我们平时根本不需要，甚至不觉得要了解更多。</p><p>这个时候就有很多人跳出来跟你说：“你一定要提前把 Spring 吃透啊！”</p><p>可当你翻阅 Spring 源码时，你肯定会望而生畏，真的太多了，不带着问题去学习无异于大海捞针。即使你去通读市场上大多数畅销的 Spring 教程，你可能仍然会感觉到茫然，不知道自己到底掌握得如何。毕竟读完之后，你不一定能预见到未来可能遇到哪些问题，而这些问题的规避和处理往往才是检验你学习成果的标准。</p><h1 id="我如何讲这门课？"><a href="#我如何讲这门课？" class="headerlink" title="我如何讲这门课？"></a>我如何讲这门课？</h1><p>厌倦了遇到问题时的疲于奔命，自然就要寻找高效便捷的学习法门了，所以这几年我一直在整理 Spring 开发中所遇到的各种各样的问题，然后按类划分。</p><p>项目忙的时候，就简单记录一下，忙过去了就深入研究。现在我的 ToDoList 已经非常详实了，对我的团队帮助也非常大。对于新人来说，这是份全面的避坑指南；对于老人来说，这又是个很好的问题备忘录。</p><p>在内容设计上，整个专栏都是以问题驱动的方式来组织知识点的，大概是这样的一个思路：</p><p><img src="https://static001.geekbang.org/resource/image/45/de/45d103389eab48e4d911a7a6f7d4c0de.png?wh=548*195"></p><p>而在问题的选型上，我一共筛选出了 50 多个常见问题，这些问题主要来自：我和同事在生产环境中经常遇到问题，Stack Overflow 网站上的一些高频问题，以及常用搜索引擎检索到的一些高频问题。</p><p>这些问题的选择都遵循这样几个原则：</p><ul><li><p>不难，但是常见，基本每个人都会遇到；</p></li><li><p>不太常见，但是一旦碰见，很容易入坑；</p></li><li><p>在某些场景下可以工作，换一种情况就失效。</p></li></ul><h1 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h1><p>有了关于具体内容的详细说明，我相信你对专栏所能解决的问题已经有了大概的感知。接下来，我再跟你说说整体的课程设计，帮助你进一步了解</p><p>本专栏共分为以下三个部分，你可以对照着下面这张图去理解我的设计思路：</p><p><img src="https://static001.geekbang.org/resource/image/83/fc/834c92d778378859acf4e0e02ee778fc.png?wh=5300*1528"></p><p><strong>Spring Core 篇</strong>：Spring Core 包括 Bean 定义、注入、AOP 等核心功能，可以说它们是 Spring 的基石。不管未来你是做 Spring Web 开发，还是使用 Spring Cloud 技术栈，你都绕不开这些功能。所以这里我会重点介绍在这些功能使用上的常见问题。</p><p><strong>Spring Web 篇</strong>：大多项目使用 Spring 还是为了进行 Web 开发，所以我也梳理了从请求 URL 解析、Header 解析、Body 转化到授权等 Web 开发中绕不开的问题。不难发现，它们正好涵盖了从一个请求到来，到响应回去这一完整流程。</p><p><strong>Spring 补充篇</strong>：作为补充，这部分我会重点介绍 Spring 测试、Spring 事务、Spring Data 相关问题。最后，我还会为你系统总结下 Spring 使用中发生问题的根本原因。</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>不过，有几点我还是要提醒你一下。这门课程需要一定的基础，你要知道最基本的 Spring 使用知识，比如如何自动注入一个 Bean，如何使用 AOP 等；同时，你也需要有一定的耐心，因为涉及源码理解。</p><p>另外，这门课程重在实践与查漏补缺，所以在每个问题的讲解上，我不可能追根溯源地把所有的背景知识、前后调用关系都完整呈现出来，否则你看到的无疑是一门包含大量重复内容的 Spring 教程而已，这也违背了这门课的初衷。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>即学即练：构建一个Web服务</title>
      <link href="/2022/08/27/ji-xue-ji-lian-gou-jian-yi-ge-web-fu-wu/"/>
      <url>/2022/08/27/ji-xue-ji-lian-gou-jian-yi-ge-web-fu-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="预热：最简单的-HTTP-服务"><a href="#预热：最简单的-HTTP-服务" class="headerlink" title="预热：最简单的 HTTP 服务"></a>预热：最简单的 HTTP 服务</h1><p><img src="https://static001.geekbang.org/resource/image/9a/91/9ab73568ef659d75a313f3394a811491.png?wh=1194x1158"></p><p>我们看到，Go 应用的前 4 个领域中，有两个都是 Web 服务相关的。一个是排在第一位的 API/RPC 服务，另一个是排在第四位的 Web 服务（返回 html 页面）。考虑到后续你把 Go 应用于 Web 服务领域的机会比较大，所以，在这节课我们就选择一个 Web 服务项目作为实战小项目。</p><p>不过在真正开始我们的实战小项目前，我们先来预热一下，做一下技术铺垫。我先来给你演示一下<strong>在 Go 中创建一个基于 HTTP 协议的 Web 服务是多么的简单</strong>。</p><p>这种简单又要归功于 Go“面向工程”特性。在 02 讲介绍 Go 的设计哲学时，我们也说过，Go“面向工程”的特性，不仅体现在语言设计方面时刻考虑开发人员的体验，而且它还提供了完善的工具链和“自带电池”的标准库，这就使得 Go 程序大大减少了对外部第三方包的依赖。以开发 Web 服务为例，我们可以基于 Go 标准库提供的 net/http 包，轻松构建一个承载 Web 内容传输的 HTTP 服务。</p><p>下面，我们就来构建一个最简单的 HTTP 服务，这个服务的功能很简单，就是当收到一个 HTTP 请求后，给请求方返回包含“hello, world”数据的响应。</p><p>我们首先按下面步骤建立一个 simple-http-server 目录，并创建一个名为 simple-http-server 的 Go Module：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> simple-http-server<span class="token variable">$cd</span> simple-http-server<span class="token variable">$go</span> mod init simple-http-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于这个 HTTP 服务比较简单，我们采用最简项目布局，也就是在 simple-http-server 目录下创建一个 main.go 源文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token keyword">package</span> main <span class="token keyword">import</span> <span class="token string">"net/http"</span> <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span class="token punctuation">{</span>         w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些代码就是一个最简单的 HTTP 服务的实现了。在这个实现中，我们只使用了 Go 标准库的 http 包。可能你现在对 http 包还不熟悉，但没有关系，你现在只需要大致了解上面代码的结构与原理就可以了。</p><p>这段代码里，你要注意两个重要的函数，一个是 ListenAndServe，另一个是 HandleFunc。</p><p>你会看到，代码的第 9 行，我们通过 http 包提供的 ListenAndServe 函数，建立起一个 HTTP 服务，这个服务监听本地的 8080 端口。客户端通过这个端口与服务建立连接，发送 HTTP 请求就可以得到相应的响应结果。</p><p>那么服务端是如何处理客户端发送的请求的呢？我们看上面代码中的第 6 行。在这一行中，我们为这个服务设置了一个处理函数。这个函数的函数原型是这样的：</p><p><code>func(w http.ResponseWriter, r *http.Request)</code></p><p>这个函数里有两个参数，w 和 r。第二个参数 r 代表来自客户端的 HTTP 请求，第一个参数 w 则是用来操作返回给客户端的应答的，基于 http 包实现的 HTTP 服务的处理函数都要符合这一原型。</p><p>你也发现了，在这个例子中，所有来自客户端的请求，无论请求的 URI 路径（RequestURI）是什么，请求都会被我们设置的处理函数处理。为什么会这样呢？</p><p>这是因为，我们通过 http.HandleFunc 设置这个处理函数时，传入的模式字符串为“/”。HTTP 服务器在收到请求后，会将请求中的 URI 路径与设置的模式字符串进行最长前缀匹配，并执行匹配到的模式字符串所对应的处理函数。在这个例子中，我们仅设置了“/”这一个模式字符串，并且所有请求的 URI 都能与之匹配，自然所有请求都会被我们设置的处理函数处理。</p><p>接着，我们再来编译运行一下这个程序，直观感受一下 HTTP 服务处理请求的过程。我们首先按下面步骤来编译并运行这个程序:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cd</span> simple-http-server<span class="token variable">$go</span> build$./simple-http-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们用 curl 命令行工具模拟客户端，向上述服务建立连接并发送 http 请求：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$curl</span> localhost:8080/hello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们看到，curl 成功得到了 http 服务返回的“hello, world”响应数据。到此，我们的 HTTP 服务就构建成功了。</p><p>当然了，真实世界的 Web 服务不可能像上述例子这么简单，这仅仅是一个“预热”。我想让你知道，使用 Go 构建 Web 服务是非常容易的。并且，这样的预热也能让你初步了解实现代码的结构，先有一个技术铺垫。</p><p>下面我们就进入这节课的实战小项目，一个更接近于真实世界情况的<strong>图书管理 API 服务</strong>。</p><h1 id="图书管理-API-服务"><a href="#图书管理-API-服务" class="headerlink" title="图书管理 API 服务"></a>图书管理 API 服务</h1><p>首先，我们先来明确一下我们的业务逻辑。</p><p>在这个实战小项目中，我们模拟的是真实世界的一个书店的图书管理后端服务。这个服务为平台前端以及其他客户端，提供针对图书的 CRUD（创建、检索、更新与删除）的基于 HTTP 协议的 API。API 采用典型的 RESTful 风格设计，这个服务提供的 API 集合如下：</p><p><img src="https://static001.geekbang.org/resource/image/99/51/99717b62f7553e1a5139edcf2ac03b51.jpg?wh=1980x788"></p><p>这个 API 服务的逻辑并不复杂。简单来说，我们通过 id 来唯一标识一本书，对于图书来说，这个 id 通常是 ISBN 号。至于客户端和服务端中请求与响应的数据，我们采用放在 HTTP 协议包体（Body）中的 Json 格式数据来承载。</p><p>业务逻辑是不是很简单啊？下面我们就直接开始创建这个项目。</p><h2 id="项目建立与布局设计"><a href="#项目建立与布局设计" class="headerlink" title="项目建立与布局设计"></a>项目建立与布局设计</h2><p>我们按照下面步骤创建一个名为 bookstore 的 Go 项目并创建对应的 Go Module：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> bookstore<span class="token variable">$cd</span> bookstore<span class="token variable">$go</span> mod init bookstorego: creating new go.mod: module bookstore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的业务逻辑说明，我们可以把这个服务大体拆分为两大部分，一部分是 HTTP 服务器，用来对外提供 API 服务；另一部分是图书数据的存储模块，所有的图书数据均存储在这里。</p><p>同时，这是一个以构建可执行程序为目的的 Go 项目，我们参考 Go 项目布局标准一讲中的项目布局，把这个项目的结构布局设计成这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── cmd/│   └── bookstore/         // 放置bookstore main包源码│       └── main.go├── go.mod                 // module bookstore的go.mod├── go.sum├── internal/              // 存放项目内部包的目录│   └── store/│       └── memstore.go     ├── server/                // HTTP服务器模块│   ├── middleware/│   │   └── middleware.go│   └── server.go          └── store/                 // 图书数据存储模块    ├── factory/    │   └── factory.go    └── store.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们既给出了这个项目的结构布局，也给出了这个项目最终实现的源码文件分布情况。下面我们就从 main 包开始，自上而下逐一看看这个项目的模块设计与实现。</p><h2 id="项目-main-包"><a href="#项目-main-包" class="headerlink" title="项目 main 包"></a>项目 main 包</h2><p>main 包是主要包，为了搞清楚各个模块之间的关系，我在这里给出了 main 包的实现逻辑图：</p><p><img src="https://static001.geekbang.org/resource/image/5e/19/5e8ee50b67a4229210b12afb94f55a19.jpg?wh=1980x1080"></p><p>同时，我也列出了 main 包（main.go）的所有代码，你可以先花几分钟看一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"> <span class="token keyword">package</span> main <span class="token keyword">import</span> <span class="token punctuation">(</span>     <span class="token boolean">_</span> <span class="token string">"bookstore/internal/store"</span>     <span class="token string">"bookstore/server"</span>     <span class="token string">"bookstore/store/factory"</span>     <span class="token string">"context"</span>     <span class="token string">"log"</span>     <span class="token string">"os"</span>     <span class="token string">"os/signal"</span>     <span class="token string">"syscall"</span>     <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s<span class="token punctuation">,</span> err <span class="token operator">:=</span> factory<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"mem"</span><span class="token punctuation">)</span> <span class="token comment">// 创建图书数据存储模块实例</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    srv <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">NewBookStoreServer</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// 创建http服务实例</span>    errChan<span class="token punctuation">,</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 运行http服务</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"web server start failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"web server start ok"</span><span class="token punctuation">)</span>    c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> os<span class="token punctuation">.</span>Signal<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    signal<span class="token punctuation">.</span><span class="token function">Notify</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SIGINT<span class="token punctuation">,</span> syscall<span class="token punctuation">.</span>SIGTERM<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span> <span class="token comment">// 监视来自errChan以及c的事件</span>    <span class="token keyword">case</span> err <span class="token operator">=</span> <span class="token operator">&lt;-</span>errChan<span class="token punctuation">:</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"web server run failed:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>c<span class="token punctuation">:</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bookstore program is exiting..."</span><span class="token punctuation">)</span>        ctx<span class="token punctuation">,</span> cf <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        <span class="token keyword">defer</span> <span class="token function">cf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        err <span class="token operator">=</span> srv<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token comment">// 优雅关闭http服务实例</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bookstore program exit error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bookstore program exit ok"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Go 中，main 包不仅包含了整个程序的入口，它还是整个程序中主要模块初始化与组装的场所。那对应在我们这个程序中，主要模块就是第 16 行的创建图书存储模块实例，以及第 21 行创建 HTTP 服务模块实例。而且，你还要注意的是，第 21 行创建 HTTP 服务模块实例的时候，我们把图书数据存储实例 s 作为参数，传递给了 NewBookStoreServer 函数。这两个实例的创建原理，我们等会再来细细探讨。</p><p>这里，我们重点来看 main 函数的后半部分（第 30 行~ 第 42 行），这里表示的是，我们通过监视系统信号实现了 http 服务实例的优雅退出。</p><p>所谓优雅退出，指的就是程序有机会等待其他的事情处理完再退出。比如尚未完成的事务处理、清理资源（比如关闭文件描述符、关闭 socket）、保存必要中间状态、内存数据持久化落盘，等等。如果你经常用 Go 来编写 http 服务，那么 http 服务如何优雅退出，就是你经常要考虑的问题。</p><p>在这个问题的具体实现上，我们通过 signal 包的 Notify 捕获了 SIGINT、SIGTERM 这两个系统信号。这样，当这两个信号中的任何一个触发时，我们的 http 服务实例都有机会在退出前做一些清理工作。</p><p>然后，我们再使用 http 服务实例（srv）自身提供的 Shutdown 方法，来实现 http 服务实例内部的退出清理工作，包括：立即关闭所有 listener、关闭所有空闲的连接、等待处于活动状态的连接处理完毕，等等。当 http 服务实例的清理工作完成后，我们整个程序就可以正常退出了。</p><p>接下来，我们再重点看看构成 bookstore 程序的两个主要模块：图书数据存储模块与 HTTP 服务模块的实现。我们按照 main 函数中的初始化顺序，先来看看图书数据存储模块。</p><h2 id="图书数据存储模块（store"><a href="#图书数据存储模块（store" class="headerlink" title="图书数据存储模块（store)"></a>图书数据存储模块（store)</h2><p>图书数据存储模块的职责很清晰，就是用来存储整个 bookstore 的图书数据的。图书数据存储有很多种实现方式，最简单的方式莫过于在内存中创建一个 map，以图书 id 作为 key，来保存图书信息，我们在这一讲中也会采用这种方式。但如果我们要考虑上生产环境，数据要进行持久化，那么最实际的方式就是通过 Nosql 数据库甚至是关系型数据库，实现对图书数据的存储与管理。</p><p>考虑到对多种存储实现方式的支持，我们将针对图书的有限种存储操作，放置在一个接口类型 Store 中，如下源码所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// store/store.go</span> <span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>     Id      <span class="token builtin">string</span>   <span class="token string">`json:"id"`</span>      <span class="token comment">// 图书ISBN ID</span>     Name    <span class="token builtin">string</span>   <span class="token string">`json:"name"`</span>    <span class="token comment">// 图书名称</span>     Authors <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token string">`json:"authors"`</span> <span class="token comment">// 图书作者</span>     Press   <span class="token builtin">string</span>   <span class="token string">`json:"press"`</span>   <span class="token comment">// 出版社</span> <span class="token punctuation">}</span>  <span class="token keyword">type</span> Store <span class="token keyword">interface</span> <span class="token punctuation">{</span>     <span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token builtin">error</span>        <span class="token comment">// 创建一个新图书条目</span>     <span class="token function">Update</span><span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token builtin">error</span>        <span class="token comment">// 更新某图书条目</span>     <span class="token function">Get</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Book<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>  <span class="token comment">// 获取某图书信息</span>     <span class="token function">GetAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Book<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>   <span class="token comment">// 获取所有图书信息</span>     <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span>       <span class="token comment">// 删除某图书条目</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们建立了一个对应图书条目的抽象数据类型 Book，以及针对 Book 存取的接口类型 Store。这样，对于想要进行图书数据操作的一方来说，他只需要得到一个满足 Store 接口的实例，就可以实现对图书数据的存储操作了，不用再关心图书数据究竟采用了何种存储方式。这就实现了图书存储操作与底层图书数据存储方式的解耦。而且，这种面向接口编程也是 Go 组合设计哲学的一个重要体现。</p><p>那我们具体如何创建一个满足 Store 接口的实例呢？我们可以参考《设计模式》提供的多种创建型模式，选择一种 Go 风格的工厂模式（创建型模式的一种）来实现满足 Store 接口实例的创建。我们看一下 store/factory 包的源码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// store/factory/factory.go</span> <span class="token keyword">var</span> <span class="token punctuation">(</span>     providersMu sync<span class="token punctuation">.</span>RWMutex     providers   <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>store<span class="token punctuation">.</span>Store<span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token keyword">func</span> <span class="token function">Register</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> p store<span class="token punctuation">.</span>Store<span class="token punctuation">)</span> <span class="token punctuation">{</span>     providersMu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> providersMu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> p <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"store: Register provider is nil"</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> dup <span class="token operator">:=</span> providers<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span> dup <span class="token punctuation">{</span>         <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"store: Register called twice for provider "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span>     <span class="token punctuation">}</span>     providers<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token punctuation">}</span>  <span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>providerName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>store<span class="token punctuation">.</span>Store<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     providersMu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> providers<span class="token punctuation">[</span>providerName<span class="token punctuation">]</span>     providersMu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"store: unknown provider %s"</span><span class="token punctuation">,</span> providerName<span class="token punctuation">)</span>     <span class="token punctuation">}</span>      <span class="token keyword">return</span> p<span class="token punctuation">,</span> <span class="token boolean">nil</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码实际上是效仿了 Go 标准库的 database/sql 包采用的方式，factory 包采用了一个 map 类型数据，对工厂可以“生产”的、满足 Store 接口的实例类型进行管理。factory 包还提供了 Register 函数，让各个实现 Store 接口的类型可以把自己“注册”到工厂中来。</p><p>一旦注册成功，factory 包就可以“生产”出这种满足 Store 接口的类型实例。而依赖 Store 接口的使用方，只需要调用 factory 包的 New 函数，再传入期望使用的图书存储实现的名称，就可以得到对应的类型实例了。</p><p>在项目的 internal/store 目录下，我们还提供了一个基于内存 map 的 Store 接口的实现，我们具体看一下这个实现是怎么自注册到 factory 包中的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// internal/store/memstore.go</span> <span class="token keyword">package</span> store   <span class="token keyword">import</span> <span class="token punctuation">(</span>     mystore <span class="token string">"bookstore/store"</span>     factory <span class="token string">"bookstore/store/factory"</span>     <span class="token string">"sync"</span> <span class="token punctuation">)</span>   <span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     factory<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token string">"mem"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>MemStore<span class="token punctuation">{</span>         books<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>mystore<span class="token punctuation">.</span>Book<span class="token punctuation">)</span><span class="token punctuation">,</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token keyword">type</span> MemStore <span class="token keyword">struct</span> <span class="token punctuation">{</span>     sync<span class="token punctuation">.</span>RWMutex     books <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>mystore<span class="token punctuation">.</span>Book <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 memstore 的代码来看，它是在包的 init 函数中调用 factory 包提供的 Register 函数，把自己的实例以“mem”的名称注册到 factory 中的。这样做有一个好处，依赖 Store 接口进行图书数据管理的一方，只要导入 internal/store 这个包，就可以自动完成注册动作了。</p><p>理解了这个之后，我们再看下面 main 包中，创建图书数据存储模块实例时采用的代码，是不是就豁然开朗了？</p><p>至于 memstore.go 中图书数据存储的具体逻辑，就比较简单了，我这里就不详细分析了，你课后自己阅读一下吧。</p><p>接着，我们再来看看 bookstore 程序的另外一个重要模块：HTTP 服务模块。</p><h2 id="HTTP-服务模块（server）"><a href="#HTTP-服务模块（server）" class="headerlink" title="HTTP 服务模块（server）"></a>HTTP 服务模块（server）</h2><p>HTTP 服务模块的职责是<strong>对外提供 HTTP API 服务，处理来自客户端的各种请求，并通过 Store 接口实例执行针对图书数据的相关操作</strong>。这里，我们抽象处理一个 server 包，这个包中定义了一个 BookStoreServer 类型如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span> <span class="token keyword">type</span> BookStoreServer <span class="token keyword">struct</span> <span class="token punctuation">{</span>     s   store<span class="token punctuation">.</span>Store     srv <span class="token operator">*</span>http<span class="token punctuation">.</span>Server <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，这个类型实质上就是一个标准库的 http.Server，并且组合了来自 store.Store 接口的能力。server 包提供了 NewBookStoreServer 函数，用来创建一个 BookStoreServer 类型实例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span> <span class="token keyword">func</span> <span class="token function">NewBookStoreServer</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> s store<span class="token punctuation">.</span>Store<span class="token punctuation">)</span> <span class="token operator">*</span>BookStoreServer <span class="token punctuation">{</span>     srv <span class="token operator">:=</span> <span class="token operator">&amp;</span>BookStoreServer<span class="token punctuation">{</span>         s<span class="token punctuation">:</span> s<span class="token punctuation">,</span>         srv<span class="token punctuation">:</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>             Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span>         <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token punctuation">}</span>      router <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">NewRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>createBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>updateBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>getBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>getAllBooksHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">)</span>     router<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">,</span> srv<span class="token punctuation">.</span>delBookHandler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Methods</span><span class="token punctuation">(</span><span class="token string">"DELETE"</span><span class="token punctuation">)</span>      srv<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler <span class="token operator">=</span> middleware<span class="token punctuation">.</span><span class="token function">Logging</span><span class="token punctuation">(</span>middleware<span class="token punctuation">.</span><span class="token function">Validating</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> srv <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到函数 NewBookStoreServer 接受两个参数，一个是 HTTP 服务监听的服务地址，另外一个是实现了 store.Store 接口的类型实例。这种函数原型的设计是 Go 语言的一种惯用设计方法，也就是接受一个接口类型参数，返回一个具体类型。返回的具体类型组合了传入的接口类型的能力</p><p>这个时候，和前面预热时实现的简单 http 服务一样，我们还需为 HTTP 服务器设置请求的处理函数。</p><p>由于这个服务请求 URI 的模式字符串比较复杂，标准库 http 包内置的 URI 路径模式匹配器（ServeMux，也称为路由管理器）不能满足我们的需求，因此在这里，我们需要借助一个第三方包 github.com/gorilla/mux 来实现我们的需求。</p><p>在上面代码的第 11 行到第 16 行，我们针对不同 URI 路径模式设置了不同的处理函数。我们以 createBookHandler 和 getBookHandler 为例来看看这些处理函数的实现:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span>  <span class="token keyword">func</span> <span class="token punctuation">(</span>bs <span class="token operator">*</span>BookStoreServer<span class="token punctuation">)</span> <span class="token function">createBookHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      dec <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>      <span class="token keyword">var</span> book store<span class="token punctuation">.</span>Book      <span class="token keyword">if</span> err <span class="token operator">:=</span> dec<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>          http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>        <span class="token keyword">if</span> err <span class="token operator">:=</span> bs<span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>          http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">func</span> <span class="token punctuation">(</span>bs <span class="token operator">*</span>BookStoreServer<span class="token punctuation">)</span> <span class="token function">getBookHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      id<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Vars</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span>      <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>          http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"no id found in request"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token punctuation">}</span>       book<span class="token punctuation">,</span> err <span class="token operator">:=</span> bs<span class="token punctuation">.</span>s<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>     <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>         <span class="token keyword">return</span>     <span class="token punctuation">}</span>      <span class="token function">response</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> book<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token keyword">func</span> <span class="token function">response</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     data<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>     <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>         http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusInternalServerError<span class="token punctuation">)</span>         <span class="token keyword">return</span>     <span class="token punctuation">}</span>     w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span>     w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些处理函数的实现都大同小异，都是先获取 http 请求包体数据，然后通过标准库 json 包将这些数据，解码（decode）为我们需要的 store.Book 结构体实例，再通过 Store 接口对图书数据进行存储操作。如果我们是获取图书数据的请求，那么处理函数将通过 response 函数，把取出的图书数据编码到 http 响应的包体中，并返回给客户端。</p><p>然后，在 NewBookStoreServer 函数实现的尾部，我们还看到了这样一行代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">srv<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler <span class="token operator">=</span> middleware<span class="token punctuation">.</span><span class="token function">Logging</span><span class="token punctuation">(</span>middleware<span class="token punctuation">.</span><span class="token function">Validating</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这行代码的意思是说，我们在 router 的外围包裹了两层 middleware。什么是 middleware 呢？对于我们的上下文来说，这些 middleware 就是一些通用的 http 处理函数。我们看一下这里的两个 middleware，也就是 Logging 与 Validating 函数的实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/middleware/middleware.go</span>  <span class="token keyword">func</span> <span class="token function">Logging</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> http<span class="token punctuation">.</span>Handler <span class="token punctuation">{</span>     <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>         log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recv a %s request from %s"</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> req<span class="token punctuation">.</span>RemoteAddr<span class="token punctuation">)</span>         next<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> req<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token keyword">func</span> <span class="token function">Validating</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> http<span class="token punctuation">.</span>Handler <span class="token punctuation">{</span>     <span class="token keyword">return</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>         contentType <span class="token operator">:=</span> req<span class="token punctuation">.</span>Header<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">)</span>         mediatype<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> mime<span class="token punctuation">.</span><span class="token function">ParseMediaType</span><span class="token punctuation">(</span>contentType<span class="token punctuation">)</span>         <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>             http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>             <span class="token keyword">return</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span> mediatype <span class="token operator">!=</span> <span class="token string">"application/json"</span> <span class="token punctuation">{</span>             http<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"invalid Content-Type"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusUnsupportedMediaType<span class="token punctuation">)</span>             <span class="token keyword">return</span>         <span class="token punctuation">}</span>         next<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> req<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，Logging 函数主要用来输出每个到达的 HTTP 请求的一些概要信息，而 Validating 则会对每个 http 请求的头部进行检查，检查 Content-Type 头字段所表示的媒体类型是否为 application/json。这些通用的 middleware 函数，会被串联到每个真正的处理函数之前，避免我们在每个处理函数中重复实现这些逻辑。</p><p>创建完 BookStoreServer 实例后，我们就可以调用其 ListenAndServe 方法运行这个 http 服务了，显然这个方法的名字是仿效 http.Server 类型的同名方法，我们的实现是这样的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// server/server.go</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>bs <span class="token operator">*</span>BookStoreServer<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> err <span class="token builtin">error</span>     errChan <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">)</span>     <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         err <span class="token operator">=</span> bs<span class="token punctuation">.</span>srv<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         errChan <span class="token operator">&lt;-</span> err     <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">select</span> <span class="token punctuation">{</span>     <span class="token keyword">case</span> err <span class="token operator">=</span> <span class="token operator">&lt;-</span>errChan<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err     <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">return</span> errChan<span class="token punctuation">,</span> <span class="token boolean">nil</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，这个函数把 BookStoreServer 内部的 http.Server 的运行，放置到一个单独的轻量级线程 Goroutine 中。这是因为，http.Server.ListenAndServe 会阻塞代码的继续运行，如果不把它放在单独的 Goroutine 中，后面的代码将无法得到执行。</p><p>为了检测到 http.Server.ListenAndServe 的运行状态，我们再通过一个 channel（位于第 5 行的 errChan），在新创建的 Goroutine 与主 Goroutine 之间建立的通信渠道。通过这个渠道，这样我们能及时得到 http server 的运行状态。</p><h2 id="编译、运行与验证"><a href="#编译、运行与验证" class="headerlink" title="编译、运行与验证"></a>编译、运行与验证</h2><p>到这里，bookstore 项目的大部分重要代码我们都分析了一遍，是时候将程序跑起来看看了。</p><p>不过，因为我们在程序中引入了一个第三方依赖包，所以在构建项目之前，我们需要执行下面这个命令，让 Go 命令自动分析依赖项和版本，并更新 go.mod：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/gorilla/muxgo: found github.com/gorilla/mux <span class="token keyword">in</span> github.com/gorilla/mux v1.8.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完成后，我们就可以按下面的步骤来构建并执行 bookstore 了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build bookstore/cmd/bookstore$./bookstore<span class="token number">2021</span>/10/05 <span class="token number">16</span>:08:36 web server start ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你看到上面这个输出的日志，说明我们的程序启动成功了。</p><p>现在，我们就可以像前面一样使用 curl 命令行工具，模仿客户端向 bookstore 服务发起请求了，比如创建一个新书条目：</p><p><code>$curl -X POST -H "Content-Type:application/json" -d '{"id": "978-7-111-55842-2", "name": "The Go Programming Language", "authors":["Alan A.A.Donovan", "Brian W. Kergnighan"],"press": "Pearson Education"}' localhost:8080/book</code></p><p>此时服务端会输出如下日志，表明我们的 bookstore 服务收到了客户端请求。</p><p><code>2021/10/05 16:09:10 recv a POST request from [::1]:58021</code></p><p>接下来，我们再来获取一下这本书的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$curl</span> -X GET -H <span class="token string">"Content-Type:application/json"</span> localhost:8080/book/978-7-111-55842-2<span class="token punctuation">{</span><span class="token string">"id"</span><span class="token builtin class-name">:</span><span class="token string">"978-7-111-55842-2"</span>,<span class="token string">"name"</span><span class="token builtin class-name">:</span><span class="token string">"The Go Programming Language"</span>,<span class="token string">"authors"</span>:<span class="token punctuation">[</span><span class="token string">"Alan A.A.Donovan"</span>,<span class="token string">"Brian W. Kergnighan"</span><span class="token punctuation">]</span>,<span class="token string">"press"</span><span class="token builtin class-name">:</span><span class="token string">"Pearson Education"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们看到 curl 得到的响应与我们预期的是一致的。</p><p>好了，我们不再进一步验证了，你课后还可以自行编译、执行并验证。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们就完成了我们第一个实战小项目，不知道你感觉如何呢？</p><p>这一讲中，我们带你用 Go 语言构建了一个最简单的 HTTP 服务，以及一个接近真实的图书管理 API 服务。在整个实战小项目的实现过程中，你也能初步学习到 Go 编码时常用的一些惯用法，比如基于接口的组合、类似 database/sql 所使用的惯用创建模式，等等。</p><p>通过这节课的学习，你是否体会到了 Go 语言的魅力了呢？是否察觉到 Go 编码与其他主流语言不同的风格了呢？其实不论你的理解程度有多少，都不重要。只要你能“照猫画虎”地将上面的程序自己编写一遍，构建、运行起来并验证一遍，就算是完美达成这一讲的目标了。</p><p>你在这个过程肯定会有各种各样的问题，但没关系，这些问题会成为你继续向下学习 Go 的动力。毕竟，带着问题的学习，能让你的学习过程更有的放矢、更高效。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入口函数与包初始化：搞清Go程序的执行次序</title>
      <link href="/2022/08/27/ru-kou-han-shu-yu-bao-chu-shi-hua-gao-qing-go-cheng-xu-de-zhi-xing-ci-xu/"/>
      <url>/2022/08/27/ru-kou-han-shu-yu-bao-chu-shi-hua-gao-qing-go-cheng-xu-de-zhi-xing-ci-xu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在刚开始学习 Go 语言的时候，我们可能经常会遇到这样一个问题：一个 Go 项目中有数十个 Go 包，每个包中又有若干常量、变量、各种函数和方法，那 Go 代码究竟是从哪里开始执行的呢？后续的执行顺序又是什么样的呢？</p><p>事实上，了解这门语言编写应用的执行次序，对我们写出结构合理、逻辑清晰的程序大有裨益，无论你用的是归属为哪种编程范式（Paradigm）的编程语言，过程式的、面向对象的、函数式的，或是其他编程范式的，我都建议你深入了解一下。</p><p>所以今天这节课，我就带你来了解一下 Go 程序的执行次序，这样在后续阅读和理解 Go 代码的时候，你就好比拥有了“通往宝藏的地图”，可以直接沿着 Go 代码执行次序这张“地图”去阅读和理解 Go 代码了，不会在庞大的代码库中迷失了。</p><p>Go 程序由一系列 Go 包组成，代码的执行也是在各个包之间跳转。和其他语言一样，Go 也拥有自己的用户层入口：main 函数。这节课我们就从 main 函数入手，逐步展开，最终带你掌握 Go 程序的执行次序。</p><p>那么下面，我们就先来看看 Go 应用的入口函数。</p><p><strong>main.main 函数：Go 应用的入口函数</strong></p><p>Go 语言中有一个特殊的函数：main 包中的 main 函数，也就是 main.main，它是所有 Go 可执行程序的用户层执行逻辑的入口函数。Go 程序在用户层面的执行逻辑，会在这个函数内按照它的调用顺序展开。</p><p>main 函数的函数原型是这样的：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 用户层执行逻辑</span>    <span class="token operator">...</span> <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，main 函数的函数原型非常简单，没有参数也没有返回值。而且，Go 语言要求：可执行程序的 main 包必须定义 main 函数，否则 Go 编译器会报错。在启动了多个 Goroutine（Go 语言的轻量级用户线程，后面我们会详细讲解）的 Go 应用中，main.main 函数将在 Go 应用的主 Goroutine 中执行。</p><p>不过很有意思的是，在多 Goroutine 的 Go 应用中，相较于 main.main 作为 Go 应用的入口，main.main 函数返回的意义其实更大，因为 main 函数返回就意味着整个 Go 程序的终结，而且你也不用管这个时候是否还有其他子 Goroutine 正在执行。</p><p>另外还值得我们注意的是，除了 main 包外，其他包也可以拥有自己的名为 main 的函数或方法。但按照 Go 的可见性规则（小写字母开头的标识符为非导出标识符），非 main 包中自定义的 main 函数仅限于包内使用，就像下面代码这样，这是一段在非 main 包中定义 main 函数的代码片段：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> pkg1<span class="token keyword">import</span> <span class="token string">"fmt"</span>​<span class="token keyword">func</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main func for pkg1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这里 main 函数就主要是用来在包 pkg1 内部使用的，它是没法在包外使用的。</p><p>好，现在我们已经了解了 Go 应用的入口函数 main.main 的特性。<strong>不过对于 main 包的 main 函数来说，你还需要明确一点，就是它虽然是用户层逻辑的入口函数，但它却不一定是用户层第一个被执行的函数。</strong></p><p><strong>这是为什么呢？这跟 Go 语言的另一个函数 init 有关。</strong></p><p>除了前面讲过的 main.main 函数之外，Go 语言还有一个特殊函数，它就是用于进行包初始化的 init 函数了。</p><p>和 main.main 函数一样，init 函数也是一个无参数无返回值的函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 包初始化逻辑</span>    <span class="token operator">...</span> <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那我们现在回到前面这个“main 函数不一定是用户层第一个被执行的函数”的问题，其实就是因为，如果 main 包依赖的包中定义了 init 函数，或者是 main 包自身定义了 init 函数，那么 Go 程序在这个包初始化的时候，就会自动调用它的 init 函数，因此这些 init 函数的执行就都会发生在 main 函数之前。</p><p>不过对于 init 函数来说，我们还需要注意一点，就是在 Go 程序中我们不能手工显式地调用 init，否则就会收到编译错误，就像下面这个示例，它表示的手工显式调用 init 函数的错误做法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main​<span class="token keyword">import</span> <span class="token string">"fmt"</span>​<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"init invoked"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，在构建并运行上面这些示例代码之后，Go 编译器会报下面这个错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> run call_init.go ./call_init.go:10:2: undefined: init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，Go 包可以拥有不止一个 init 函数，每个组成 Go 包的 Go 源文件中，也可以定义多个 init 函数。</p><p>所以说，在初始化 Go 包时，Go 会按照一定的次序，逐一、顺序地调用这个包的 init 函数。一般来说，先传递给 Go 编译器的源文件中的 init 函数，会先被执行；而同一个源文件中的多个 init 函数，会按声明顺序依次执行。</p><p>那么，现在我们就知晓了 main.main 函数可能并不是第一个被执行的函数的原因了。所以，当我们要在 main.main 函数执行之前，执行一些函数或语句的时候，我们只需要将它放入 init 函数中就可以了。</p><p>了解了这两个函数的执行顺序之后，我们现在就来整体地看看，一个 Go 包的初始化是以何种次序和逻辑进行的。</p><h1 id="Go-包的初始化次序"><a href="#Go-包的初始化次序" class="headerlink" title="Go 包的初始化次序"></a>Go 包的初始化次序</h1><p>我们从程序逻辑结构角度来看，Go 包是程序逻辑封装的基本单元，每个包都可以理解为是一个“自治”的、封装良好的、对外部暴露有限接口的基本单元。一个 Go 程序就是由一组包组成的，程序的初始化就是这些包的初始化。每个 Go 包还会有自己的依赖包、常量、变量、init 函数（其中 main 包有 main 函数）等</p><p>在这里你要注意：<strong>我们在阅读和理解代码的时候，需要知道这些元素在在程序初始化过程中的初始化顺序，这样便于我们确定在某一行代码处这些元素的当前状态。</strong></p><p>下面，我们就通过一张流程图，来了解学习下 Go 包的初始化次序：</p><p><img src="https://static001.geekbang.org/resource/image/e4/0b/e4ddb702876f4f2a0880e4353a390d0b.jpg?wh=1920x1047"></p><p>这里，我们来看看具体的初始化步骤。</p><p>首先，main 包依赖 pkg1 和 pkg4 两个包，所以第一步，Go 会根据包导入的顺序，先去初始化 main 包的第一个依赖包 pkg1。</p><p>第二步，Go 在进行包初始化的过程中，会采用“深度优先”的原则，递归初始化各个包的依赖包。在上图里，pkg1 包依赖 pkg2 包，pkg2 包依赖 pkg3 包，pkg3 没有依赖包，于是 Go 在 pkg3 包中按照“常量 -&gt; 变量 -&gt; init 函数”的顺序先对 pkg3 包进行初始化；</p><p>紧接着，在 pkg3 包初始化完毕后，Go 会回到 pkg2 包并对 pkg2 包进行初始化，接下来再回到 pkg1 包并对 pkg1 包进行初始化。在调用完 pkg1 包的 init 函数后，Go 就完成了 main 包的第一个依赖包 pkg1 的初始化。</p><p>接下来，Go 会初始化 main 包的第二个依赖包 pkg4，pkg4 包的初始化过程与 pkg1 包类似，也是先初始化它的依赖包 pkg5，然后再初始化自身；</p><p>然后，当 Go 初始化完 pkg4 包后也就完成了对 main 包所有依赖包的初始化，接下来初始化 main 包自身。</p><p>最后，在 main 包中，Go 同样会按照“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化，执行完这些初始化工作后才正式进入程序的入口函数 main 函数。</p><p>现在，我们可以通过一段代码示例来验证一下 Go 程序启动后，Go 包的初始化次序是否是正确的，示例程序的结构如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">prog-init-order├── go.mod├── main.go├── pkg1│   └── pkg1.go├── pkg2│   └── pkg2.go└── pkg3    └── pkg3.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们设定的各个包的依赖关系如下：</p><ul><li><p>main 包依赖 pkg1 包和 pkg2 包；</p></li><li><p>pkg1 包和 pkg2 包都依赖 pkg3 包。</p></li></ul><p>这里我只列出了 main 包的代码，pkg1、pkg2 和 pkg3 包的代码与 main 包都是类似的，你可以自己尝试去列一下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main​<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>​    <span class="token boolean">_</span> <span class="token string">"github.com/bigwhite/prog-init-order/pkg1"</span>    <span class="token boolean">_</span> <span class="token string">"github.com/bigwhite/prog-init-order/pkg2"</span><span class="token punctuation">)</span>​<span class="token keyword">var</span> <span class="token punctuation">(</span>    <span class="token boolean">_</span>  <span class="token operator">=</span> <span class="token function">constInitCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    v1 <span class="token operator">=</span> <span class="token function">variableInit</span><span class="token punctuation">(</span><span class="token string">"v1"</span><span class="token punctuation">)</span>    v2 <span class="token operator">=</span> <span class="token function">variableInit</span><span class="token punctuation">(</span><span class="token string">"v2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>​<span class="token keyword">const</span> <span class="token punctuation">(</span>    c1 <span class="token operator">=</span> <span class="token string">"c1"</span>    c2 <span class="token operator">=</span> <span class="token string">"c2"</span><span class="token punctuation">)</span>​<span class="token keyword">func</span> <span class="token function">constInitCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c1 <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: const c1 has been initialized"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> c2 <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: const c2 has been initialized"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">variableInit</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"main: var %s has been initialized\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    <span class="token keyword">return</span> name<span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: first init func invoked"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main: second init func invoked"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>​<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// do nothing</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，在 main 包中其实并没有使用 pkg1 和 pkg2 中的函数或方法，而是直接通过空导入的方式“触发”pkg1 包和 pkg2 包的初始化（pkg2 包也是通过空导入的方式依赖 pkg3 包的），下面是这个程序的运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> run main.gopkg3: const c has been initializedpkg3: var <span class="token function">v</span> has been initializedpkg3: init func invokedpkg1: const c has been initializedpkg1: var <span class="token function">v</span> has been initializedpkg1: init func invokedpkg2: const c has been initializedpkg2: var <span class="token function">v</span> has been initializedpkg2: init func invokedmain: const c1 has been initializedmain: const c2 has been initializedmain: var v1 has been initializedmain: var v2 has been initializedmain: first init func invokedmain: second init func invoked<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你看，正如我们预期的那样，Go 运行时是按照“pkg3 -&gt; pkg1 -&gt; pkg2 -&gt; main”的顺序，来对 Go 程序的各个包进行初始化的，而在包内，则是以“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化。此外，main 包的两个 init 函数，会按照在源文件 main.go 中的出现次序进行调用。</p><p>还有一点，pkg1 包和 pkg2 包都依赖 pkg3 包，但根据 Go 语言规范，一个被多个包依赖的包仅会初始化一次，因此这里的 pkg3 包仅会被初始化了一次。</p><p>所以简而言之，记住 Go 包的初始化次序并不难，你只需要记住这三点就可以了：</p><ul><li><p>依赖包按“深度优先”的次序进行初始化；</p></li><li><p>每个包内按以“常量 -&gt; 变量 -&gt; init 函数”的顺序进行初始化；</p></li><li><p>包内的多个 init 函数按出现次序进行自动调用。</p></li></ul><p>到这里，我们已经知道了 Go 程序中包的初始化次序，也了解了每个包中常量、变量以及 init 函数的运行次序，以及 init 函数作为包初始化函数的一些特性。</p><p>搞完了这些最主线的内容之后，不知你有没有发现，我们好像还忘记了一件事：我们好像忘记分析 init 函数的用途了？别急，我们现在就把这落下的功课补上，看看作为 Go 包初始化函数的 init 函数，在日常 Go 语言开发中怎么来使用呢？</p><h1 id="init-函数的用途"><a href="#init-函数的用途" class="headerlink" title="init 函数的用途"></a>init 函数的用途</h1><p>其实，init 函数的这些常用用途，与 init 函数在 Go 包初始化过程中的次序密不可分。我们前面讲过，Go 包初始化时，init 函数的初始化次序在变量之后，这给了开发人员在 init 函数中对包级变量进行进一步检查与操作的机会。</p><p><strong>这里我们先来看 init 函数的第一个常用用途：重置包级变量值。</strong></p><p>init 函数就好比 Go 包真正投入使用之前唯一的“质检员”，负责对包内部以及暴露到外部的包级数据（主要是包级变量）的初始状态进行检查。在 Go 标准库中，我们能发现很多 init 函数被用于检查包级变量的初始状态的例子，标准库 flag 包对 init 函数的使用就是其中的一个，这里我们简单来分析一下。</p><p>flag 包定义了一个导出的包级变量 CommandLine，如果用户没有通过 flag.NewFlagSet 创建新的代表命令行标志集合的实例，那么 CommandLine 就会作为 flag 包各种导出函数背后，默认的代表命令行标志集合的实例。</p><p>而在 flag 包初始化的时候，由于 init 函数初始化次序在包级变量之后，因此包级变量 CommandLine 会在 init 函数之前被初始化了，你可以看一下下面的代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> CommandLine <span class="token operator">=</span> <span class="token function">NewFlagSet</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ExitOnError<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">NewFlagSet</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> errorHandling ErrorHandling<span class="token punctuation">)</span> <span class="token operator">*</span>FlagSet <span class="token punctuation">{</span>    f <span class="token operator">:=</span> <span class="token operator">&amp;</span>FlagSet<span class="token punctuation">{</span>        name<span class="token punctuation">:</span>          name<span class="token punctuation">,</span>        errorHandling<span class="token punctuation">:</span> errorHandling<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    f<span class="token punctuation">.</span>Usage <span class="token operator">=</span> f<span class="token punctuation">.</span>defaultUsage    <span class="token keyword">return</span> f<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>FlagSet<span class="token punctuation">)</span> <span class="token function">defaultUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> f<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Usage:\n"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Usage of %s:\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    f<span class="token punctuation">.</span><span class="token function">PrintDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，在通过 NewFlagSet 创建 CommandLine 变量绑定的 FlagSet 类型实例时，CommandLine 的 Usage 字段被赋值为 defaultUsage。</p><p>也就是说，如果保持现状，那么使用 flag 包默认 CommandLine 的用户就无法自定义 usage 的输出了。于是，flag 包在 init 函数中重置了 CommandLine 的 Usage 字段</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    CommandLine<span class="token punctuation">.</span>Usage <span class="token operator">=</span> commandLineUsage <span class="token comment">// 重置CommandLine的Usage字段</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">commandLineUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">Usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> Usage <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>CommandLine<span class="token punctuation">.</span><span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Usage of %s:\n"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token function">PrintDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候我们会发现，CommandLine 的 Usage 字段，设置为了一个 flag 包内的未导出函数 commandLineUsage，后者则直接使用了 flag 包的另外一个导出包变量 Usage。这样，就可以通过 init 函数，将 CommandLine 与包变量 Usage 关联在一起了。</p><p>然后，当用户将自定义的 usage 赋值给了 flag.Usage 后，就相当于改变了默认代表命令行标志集合的 CommandLine 变量的 Usage。这样当 flag 包完成初始化后，CommandLine 变量便处于一个合理可用的状态了。</p><p><strong>init 函数的第二个常用用途，是实现对包级变量的复杂初始化。</strong></p><p>有些包级变量需要一个比较复杂的初始化过程，有些时候，使用它的类型零值（每个 Go 类型都具有一个零值定义）或通过简单初始化表达式不能满足业务逻辑要求，而 init 函数则非常适合完成此项工作，标准库 http 包中就有这样一个典型示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    http2VerboseLogs    <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span>    http2logFrameWrites <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span>    http2logFrameReads  <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span>    http2inTests        <span class="token builtin">bool</span> <span class="token comment">// 初始化时默认值为false</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    e <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"GODEBUG"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">"http2debug=1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        http2VerboseLogs <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2VerboseLogs的值进行重置</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token string">"http2debug=2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        http2VerboseLogs <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2VerboseLogs的值进行重置</span>        http2logFrameWrites <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2logFrameWrites的值进行重置</span>        http2logFrameReads <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 在init中对http2logFrameReads的值进行重置</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，标准库 http 包定义了一系列布尔类型的特性开关变量，它们默认处于关闭状态（即值为 false），但我们可以通过 GODEBUG 环境变量的值，开启相关特性开关。</p><p>可是这样一来，简单地将这些变量初始化为类型零值，就不能满足要求了，所以 http 包在 init 函数中，就根据环境变量 GODEBUG 的值，对这些包级开关变量进行了复杂的初始化，从而保证了这些开关变量在 http 包完成初始化后，可以处于合理状态。</p><p><strong>说完了这个，我们现在来讲 init 函数的第三个常用用途：在 init 函数中实现“注册模式”。</strong></p><p>为了让你更好地理解，首先我们来看一段使用 lib/pq 包访问 PostgreSQL 数据库的代码示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"database/sql"</span>    <span class="token boolean">_</span> <span class="token string">"github.com/lib/pq"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    db<span class="token punctuation">,</span> err <span class="token operator">:=</span> sql<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"postgres"</span><span class="token punctuation">,</span> <span class="token string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    age <span class="token operator">:=</span> <span class="token number">21</span>    rows<span class="token punctuation">,</span> err <span class="token operator">:=</span> db<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token string">"SELECT name FROM users WHERE age = $1"</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，这是一段“神奇”的代码，你可以看到示例代码是以空导入的方式导入 lib/pq 包的，main 函数中没有使用 pq 包的任何变量、函数或方法，这样就实现了对 PostgreSQL 数据库的访问。而这一切的奥秘，全在 pq 包的 init 函数中：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sql<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span><span class="token string">"postgres"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Driver<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个奥秘就在，我们其实是利用了用空导入的方式导入 lib/pq 包时产生的一个“副作用”，也就是 lib/pq 包作为 main 包的依赖包，它的 init 函数会在 pq 包初始化的时候得以执行。</p><p>从上面代码中，我们可以看到在 pq 包的 init 函数中，pq 包将自己实现的 sql 驱动注册到了 sql 包中。这样只要应用层代码在 Open 数据库的时候，传入驱动的名字（这里是“postgres”)，那么通过 sql.Open 函数，返回的数据库实例句柄对数据库进行的操作，实际上调用的都是 pq 包中相应的驱动实现。</p><p>实际上，这种通过在 init 函数中注册自己的实现的模式，就有效降低了 Go 包对外的直接暴露，尤其是包级变量的暴露，从而避免了外部通过包级变量对包状态的改动。</p><p>另外，从标准库 database/sql 包的角度来看，这种“注册模式”实质是一种工厂设计模式的实现，sql.Open 函数就是这个模式中的工厂方法，它根据外部传入的驱动名称“生产”出不同类别的数据库实例句柄。</p><p>这种“注册模式”在标准库的其他包中也有广泛应用，比如说，使用标准库 image 包获取各种格式图片的宽和高：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"image"</span>    <span class="token boolean">_</span> <span class="token string">"image/gif"</span> <span class="token comment">// 以空导入方式注入gif图片格式驱动</span>    <span class="token boolean">_</span> <span class="token string">"image/jpeg"</span> <span class="token comment">// 以空导入方式注入jpeg图片格式驱动</span>    <span class="token boolean">_</span> <span class="token string">"image/png"</span> <span class="token comment">// 以空导入方式注入png图片格式驱动</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 支持png, jpeg, gif</span>    width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">imageSize</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 获取传入的图片文件的宽与高</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"get image size error:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"image size: [%d, %d]\n"</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">imageSize</span><span class="token punctuation">(</span>imageFile <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>imageFile<span class="token punctuation">)</span> <span class="token comment">// 打开图文文件</span>    <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    img<span class="token punctuation">,</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> image<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token comment">// 对文件进行解码，得到图片实例</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> err    <span class="token punctuation">}</span>    b <span class="token operator">:=</span> img<span class="token punctuation">.</span><span class="token function">Bounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回图片区域</span>    <span class="token keyword">return</span> b<span class="token punctuation">.</span>Max<span class="token punctuation">.</span>X<span class="token punctuation">,</span> b<span class="token punctuation">.</span>Max<span class="token punctuation">.</span>Y<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，上面这个示例程序支持 png、jpeg、gif 三种格式的图片，而达成这一目标的原因，正是 image/png、image/jpeg 和 image/gif 包都在各自的 init 函数中，将自己“注册”到 image 的支持格式列表中了，你可以看看下面这个代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/image/png/reader.go</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span><span class="token function">RegisterFormat</span><span class="token punctuation">(</span><span class="token string">"png"</span><span class="token punctuation">,</span> pngHeader<span class="token punctuation">,</span> Decode<span class="token punctuation">,</span> DecodeConfig<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// $GOROOT/src/image/jpeg/reader.go</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span><span class="token function">RegisterFormat</span><span class="token punctuation">(</span><span class="token string">"jpeg"</span><span class="token punctuation">,</span> <span class="token string">"\xff\xd8"</span><span class="token punctuation">,</span> Decode<span class="token punctuation">,</span> DecodeConfig<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// $GOROOT/src/image/gif/reader.go</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    image<span class="token punctuation">.</span><span class="token function">RegisterFormat</span><span class="token punctuation">(</span><span class="token string">"gif"</span><span class="token punctuation">,</span> <span class="token string">"GIF8?a"</span><span class="token punctuation">,</span> Decode<span class="token punctuation">,</span> DecodeConfig<span class="token punctuation">)</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，现在我们了解了 init 函数的常见用途。init 函数之所以可以胜任这些工作，恰恰是因为它在 Go 应用初始化次序中的特殊“位次”，也就是 main 函数之前，常量和变量初始化之后。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在这一节课中，我们一起了解了 Go 应用的用户层入口函数 main.main、包初始化函数 init，还有 Go 程序包的初始化次序和包内各种语法元素的初始化次序。</p><p>其中，你需要重点关注 init 函数具备的几种行为特征：</p><ul><li><p>执行顺位排在包内其他语法元素的后面；</p></li><li><p>每个 init 函数在整个 Go 程序生命周期内仅会被执行一次；</p></li><li><p>init 函数是顺序执行的，只有当一个 init 函数执行完毕后，才会去执行下一个 init 函数。</p></li></ul><p>基于上面这些特征，init 函数十分适合做一些包级数据初始化工作以及包级数据初始状态的检查工作，我们也通过实例讲解了 init 函数的这些常见用途。</p><p>最后，大多 Go 程序都是并发程序，程序会启动多个 Goroutine 并发执行程序逻辑，这里你一定要注意主 Goroutine 的优雅退出，也就是主 Goroutine 要根据实际情况来决定，是否要等待其他子 Goroutine 做完清理收尾工作退出后再行退出。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>今天我给你留了一个思考题：当 init 函数在检查包数据初始状态时遇到失败或错误的情况，我们该如何处理呢？</p><p>分情况而定</p><ol><li>初始化失败的是必要的数据 panic处理 结束进程</li><li>初始化失败的是对业务没影响，可成功可失败的 输出warn或error日志 方便定位</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day02</title>
      <link href="/2022/08/26/yi-yuan-ji-lu-day02/"/>
      <url>/2022/08/26/yi-yuan-ji-lu-day02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是妈妈住院的第四天，昨天做完手术后，妈妈十分难受，疼的一直叫，而且睡不着觉。昨天晚上我留在了医院，一直没有睡着，因为要照顾妈妈，而且还很担心。但是在医院的这几天虽然吃饭的时间不是很固定，而且有时候会头疼。</p><p>希望妈妈早日康复！！！</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建模式：Go Module的6类常规操作</title>
      <link href="/2022/08/24/gou-jian-mo-shi-go-module-de-6-lei-chang-gui-cao-zuo/"/>
      <url>/2022/08/24/gou-jian-mo-shi-go-module-de-6-lei-chang-gui-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过上一节课的讲解，我们掌握了 Go Module 构建模式的基本概念和工作原理，也初步学会了如何通过 go mod 命令，将一个 Go 项目转变为一个 Go Module，并通过 Go Module 构建模式进行构建。</p><p>但是，围绕一个 Go Module，Go 开发人员每天要执行很多 Go 命令对其进行维护。这些维护又是怎么进行的呢？</p><p>具体来说，维护 Go Module 无非就是对 Go Module 依赖包的管理。但在具体工作中还有很多情况，我们接下来会拆分成六个场景，层层深入给你分析。可以说，学好这些是每个 Go 开发人员成长的必经之路。</p><p>我们首先来看一下日常进行 Go 应用开发时遇到的最为频繁的一个场景：<strong>为当前项目添加一个依赖包。</strong></p><h1 id="为当前-module-添加一个依赖"><a href="#为当前-module-添加一个依赖" class="headerlink" title="为当前 module 添加一个依赖"></a>为当前 module 添加一个依赖</h1><p>在一个项目的初始阶段，我们会经常为项目引入第三方包，并借助这些包完成特定功能。即便是项目进入了稳定阶段，随着项目的演进，我们偶尔还需要在代码中引入新的第三方包。</p><p>那么我们如何为一个 Go Module 添加一个新的依赖包呢？</p><p>我们还是以上一节课中讲过的 module-mode 项目为例。如果我们要为这个项目增加一个新依赖：github.com/google/uuid，那需要怎么做呢？</p><p>我们首先会更新源码，就像下面代码中这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"github.com/google/uuid"</span>  <span class="token string">"github.com/sirupsen/logrus"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">NewString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新源码中，我们通过 import 语句导入了 github.com/google/uuid，并在 main 函数中调用了 uuid 包的函数 NewString。此时，如果我们直接构建这个 module，我们会得到一个错误提示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> buildmain.go:4:2: no required module provides package github.com/google/uuid<span class="token punctuation">;</span> to <span class="token function">add</span> it:  go get github.com/google/uuid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Go 编译器提示我们，go.mod 里的 require 段中，没有哪个 module 提供了 github.com/google/uuid 包，如果我们要增加这个依赖，可以手动执行 go get 命令。那我们就来按照提示手工执行一下这个命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/google/uuidgo: downloading github.com/google/uuid v1.3.0go get: added github.com/google/uuid v1.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你会发现，go get 命令将我们新增的依赖包下载到了本地 module 缓存里，并在 go.mod 文件的 require 段中新增了一行内容：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">require <span class="token punctuation">(</span>  github<span class="token punctuation">.</span>com<span class="token operator">/</span>google<span class="token operator">/</span>uuid v1<span class="token punctuation">.</span><span class="token number">3.0</span> <span class="token comment">//新增的依赖</span>  github<span class="token punctuation">.</span>com<span class="token operator">/</span>sirupsen<span class="token operator">/</span>logrus v1<span class="token punctuation">.</span><span class="token number">8.1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这新增的一行表明，我们当前项目依赖的是 uuid 的 v1.3.0 版本。我们也可以使用 go mod tidy 命令，在执行构建前自动分析源码中的依赖变化，识别新增依赖项并下载它们：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/google/uuidgo: found github.com/google/uuid <span class="token keyword">in</span> github.com/google/uuid v1.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于我们这个例子而言，手工执行 go get 新增依赖项，和执行 go mod tidy 自动分析和下载依赖项的最终效果，是等价的。但对于复杂的项目变更而言，逐一手工添加依赖项显然很没有效率，go mod tidy 是更佳的选择。</p><p>到这里，我们已经了解了怎么为当前的 module 添加一个新的依赖。但是在日常开发场景中，我们需要对依赖的版本进行更改。那这又要怎么做呢？下面我们就来看看下面升、降级修改依赖版本的场景。</p><h1 id="升级-降级依赖的版本"><a href="#升级-降级依赖的版本" class="headerlink" title="升级 / 降级依赖的版本"></a>升级 / 降级依赖的版本</h1><p>我们先以对依赖的版本进行降级为例，分析一下。</p><p>在实际开发工作中，如果我们认为 Go 命令自动帮我们确定的某个依赖的版本存在一些问题，比如，引入了不必要复杂性导致可靠性下降、性能回退等等，我们可以手工将它降级为之前发布的某个兼容版本。</p><p>那这个操作依赖于什么原理呢？</p><p>答案就是我们上一节课讲过“语义导入版本”机制。我们再来简单复习一下，Go Module 的版本号采用了语义版本规范，也就是版本号使用 vX.Y.Z 的格式。其中 X 是主版本号，Y 为次版本号 (minor)，Z 为补丁版本号 (patch)。主版本号相同的两个版本，较新的版本是兼容旧版本的。如果主版本号不同，那么两个版本是不兼容的。</p><p>有了语义版本号作为基础和前提，我们就可以从容地手工对依赖的版本进行升降级了，Go 命令也可以根据版本兼容性，自动选择出合适的依赖版本了。</p><p>我们还是以上面提到过的 logrus 为例，logrus 现在就存在着多个发布版本，我们可以通过下面命令来进行查询：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> list -m -versions github.com/sirupsen/logrusgithub.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 v0.3.0 v0.4.0 v0.4.1 v0.5.0 v0.5.1 v0.6.0 v0.6.1 v0.6.2 v0.6.3 v0.6.4 v0.6.5 v0.6.6 v0.7.0 v0.7.1 v0.7.2 v0.7.3 v0.8.0 v0.8.1 v0.8.2 v0.8.3 v0.8.4 v0.8.5 v0.8.6 v0.8.7 v0.9.0 v0.10.0 v0.11.0 v0.11.1 v0.11.2 v0.11.3 v0.11.4 v0.11.5 v1.0.0 v1.0.1 v1.0.3 v1.0.4 v1.0.5 v1.0.6 v1.1.0 v1.1.1 v1.2.0 v1.3.0 v1.4.0 v1.4.1 v1.4.2 v1.5.0 v1.6.0 v1.7.0 v1.7.1 v1.8.0 v1.8.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在这个例子中，基于初始状态执行的 go mod tidy 命令，帮我们选择了 logrus 的最新发布版本 v1.8.1。如果你觉得这个版本存在某些问题，想将 logrus 版本降至某个之前发布的兼容版本，比如 v1.7.0，那么我们可以在项目的 module 根目录下，执行带有版本号的 go get 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/sirupsen/logrus@v1.7.0go: downloading github.com/sirupsen/logrus v1.7.0go get: downgraded github.com/sirupsen/logrus v1.8.1 <span class="token operator">=</span><span class="token operator">&gt;</span> v1.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从这个执行输出的结果，我们可以看到，go get 命令下载了 logrus v1.7.0 版本，并将 go.mod 中对 logrus 的依赖版本从 v1.8.1 降至 v1.7.0。</p><p><strong>当然我们也可以使用万能命令 go mod tidy 来帮助我们降级，但前提是首先要用 go mod edit 命令，明确告知我们要依赖 v1.7.0 版本，而不是 v1.8.1，这个执行步骤是这样的</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod edit -require<span class="token operator">=</span>github.com/sirupsen/logrus@v1.7.0<span class="token variable">$go</span> mod tidy       go: downloading github.com/sirupsen/logrus v1.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>降级后，我们再假设 logrus v1.7.1 版本是一个安全补丁升级，修复了一个严重的安全漏洞，而且我们必须使用这个安全补丁版本，这就意味着我们需要将 logrus 依赖从 v1.7.0 升级到 v1.7.1。</p><p>我们可以使用与降级同样的步骤来完成升级，这里我只列出了使用 go get 实现依赖版本升级的命令和输出结果，你自己动手试一下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/sirupsen/logrus@v1.7.1go: downloading github.com/sirupsen/logrus v1.7.1go get: upgraded github.com/sirupsen/logrus v1.7.0 <span class="token operator">=</span><span class="token operator">&gt;</span> v1.7.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>好了，到这里你就学会了如何对项目依赖包的版本进行升降级了。</p><p>但是你可能会发现一个问题，在前面的例子中，Go Module 的依赖的主版本号都是 1。根据我们上节课中学习的语义导入版本的规范，在 Go Module 构建模式下，当依赖的主版本号为 0 或 1 的时候，我们在 Go 源码中导入依赖包，不需要在包的导入路径上增加版本号，也就是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">import</span> github.com/user/repo/v0 等价于 <span class="token function">import</span> github.com/user/repo<span class="token function">import</span> github.com/user/repo/v1 等价于 <span class="token function">import</span> github.com/user/repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是，如果我们要依赖的 module 的主版本号大于 1，这又要怎么办呢？接着我们就来看看这个场景下该如何去做。</p><h1 id="添加一个主版本号大于-1-的依赖"><a href="#添加一个主版本号大于-1-的依赖" class="headerlink" title="添加一个主版本号大于 1 的依赖"></a>添加一个主版本号大于 1 的依赖</h1><p>这里，我们还是先来回顾一下，上节课我们讲的语义版本规则中对主版本号大于 1 情况有没有相应的说明。</p><p>有的。语义导入版本机制有一个原则：如果新旧版本的包使用相同的导入路径，那么新包与旧包是兼容的。也就是说，如果新旧两个包不兼容，那么我们就应该采用不同的导入路径。</p><p>按照语义版本规范，如果我们要为项目引入主版本号大于 1 的依赖，比如 v2.0.0，那么由于这个版本与 v1、v0 开头的包版本都不兼容，我们在导入 v2.0.0 包时，不能再直接使用 github.com/user/repo，而要使用像下面代码中那样不同的包导入路径：</p><p><code>import github.com/user/repo/v2/xxx</code></p><p>也就是说，如果我们要为 Go 项目添加主版本号大于 1 的依赖，我们就需要使用“语义导入版本”机制，在声明它的导入路径的基础上，加上版本号信息。我们以“向 module-mode 项目添加 github.com/go-redis/redis 依赖包的 v7 版本”为例，看看添加步骤。</p><p>首先，我们在源码中，以空导入的方式导入 v7 版本的 github.com/go-redis/redis 包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token boolean">_</span> <span class="token string">"github.com/go-redis/redis/v7"</span> <span class="token comment">// “_”为空导入</span>  <span class="token string">"github.com/google/uuid"</span>  <span class="token string">"github.com/sirupsen/logrus"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">NewString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>空导入：只执行依赖包的初始化（包括常量、变量的初始化以及init函数的执行），而不在包外显式使用包内的任何语法元素；在实践中，空导入，通常意味着，我们期望依赖包的init函数得以执行，其中有我们需要的逻辑；</strong></p><p>接下来的步骤就与添加兼容依赖一样，我们通过 go get 获取 redis 的 v7 版本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/go-redis/redis/v7go: downloading github.com/go-redis/redis/v7 v7.4.1go: downloading github.com/go-redis/redis v6.15.9+incompatiblego get: added github.com/go-redis/redis/v7 v7.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到，go get 为我们选择了 go-redis v7 版本下当前的最新版本 v7.4.1。</p><p>不过呢，这里说的是为项目添加一个主版本号大于 1 的依赖的步骤。有些时候，出于要使用依赖包最新功能特性等原因，我们可能需要将某个依赖的版本升级为其不兼容版本，也就是主版本号不同的版本，这又该怎么做呢？</p><p>我们还以 go-redis/redis 这个依赖为例，将这个依赖从 v7 版本升级到最新的 v8 版本看看。</p><h1 id="升级依赖版本到一个不兼容版本"><a href="#升级依赖版本到一个不兼容版本" class="headerlink" title="升级依赖版本到一个不兼容版本"></a>升级依赖版本到一个不兼容版本</h1><p>我们前面说了，按照语义导入版本的原则，不同主版本的包的导入路径是不同的。所以，同样地，我们这里也需要先将代码中 redis 包导入路径中的版本号改为 v8：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token boolean">_</span> <span class="token string">"github.com/go-redis/redis/v8"</span>  <span class="token string">"github.com/google/uuid"</span>  <span class="token string">"github.com/sirupsen/logrus"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们再通过 go get 来获取 v8 版本的依赖包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> get github.com/go-redis/redis/v8go: downloading github.com/go-redis/redis/v8 v8.11.1go: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5fgo: downloading github.com/cespare/xxhash/v2 v2.1.1go get: added github.com/go-redis/redis/v8 v8.11.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们就完成了向一个不兼容依赖版本的升级。是不是很简单啊！</p><p>但是项目继续演化到一个阶段的时候，我们可能还需要移除对之前某个包的依赖。</p><h1 id="移除一个依赖"><a href="#移除一个依赖" class="headerlink" title="移除一个依赖"></a>移除一个依赖</h1><p>我们还是看前面 go-redis/redis 示例，如果我们这个时候不需要再依赖 go-redis/redis 了，你会怎么做呢？</p><p>你可能会删除掉代码中对 redis 的空导入这一行，之后再利用 go build 命令成功地构建这个项目。</p><p>但你会发现，与添加一个依赖时 Go 命令给出友好提示不同，这次 go build 没有给出任何关于项目已经将 go-redis/redis 删除的提示，并且 go.mod 里 require 段中的 go-redis/redis/v8 的依赖依旧存在着。</p><p>我们再通过 go list 命令列出当前 module 的所有依赖，你也会发现 go-redis/redis/v8 仍出现在结果中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> list -m allgithub.com/bigwhite/module-modegithub.com/cespare/xxhash/v2 v2.1.1github.com/davecgh/go-spew v1.1.1<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.github.com/go-redis/redis/v8 v8.11.1<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.gopkg.in/yaml.v2 v2.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是怎么回事呢？</p><p>其实，要想彻底从项目中移除 go.mod 中的依赖项，仅从源码中删除对依赖项的导入语句还不够。这是因为如果源码满足成功构建的条件，go build 命令是不会“多管闲事”地清理 go.mod 中多余的依赖项的。</p><p>那正确的做法是怎样的呢？我们还得用 go mod tidy 命令，将这个依赖项彻底从 Go Module 构建上下文中清除掉。go mod tidy 会自动分析源码依赖，而且将不再使用的依赖从 go.mod 和 go.sum 中移除。</p><p>到这里，其实我们已经分析了 Go Module 依赖包管理的 5 个常见情况了，但其实还有一种特殊情况，需要我们借用 vendor 机制。</p><h1 id="特殊情况：使用-vendor"><a href="#特殊情况：使用-vendor" class="headerlink" title="特殊情况：使用 vendor"></a>特殊情况：使用 vendor</h1><p>你可能会感到有点奇怪，为什么 Go Module 的维护，还有要用 vendor 的情况？</p><p>其实，vendor 机制虽然诞生于 GOPATH 构建模式主导的年代，但在 Go Module 构建模式下，它依旧被保留了下来，并且成为了 Go Module 构建机制的一个很好的补充。特别是在一些不方便访问外部网络，并且对 Go 应用构建性能敏感的环境，比如在一些内部的持续集成或持续交付环境（CI/CD）中，使用 vendor 机制可以实现与 Go Module 等价的构建。</p><p>和 GOPATH 构建模式不同，Go Module 构建模式下，我们再也无需手动维护 vendor 目录下的依赖包了，Go 提供了可以快速建立和更新 vendor 的命令，我们还是以前面的 module-mode 项目为例，通过下面命令为该项目建立 vendor：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod vendor<span class="token variable">$tree</span> -LF <span class="token number">2</span> vendorvendor├── github.com/│   ├── google/│   ├── magefile/│   └── sirupsen/├── golang.org/│   └── x/└── modules.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，go mod vendor 命令在 vendor 目录下，创建了一份这个项目的依赖包的副本，并且通过 vendor/modules.txt 记录了 vendor 下的 module 以及版本。</p><p>如果我们要基于 vendor 构建，而不是基于本地缓存的 Go Module 构建，我们需要在 go build 后面加上 -mod=vendor 参数。</p><p>在 Go 1.14 及以后版本中，如果 Go 项目的顶层目录下存在 vendor 目录，那么 go build 默认也会优先基于 vendor 构建，除非你给 go build 传入 -mod=mod 的参数。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，到这里，我们就完成了维护 Go Module 的全部常见场景的学习了，现在我们一起来回顾一下吧。</p><p>在通过 go mod init 为当前 Go 项目创建一个新的 module 后，随着项目的演进，我们在日常开发过程中，会遇到多种常见的维护 Go Module 的场景。</p><p>其中最常见的就是为项目添加一个依赖包，我们可以通过 go get 命令手工获取该依赖包的特定版本，更好的方法是通过 go mod tidy 命令让 Go 命令自动去分析新依赖并决定使用新依赖的哪个版本。</p><p>另外，还有几个场景需要你记住：</p><ul><li><p>通过 go get 我们可以升级或降级某依赖的版本，如果升级或降级前后的版本不兼容，这里千万注意别忘了变化包导入路径中的版本号，这是 Go 语义导入版本机制的要求；</p></li><li><p>通过 go mod tidy，我们可以自动分析 Go 源码的依赖变更，包括依赖的新增、版本变更以及删除，并更新 go.mod 中的依赖信息。</p></li><li><p>通过 go mod vendor，我们依旧可以支持 vendor 机制，并且可以对 vendor 目录下缓存的依赖包进行自动管理。</p></li></ul><p>在了解了如何应对 Go Modules 维护的日常工作场景后，你是不是有一种再也不担心 Go 源码构建问题的感觉了呢？</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建模式：Go是怎么解决包依赖管理问题的？</title>
      <link href="/2022/08/24/gou-jian-mo-shi-go-shi-zen-me-jie-jue-bao-yi-lai-guan-li-wen-ti-de/"/>
      <url>/2022/08/24/gou-jian-mo-shi-go-shi-zen-me-jie-jue-bao-yi-lai-guan-li-wen-ti-de/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-构建模式是怎么演化的？"><a href="#Go-构建模式是怎么演化的？" class="headerlink" title="Go 构建模式是怎么演化的？"></a>Go 构建模式是怎么演化的？</h1><p> <strong>Go 程序由 Go 包组合而成的，Go 程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程。</strong></p><p>Go 语言的构建模式历经了三个迭代和演化过程，分别是最初期的 GOPATH、1.5 版本的 Vendor 机制，以及现在的 Go Module。这里我们就先来介绍一下前面这两个。</p><h2 id="首先我们来看-GOPATH。"><a href="#首先我们来看-GOPATH。" class="headerlink" title="首先我们来看 GOPATH。"></a>首先我们来看 GOPATH。</h2><p>Go 语言在首次开源时，就内置了一种名为 GOPATH 的构建模式。在这种构建模式下，Go 编译器可以在本地 GOPATH 环境变量配置的路径下，搜寻 Go 程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><p>我这里给出了一段在 GOPATH 构建模式下编写的代码，你先来感受一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/sirupsen/logrus"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, gopath mode"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这段代码依赖了第三方包 logrus（logrus 是 Go 社区使用最为广泛的第三方 log 包）。</p><p>接下来，这个构建过程演示了 Go 编译器（这里使用 Go 1.10.8）在 GOPATH 环境变量所配置的目录下（这里为 /Users/tonybai/Go），无法找到程序依赖的 logrus 包而报错的情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.gomain.go:3:8: cannot <span class="token function">find</span> package <span class="token string">"github.com/sirupsen/logrus"</span> <span class="token keyword">in</span> any of:  /Users/tonybai/.bin/go1.10.8/src/github.com/sirupsen/logrus <span class="token punctuation">(</span>from <span class="token variable">$GOROOT</span><span class="token punctuation">)</span>  /Users/tonybai/Go/src/github.com/sirupsen/logrus <span class="token punctuation">(</span>from <span class="token variable">$GOPATH</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么 Go 编译器在 GOPATH 构建模式下，究竟怎么在 GOPATH 配置的路径下搜寻第三方依赖包呢？</strong></p><p>为了给你说清楚搜寻规则，我们先假定 Go 程序导入了 github.com/user/repo 这个包，我们也同时假定当前 GOPATH 环境变量配置的值为:</p><p><code>export GOPATH=/usr/local/goprojects:/home/tonybai/go</code></p><p>那么在 GOPATH 构建模式下，Go 编译器在编译 Go 程序时，就会在下面两个路径下搜索第三方依赖包是否存在：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/goprojects/src/github.com/user/repo/home/tonybai/go/src/github.com/user/repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里注意一下，如果你没有显式设置 GOPATH 环境变量，Go 会将 GOPATH 设置为默认值，不同操作系统下默认值的路径不同，在 macOS 或 Linux 上，它的默认值是 $HOME/go。</p><p>那么，当遇到像上面例子一样，没有在本地找到程序的第三方依赖包的情况，我们该如何解决这个问题呢？</p><p>我们可以通过 go get 命令将本地缺失的第三方依赖包下载到本地，比如：</p><p><code>$go get github.com/sirupsen/logrus</code></p><p>这里的 go get 命令，不仅能将 logrus 包下载到 GOPATH 环境变量配置的目录下，它还会检查 logrus 的依赖包在本地是否存在，如果不存在，go get 也会一并将它们下载到本地。</p><p>不过，go get 下载的包只是那个时刻各个依赖包的最新主线版本，这样会给后续 Go 程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个 Go 包时，得到不同的结果，也就是不能保证可重现的构建（Reproduceable Build）。又比如，如果依赖包引入了不兼容代码，程序将无法通过编译。</p><p>最后还有一点，如果依赖包因引入新代码而无法正常通过编译，并且该依赖包的作者又没用及时修复这个问题，这种错误也会传导到你的程序，导致你的程序无法通过编译。</p><p>也就是说，在 GOPATH 构建模式下，Go 编译器实质上并没有关注 Go 项目所依赖的第三方包的版本。但 Go 开发者希望自己的 Go 项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是 Go 核心开发团队引入了 Vendor 机制试图解决上面的问题。</p><p><strong>现在我们就来看看 vendor 机制是怎么解决这个问题的。</strong></p><h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h2><p>Go 在 1.5 版本中引入 vendor 机制。vendor 机制本质上就是在 Go 项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是 vendor。</p><p>Go 编译器会优先感知和使用 vendor 目录下缓存的第三方包版本，而不是 GOPATH 环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论 GOPATH 环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到 Go 程序的构建。</p><p>如果你将 vendor 目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用 vendor 机制管理第三方依赖包，最佳实践就是将 vendor 一并提交到代码仓库中。</p><p>下面这个目录结构就是为上面的代码示例添加 vendor 目录后的结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token punctuation">.</span>├── main<span class="token punctuation">.</span><span class="token keyword">go</span>└── vendor<span class="token operator">/</span>    ├── github<span class="token punctuation">.</span>com<span class="token operator">/</span>    │   └── sirupsen<span class="token operator">/</span>    │       └── logrus<span class="token operator">/</span>    └── golang<span class="token punctuation">.</span>org<span class="token operator">/</span>        └── x<span class="token operator">/</span>            └── sys<span class="token operator">/</span>                └── unix<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在添加完 vendor 后，我们重新编译 main.go，这个时候 Go 编译器就会在 vendor 目录下搜索程序依赖的 logrus 包以及后者依赖的 golang.org/x/sys/unix 包了。</p><p><strong>这里你还要注意一点，要想开启 vendor 机制，你的 Go 项目必须位于 GOPATH 环境变量配置的某个路径的 src 目录下面</strong>。如果不满足这一路径要求，那么 Go 编译器是不会理会 Go 项目目录下的 vendor 目录的。</p><p>不过 vendor 机制虽然一定程度解决了 Go 程序可重现构建的问题，但对开发者来说，它的体验却不那么好。一方面，Go 项目必须放在 GOPATH 环境变量配置的路径下，庞大的 vendor 目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。</p><p>另外，你还需要手工管理 vendor 下面的 Go 依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等，最让开发者头疼的就是这一点。</p><p>为了解决这个问题，Go 核心团队与社区将 Go 构建的重点转移到如何解决包依赖管理上。Go 社区先后开发了诸如 gb、glide、dep 等工具，来帮助 Go 开发者对 vendor 下的第三方包进行自动依赖分析和管理，但这些工具也都有自身的问题。</p><p>就在 Go 社区为包依赖管理焦虑并抱怨没有官方工具的时候，Go 核心团队基于社区实践的经验和教训，推出了 Go 官方的解决方案：Go Module。</p><h2 id="创建你的第一个-Go-Module"><a href="#创建你的第一个-Go-Module" class="headerlink" title="创建你的第一个 Go Module"></a>创建你的第一个 Go Module</h2><p>从 Go 1.11 版本开始，除了 GOPATH 构建模式外，Go 又增加了一种 Go Module 构建模式。</p><p>在04 讲中，我们曾基于 Go Module 构建模式编写过一个“hello, world”程序，当时是为了讲解 Go 程序结构，这里我再带你回顾一下 Go Module 的基础概念。</p><p>一个 Go Module 是一个 Go 包的集合。module 是有版本的，所以 module 下的包也就有了版本属性。这个 module 与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。</p><p>在 Go Module 模式下，通常一个代码仓库对应一个 Go Module。一个 Go Module 的顶层目录下会放置一个 go.mod 文件，每个 go.mod 文件会定义唯一一个 module，也就是说 Go Module 与 go.mod 是一一对应的。</p><p>go.mod 文件所在的顶层目录也被称为 module 的根目录，module 根目录以及它子目录下的所有 Go 包均归属于这个 Go Module，这个 module 也被称为 main module。</p><p>你可能也意识到了，Go Module 的原理和使用方法其实有点复杂，但“千里之行始于足下”，下面我们先从如何创建一个 Go Module 说起。我们先来将上面的例子改造成为一个基于 Go Module 构建模式的 Go 项目。</p><h2 id="创建一个-Go-Module"><a href="#创建一个-Go-Module" class="headerlink" title="创建一个 Go Module"></a>创建一个 Go Module</h2><p>将基于当前项目创建一个 Go Module，通常有如下几个步骤：</p><p>第一步，通过 go mod init 创建 go.mod 文件，将当前项目变为一个 Go Module；</p><p>第二步，通过 go mod tidy 命令自动更新当前 module 的依赖信息；</p><p>第三步，执行 go build，执行新 module 的构建。</p><p>我们一步一步来详细看一下。</p><p>我们先建立一个新项目 module-mode 用来演示 Go Module 的创建，注意我们可以在任意路径下创建这个项目，不必非要在 GOPATH 环境变量的配置路径下。</p><p>这个项目的 main.go 修改自上面的例子，修改后的 main.go 的代码是这样的，我们依旧依赖外部包 logrus：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/sirupsen/logrus"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logrus<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, go module mode"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，这个项目目录下只有 main.go 一个源文件，现在我们就来为这个项目添加 Go Module 支持。我们通过 go mod init 命令为这个项目创建一个 Go Module（这里我们使用的是 Go 版本为 1.16.5，Go 1.16 版本默认采用 Go Module 构建模式）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod init github.com/bigwhite/module-modego: creating new go.mod: module github.com/bigwhite/module-modego: to <span class="token function">add</span> module requirements and sums:  go mod tidy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，go mod init 在当前项目目录下创建了一个 go.mod 文件，这个 go.mod 文件将当前项目变为了一个 Go Module，项目根目录变成了 module 根目录。go.mod 的内容是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/bigwhite/module-modego <span class="token number">1.16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个 go.mod 文件现在处于初始状态，它的第一行内容用于声明 module 路径 (module path)，最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p><p>go mod init 命令还输出了两行日志，提示我们可以使用 go mod tidy 命令，添加 module 依赖以及校验和。go mod tidy 命令会扫描 Go 源码，并自动找出项目依赖的外部 Go Module 以及版本，下载这些依赖并更新本地的 go.mod 文件。我们按照这个提示执行一下 go mod tidy 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidygo: finding module <span class="token keyword">for</span> package github.com/sirupsen/logrusgo: downloading github.com/sirupsen/logrus v1.8.1go: found github.com/sirupsen/logrus <span class="token keyword">in</span> github.com/sirupsen/logrus v1.8.1go: downloading golang.org/x/sys v0.0.0-20191026070338-33540a1f6037go: downloading github.com/stretchr/testify v1.2.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，对于一个处于初始状态的 module 而言，go mod tidy 分析了当前 main module 的所有源文件，找出了当前 main module 的所有第三方依赖，确定第三方依赖的版本，还下载了当前 main module 的直接依赖包（比如 logrus），以及相关间接依赖包（直接依赖包的依赖，比如上面的 golang.org/x/sys 等）。</p><p>Go Module 还支持通过 Go Module 代理服务加速第三方依赖的下载。在03 讲我们讲解 Go 环境安装时，就提到过 GOPROXY 环境变量，这个环境变量的默认值为“https: // proxy.golang.org,direct”，不过我们可以配置更适合于中国大陆地区的 Go Module 代理服务。</p><p>由 go mod tidy 下载的依赖 module 会被放置在本地的 module 缓存路径下，默认值为 $GOPATH[0]/pkg/mod，Go 1.15 及以后版本可以通过 GOMODCACHE 环境变量，自定义本地 module 的缓存路径。</p><p>执行 go mod tidy 后，我们示例 go.mod 的内容更新如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">module github<span class="token punctuation">.</span>com<span class="token operator">/</span>bigwhite<span class="token operator">/</span>module<span class="token operator">-</span>mode<span class="token keyword">go</span> <span class="token number">1.16</span>require github<span class="token punctuation">.</span>com<span class="token operator">/</span>sirupsen<span class="token operator">/</span>logrus v1<span class="token punctuation">.</span><span class="token number">8.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，当前 module 的直接依赖 logrus，还有它的版本信息都被写到了 go.mod 文件的 require 段中。</p><p>而且，执行完 go mod tidy 后，当前项目除了 go.mod 文件外，还多了一个新文件 go.sum，内容是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c<span class="token operator">=</span>github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38<span class="token operator">=</span>github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM<span class="token operator">=</span>github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4<span class="token operator">=</span>github.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE<span class="token operator">=</span>github.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0<span class="token operator">=</span>github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w<span class="token operator">=</span>github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs<span class="token operator">=</span>golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4<span class="token operator">=</span>golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这同样是由 go mod 相关命令维护的一个文件，它存放了特定版本 module 内容的哈希值。</p><p>这是 Go Module 的一个安全措施。当将来这里的某个 module 的特定版本被再次下载的时候，go 命令会使用 go.sum 文件中对应的哈希值，和新下载的内容的哈希值进行比对，只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的 module 内容，不会被恶意或意外篡改。因此，我推荐你把 go.mod 和 go.sum 两个文件与源码，一并提交到代码版本控制服务器上</p><p>现在，go mod init 和 go mod tidy 已经为我们当前 Go Module 的构建铺平了道路，接下来，我们只需在当前 module 的根路径下，执行 go build 就可以完成 module 的构建了！</p><p>go build 命令会读取 go.mod 中的依赖及版本信息，并在本地 module 缓存路径下找到对应版本的依赖 module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件 module-mode，执行这个文件我们就能得到正确结果了。</p><p>整个过程的执行步骤是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build<span class="token variable">$ls</span>go.mod    go.sum    main.go    module-mode*$./module-mode INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> hello, go module mode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，到这里，我们已经完成了一个有着多个第三方依赖的项目的构建了。但关于 Go Module 的操作还远不止这些。随着 Go 项目的演进，我们会在代码中导入新的第三方包，删除一些旧的依赖包，更新一些依赖包的版本等。关于这些内容，我会在下一节课再给你详细讲解。</p><p>那么，在看到我们的 Go Module 机制会自动分析项目的依赖包，并选出最适合的版本后，不知道你会不会有这样的疑惑：项目所依赖的包有很多版本，Go Module 是如何选出最适合的那个版本的呢？要想回答这个问题，我们就需要深入到 Go Module 构建模式的工作原理中去。</p><h2 id="深入-Go-Module-构建模式"><a href="#深入-Go-Module-构建模式" class="headerlink" title="深入 Go Module 构建模式"></a>深入 Go Module 构建模式</h2><p> Go 语言设计者在设计 Go Module 构建模式，来解决“包依赖管理”的问题时，进行了几项创新，这其中就包括语义导入版本 (Semantic Import Versioning)，以及和其他主流语言不同的最小版本选择 (Minimal Version Selection) 等机制。只要你深入理解了这些机制，你就能真正掌握 Go Module 构建模式。</p><h3 id="首先我们看一下-Go-Module-的语义导入版本机制。"><a href="#首先我们看一下-Go-Module-的语义导入版本机制。" class="headerlink" title="首先我们看一下 Go Module 的语义导入版本机制。"></a>首先我们看一下 Go Module 的语义导入版本机制。</h3><p>在上面的例子中，我们看到 go.mod 的 require 段中依赖的版本号，都符合 vX.Y.Z 的格式。在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，由前缀 v 和一个满足语义版本规范的版本号组成。</p><p>你可以看看下面这张图，语义版本号分成 3 部分：主版本号 (major)、次版本号 (minor) 和补丁版本号 (patch)。例如上面的 logrus module 的版本号是 v1.8.1，这就表示它的主版本号为 1，次版本号为 8，补丁版本号为 1。</p><p><img src="https://static001.geekbang.org/resource/image/46/a2/468323b3294cce2ea7f4c1da3699c5a2.png?wh=1242x670"></p><p>Go 命令和 go.mod 文件都使用上面这种符合语义版本规范的版本号，作为描述 Go Module 版本的标准形式。借助于语义版本规范，Go 命令可以确定同一 module 的两个版本发布的先后次序，而且可以确定它们是否兼容。</p><p>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。</p><p>而且，Go Module 规定：<strong>如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的</strong>。怎么理解呢？我们来举个简单示例。我们就以 logrus 为例，它有很多发布版本，我们从中选出两个版本 v1.7.0 和 v1.8.1.。按照上面的语义版本规则，这两个版本的主版本号相同，新版本 v1.8.1 是兼容老版本 v1.7.0 的。那么，我们就可以知道，如果一个项目依赖 logrus，无论它使用的是 v1.7.0 版本还是 v1.8.1 版本，它都可以使用下面的包导入语句导入 logrus 包：</p><p><code>import "github.com/sirupsen/logrus"</code></p><p>那么问题又来了，假如在未来的某一天，logrus 的作者发布了 logrus v2.0.0 版本。那么根据语义版本规则，该版本的主版本号为 2，已经与 v1.7.0、v1.8.1 的主版本号不同了，那么 v2.0.0 与 v1.7.0、v1.8.1 就是不兼容的包版本。然后我们再按照 Go Module 的规定，如果一个项目依赖 logrus v2.0.0 版本，那么它的包导入路径就不能再与上面的导入方式相同了。那我们应该使用什么方式导入 logrus v2.0.0 版本呢？</p><p>Go Module 创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下面这样导入 logrus v2.0.0 版本依赖包：</p><p><code>import "github.com/sirupsen/logrus/v2"</code></p><p>这就是 Go 的“语义导入版本”机制，也就是说通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"github.com/sirupsen/logrus"</span>    logv2 <span class="token string">"github.com/sirupsen/logrus/v2"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过到这里，你可能会问，v0.y.z 版本应该使用哪种导入路径呢？</p><p>按照语义版本规范的说法，v0.y.z 这样的版本号是用于项目初始开发阶段的版本号。在这个阶段任何事情都有可能发生，其 API 也不应该被认为是稳定的。Go Module 将这样的版本 (v0) 与主版本号 v1 做同等对待，也就是采用不带主版本号的包导入路径，这样一定程度降低了 Go 开发人员使用这样版本号包时的心智负担。</p><p>Go 语义导入版本机制是 Go Module 机制的基础规则，同样它也是 Go Module 其他规则的基础。</p><h3 id="接下来，我们再来看一下-Go-Module-的最小版本选择原则。"><a href="#接下来，我们再来看一下-Go-Module-的最小版本选择原则。" class="headerlink" title="接下来，我们再来看一下 Go Module 的最小版本选择原则。"></a>接下来，我们再来看一下 Go Module 的最小版本选择原则。</h3><p>在前面的例子中，Go 命令都是在项目初始状态分析项目的依赖，并且项目中两个依赖包之间没有共同的依赖，这样的包依赖关系解决起来还是比较容易的。但依赖关系一旦复杂起来，比如像下图中展示的这样，Go 又是如何确定使用依赖包 C 的哪个版本的呢？</p><p><img src="https://static001.geekbang.org/resource/image/49/1b/49eb7aa0458d8ec6131d9e5661155f1b.jpeg?wh=1920x1080"></p><p>在这张图中，myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C，但 A 依赖 C 的 v1.1.0 版本，而 B 依赖的是 C 的 v1.3.0 版本，并且此时 C 包的最新发布版为 C v1.7.0。这个时候，Go 命令是如何为 myproject 选出间接依赖包 C 的版本呢？选出的究竟是 v1.7.0、v1.1.0 还是 v1.3.0 呢？你可以暂停一两分钟思考一下。</p><p>其实，当前存在的主流编程语言，以及 Go Module 出现之前的很多 Go 包依赖管理工具都会选择依赖项的“最新最大 (Latest Greatest) 版本”，对应到图中的例子，这个版本就是 v1.7.0。</p><p>当然了，理想状态下，如果语义版本控制被正确应用，并且这种“社会契约”也得到了很好的遵守，那么这种选择算法是有道理的，而且也可以正常工作。在这样的情况下，依赖项的“最新最大版本”应该是最稳定和安全的版本，并且应该有向后兼容性。至少在相同的主版本 (Major Verion) 依赖树中是这样的。</p><p>但我们这个问题的答案并不是这样的。Go 设计者另辟蹊径，在诸多兼容性版本间，他们不光要考虑最新最大的稳定与安全，还要尊重各个 module 的述求：A 明明说只要求 C v1.1.0，B 明明说只要求 C v1.3.0。<strong>所以 Go 会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”</strong></p><p>这个例子中，C v1.3.0 是符合项目整体要求的版本集合中的版本最小的那个，于是 Go 命令选择了 C v1.3.0，而不是最新最大的 C v1.7.0。并且，Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。</p><p>了解了语义导入版本与最小版本选择两种机制后，你就可以说你已经掌握了 Go Module 的精髓。</p><p>但很多 Go 开发人员的起点，并非是默认开启 Go Module 构建模式的 Go 1.16 版本，多数 Go 开发人使用的环境中都存在着多套 Go 版本，有用于体验最新功能特性的 Go 版本，也有某些遗留项目所使用的老版本 Go 编译器。</p><p>它们工作时采用的构建模式是不一样的，并且即便是引入 Go Module 的 Go 1.11 版本，它的 Go Module 机制，和后续进化后的 Go 版本的 Go Module 构建机制在表现行为上也有所不同。因此 Go 开发人员可能需要经常在各个 Go 版本间切换。而明确具体版本下 Go Module 的实际表现行为对 Go 开发人员是十分必要的。</p><h3 id="Go-各版本构建模式机制和切换"><a href="#Go-各版本构建模式机制和切换" class="headerlink" title="Go 各版本构建模式机制和切换"></a>Go 各版本构建模式机制和切换</h3><p>我们前面说了，在 Go 1.11 版本中，Go 开发团队引入 Go Modules 构建模式。这个时候，GOPATH 构建模式与 Go Modules 构建模式各自独立工作，我们可以通过设置环境变量 GO111MODULE 的值在两种构建模式间切换。</p><p>然后，随着 Go 语言的逐步演进，从 Go 1.11 到 Go 1.16 版本，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式几经变化，直到 Go 1.16 版本，Go Module 构建模式成为了默认模式。</p><p>所以，要分析 Go 各版本的具体构建模式的机制和切换，我们只需要找到这几个代表性的版本就好了。</p><p>我这里将 Go 1.13 版本之前、Go 1.13 版本以及 Go 1.16 版本，在 GO111MODULE 为不同值的情况下的行为做了一下对比，这样我们可以更好地理解不同版本下、不同构建模式下的行为特性，下面我们就来用表格形式做一下比对：</p><p><img src="https://static001.geekbang.org/resource/image/45/d3/45bdecc5fa873e06893d6658e447a8d3.jpeg?wh=1920x1080"></p><p>了解了这些，你就能在工作中游刃有余的在各个 Go 版本间切换了，不用再担心切换后模式变化，导致构建失败了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Go 语言最初发布时内置的构建模式为 GOPATH 构建模式。在这种构建模式下，所有构建都离不开 GOPATH 环境变量。在这个模式下，Go 编译器并没有关注依赖包的版本，开发者也无法控制第三方依赖的版本，导致开发者无法实现可重现的构建。</p><p>那么，为了支持可重现构建，Go 1.5 版本引入了 vendor 机制，开发者可以在项目目录下缓存项目的所有依赖，实现可重现构建。但 vendor 机制依旧不够完善，开发者还需要手工管理 vendor 下的依赖包，这就给开发者带来了不小的心智负担。</p><p>后来，Go 1.11 版本中，Go 核心团队推出了新一代构建模式：Go Module 以及一系列创新机制，包括语义导入版本机制、最小版本选择机制等。语义导入版本机制是 Go Moudle 其他机制的基础，它是通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本。而且，Go 命令使用最小版本选择机制进行包依赖版本选择，这和当前主流编程语言，以及 Go 社区之前的包依赖管理工具使用的算法都有点不同。</p><p>外，Go 命令还可以通过 GO111MODULE 环境变量进行 Go 构建模式的切换。但你要注意，从 Go 1.11 到 Go 1.16，不同的 Go 版本在 GO111MODULE 为不同值的情况下，开启的构建模式以及具体表现行为也几经变化，这里你重点看一下前面总结的表格。</p><p>现在，Go 核心团队已经考虑在后续版本中彻底移除 GOPATH 构建模式，Go Module 构建模式将成为 Go 语言唯一的标准构建模式。所以，学完这一课之后，我建议你从现在开始就彻底抛弃 GOPATH 构建模式，全面使用 Go Module 构建模式。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医院记录 day01</title>
      <link href="/2022/08/24/yi-yuan-ji-lu-day01/"/>
      <url>/2022/08/24/yi-yuan-ji-lu-day01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天去了县医院陪妈妈做检查，明天妈妈就要做手术了。</p><p>妈妈得了子宫肌瘤，虽然大家都说这是一个很常见的病，而且也是个小手术，但是还是很担心，害怕出现意外。而且妈妈也很害怕，因为她也很少住医院，而且也没有做过什么手术，希望明天一切都好。</p><p>每次到了这种时候，我都会想自己的长大跟不上父母衰老的速度，感觉自己现在还是个孩子，很多事情都做不好。而且最重要的就是自己还没有能力赚钱，这样就会感觉自己很没用。所以我有时候会想着不去上研究生，而选择直接就业，这样自己就能早点挣到钱了。</p><p>希望自己以后真的能够挣到差不多的钱，然后给父母一个安稳的晚年。</p>]]></content>
      
      
      <categories>
          
          <category> 日常小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医院 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准先行: Go项目的布局标准是什么?</title>
      <link href="/2022/08/23/biao-zhun-xian-xing-go-xiang-mu-de-bu-ju-biao-zhun-shi-shi-me/"/>
      <url>/2022/08/23/biao-zhun-xian-xing-go-xiang-mu-de-bu-ju-biao-zhun-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="现在的-Go-项目的典型结构布局是怎样的"><a href="#现在的-Go-项目的典型结构布局是怎样的" class="headerlink" title="现在的 Go 项目的典型结构布局是怎样的?"></a>现在的 Go 项目的典型结构布局是怎样的?</h1><p>一个 Go 项目通常分为可执行程序项目和库项目，现在我们就来分析一下这两类 Go 项目的典型结构布局分别是怎样的。</p><p><strong>首先我们先来看 Go 可执行程序项目的典型结构布局。</strong></p><p>可执行程序项目是以构建可执行程序为目的的项目，Go 社区针对这类 Go 项目所形成的典型结构布局是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -F exe-layout exe-layout├── cmd/│   ├── app1/│   │   └── main.go│   └── app2/│       └── main.go├── go.mod├── go.sum├── internal/│   ├── pkga/│   │   └── pkg_a.go│   └── pkgb/│       └── pkg_b.go├── pkg1/│   └── pkg1.go├── pkg2/│   └── pkg2.go└── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的一个 Go 项目典型布局就是“脱胎”于 Go 创世项目的最新结构布局，我现在跟你解释一下这里面的几个要点。</p><p>我们从上往下按顺序来，先来看 cmd 目录。cmd 目录就是存放项目要编译构建的可执行文件对应的 main 包的源文件。如果你的项目中有多个可执行文件需要构建，每个可执行文件的 main 包单独放在一个子目录中，比如图中的 app1、app2，cmd 目录下的各 app 的 main 包将整个项目的依赖连接在一起。</p><p>而且通常来说，main 包应该很简洁。我们在 main 包中会做一些命令行参数解析、资源初始化、日志设施初始化、数据库连接初始化等工作，之后就会将程序的执行权限交给更高级的执行控制对象。另外，也有一些 Go 项目将 cmd 这个名字改为 app 或其他名字，但它的功能其实并没有变。</p><p>接着我们来看 pkgN 目录，这是一个存放项目自身要使用、同样也是可执行文件对应 main 包所要依赖的库文件，同时这些目录下的包还可以被外部项目引用。</p><p>然后是 go.mod 和 go.sum，它们是 Go 语言包依赖管理使用的配置文件。我们前面说过，Go 1.11 版本引入了 Go Module 构建机制，这里我建议你所有新项目都基于 Go Module 来进行包依赖管理，因为这是目前 Go 官方推荐的标准构建模式。</p><p>对于还没有使用 Go Module 进行包依赖管理的遗留项目，比如之前采用 dep、glide 等作为包依赖管理工具的，建议尽快迁移到 Go Module 模式。Go 命令支持直接将 dep 的 Gopkg.toml/Gopkg.lock 或 glide 的 glide.yaml/glide.lock 转换为 go.mod。</p><p>最后我们再来看看 vendor 目录。vendor 是 Go 1.5 版本引入的用于在项目本地缓存特定版本依赖包的机制，在 Go Modules 机制引入前，基于 vendor 可以实现可重现构建，保证基于同一源码构建出的可执行程序是等价的。</p><p>不过呢，我们这里将 vendor 目录视为一个可选目录。原因在于，Go Module 本身就支持可再现构建，而无需使用 vendor。 当然 Go Module 机制也保留了 vendor 目录（通过 go mod vendor 可以生成 vendor 下的依赖包，通过 go build -mod=vendor 可以实现基于 vendor 的构建）。一般我们仅保留项目根目录下的 vendor 目录，否则会造成不必要的依赖选择的复杂性。</p><p>当然了，有些开发者喜欢借助一些第三方的构建工具辅助构建，比如：make、bazel 等。你可以将这类外部辅助构建工具涉及的诸多脚本文件（比如 Makefile）放置在项目的顶层目录下，就像 Go 创世项目中的 all.bash 那样。</p><p>另外，这里只要说明一下的是，Go 1.11 引入的 module 是一组同属于一个版本管理单元的包的集合。并且 Go 支持在一个项目 / 仓库中存在多个 module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。 因此，如果项目结构中存在版本管理的“分歧”，比如：app1 和 app2 的发布版本并不总是同步的，那么我建议你将项目拆分为多个项目（仓库），每个项目单独作为一个 module 进行单独的版本管理和演进。</p><p>当然如果你非要在一个代码仓库中存放多个 module，那么新版 Go 命令也提供了很好的支持。比如下面代码仓库 multi-modules 下面有三个 module：mainmodule、module1 和 module2：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> multi-modulesmulti-modules├── go.mod // mainmodule├── module1│   └── go.mod // module1└── module2    └── go.mod // module2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过 git tag 名字来区分不同 module 的版本。其中 vX.Y.Z 形式的 tag 名字用于代码仓库下的 mainmodule；而 module1/vX.Y.Z 形式的 tag 名字用于指示 module1 的版本；同理，module2/vX.Y.Z 形式的 tag 名字用于指示 module2 版本。</p><p>如果 Go 可执行程序项目有一个且只有一个可执行程序要构建，那就比较好办了，我们可以将上面项目布局进行简化：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">1</span> -F single-pkg-lib-layoutsingle-pkg-lib-layout├── feature1.go├── feature2.go├── go.mod└── internal/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以看到，我们删除了 cmd 目录，将唯一的可执行程序的 main 包就放置在项目根目录下，而其他布局元素的功用不变。</p><p><strong>好了到这里，我们已经了解了 Go 可执行程序项目的典型布局，现在我们再来看看 Go 库项目的典型结构布局是怎样的。</strong></p><p>Go 库项目仅对外暴露 Go 包，这类项目的典型布局形式是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -F lib-layout lib-layout├── go.mod├── internal/│   ├── pkga/│   │   └── pkg_a.go│   └── pkgb/│       └── pkg_b.go├── pkg1/│   └── pkg1.go└── pkg2/    └── pkg2.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，库类型项目相比于 Go 可执行程序项目的布局要简单一些。因为这类项目不需要构建可执行程序，所以去除了 cmd 目录。</p><p>而且，在这里，vendor 也不再是可选目录了。对于库类型项目而言，我们并不推荐在项目中放置 vendor 目录去缓存库自身的第三方依赖，库项目仅通过 go.mod 文件明确表述出该项目依赖的 module 或包以及版本要求就可以了。</p><p>Go 库项目的初衷是为了对外部（开源或组织内部公开）暴露 API，对于仅限项目内部使用而不想暴露到外部的包，可以放在项目顶层的 internal 目录下面。当然 internal 也可以有多个并存在于项目结构中的任一目录层级中，关键是项目结构设计人员要明确各级 internal 包的应用层次和范围。</p><p>对于有一个且仅有一个包的 Go 库项目来说，我们也可以将上面的布局做进一步简化，简化的布局如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">1</span> -F single-pkg-lib-layoutsingle-pkg-lib-layout├── feature1.go├── feature2.go├── go.mod└── internal/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化后，我们将这唯一包的所有源文件放置在项目的顶层目录下（比如上面的 feature1.go 和 feature2.go），其他布局元素位置和功用不变。</p><p>好了，现在我们已经了解完目前 Go 项目的典型结构布局了。不过呢，除了这些之外，还要注意一下早期 Go 可执行程序项目的经典布局，这个又有所不同。</p><p><strong>注意早期 Go 可执行程序项目的典型布局</strong></p><p>很多早期接纳 Go 语言的开发者所建立的 Go 可执行程序项目，深受 Go 创世项目 1.4 版本之前的布局影响，这些项目将所有可暴露到外面的 Go 包聚合在 pkg 目录下，就像前面 Go 1.3 版本中的布局那样，它们的典型布局结构是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$tree</span> -L <span class="token number">3</span> -F early-project-layoutearly-project-layout└── exe-layout/    ├── cmd/    │   ├── app1/    │   └── app2/    ├── go.mod    ├── internal/    │   ├── pkga/    │   └── pkgb/    ├── pkg/    │   ├── pkg1/    │   └── pkg2/    └── vendor/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到，原本放在项目顶层目录下的 pkg1 和 pkg2 公共包被统一聚合到 pkg 目录下了。而且，这种早期 Go 可执行程序项目的典型布局在 Go 社区内部也不乏受众，很多新建的 Go 项目依然采用这样的项目布局。</p><p>所以，当你看到这样的布局也不要奇怪，并且在我的讲解后，你应该就明确在这样的布局下 pkg 目录所起到的“聚类”的作用了。不过，在这里还是建议你在创建新的 Go 项目时，优先采用前面的标准项目布局。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们今天这门课就结束了。在这一节课里，我们学习了 Go 创世项目，也就是 Go 语言项目自身的项目源码布局，以及演进情况。在 Go 创世项目的启发下，Go 社区在多年实践中形成了典型的 Go 项目结构布局形式。</p><p>我们将 Go 项目分为可执行程序项目和 Go 库项目两类进行了详细的项目典型布局讲解，这里简单回顾一下。</p><p>首先，对于以生产可执行程序为目的的 Go 项目，它的典型项目结构分为五部分：</p><ul><li><p>放在项目顶层的 Go Module 相关文件，包括 go.mod 和 go.sum；</p></li><li><p>cmd 目录：存放项目要编译构建的可执行文件所对应的 main 包的源码文件；</p></li><li><p>项目包目录：每个项目下的非 main 包都“平铺”在项目的根目录下，每个目录对应一个 Go 包;</p></li><li><p>internal 目录：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；</p></li><li><p>vendor 目录：这是一个可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在的。这个目录下的内容均由 Go 命令自动维护，不需要开发者手工干预。</p></li></ul><p>第二，对于以生产可复用库为目的的 Go 项目，它的典型结构则要简单许多，我们可以直接理解为在 Go 可执行程序项目的基础上去掉 cmd 目录和 vendor 目录。</p><p>最后，早期接纳 Go 语言的开发者所建立的项目的布局深受 Go 创世项目 1.4 版本之前布局的影响，将可导出的公共包放入单独的 pkg 目录下，我们了解这种情况即可。对于新建 Go 项目，我依旧建议你采用前面介绍的标准布局形式。</p><p>现在，如果你要再面对一个要用于生产环境的 Go 应用项目的布局问题，是不是胸有成竹了呢？</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland 使用中的错误</title>
      <link href="/2022/08/23/goland-shi-yong-zhong-de-cuo-wu/"/>
      <url>/2022/08/23/goland-shi-yong-zhong-de-cuo-wu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>遇到问题</li></ul><p><img src="https://img-blog.csdnimg.cn/8c53af32c3b64a37b25f609af5977194.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>解决办法<ul><li>方案一</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/a0aeb21fb7844d788b3afa091a1085d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p><strong>删除go.mod</strong></p><p><img src="https://img-blog.csdnimg.cn/3fe3d3c764d54cffa9d8e7805a7ea111.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6X54yb55S3,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>产生原因</li></ul><p><strong>开启 Go module 模块支持后，并不能与 GOPATH 共存，所以需要删除其中一个</strong></p><p>现在基本开始使用 Go module ，所以可以将 GOPATH 删除</p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初窥门径: 一个Go程序的结构是怎样的?</title>
      <link href="/2022/08/23/chu-kui-men-jing-yi-ge-go-cheng-xu-de-jie-gou-shi-zen-yang-de/"/>
      <url>/2022/08/23/chu-kui-men-jing-yi-ge-go-cheng-xu-de-jie-gou-shi-zen-yang-de/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编写并运行第一个-Go-程序"><a href="#编写并运行第一个-Go-程序" class="headerlink" title="编写并运行第一个 Go 程序"></a>编写并运行第一个 Go 程序</h1><p><strong>Go 源文件总是用全小写字母形式的短小单词命名，并且以.go扩展名结尾</strong></p><p>如果要在源文件的名字中使用多个单词，我们通常是将多个单词连接起来作为源文件名，而不是使用其他分隔符，比如下划线。比如 hello_world.go</p><p><strong>下划线这种分隔符，在 Go 源文件命名中有特殊作用</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>终端运行</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">linux<span class="token variable">$go</span> build main.go$./mainhello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">window<span class="token operator">&gt;</span>go build main.go<span class="token operator">&gt;</span>.<span class="token punctuation">\</span>main.exehello, world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="示例程序的结构"><a href="#示例程序的结构" class="headerlink" title="示例程序的结构"></a>示例程序的结构</h1><p><code>package main</code></p><p>这一行代码定义了 Go 中的一个包 package。包是 Go 语言的基本组成单元，通常使用单个的小写单词命名，一个 Go 程序本质上就是一组包的集合。所有 Go 代码都有自己隶属的包，在这里我们的“hello，world”示例的所有代码都在一个名为 main 的包中。main 包在 Go 中是一个特殊的包，整个 Go 程序中仅允许存在一个名为 main 的包。</p><p>main 包中的主要代码是一个名为 main 的函数： </p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>这里的 main 函数会比较特殊：当你运行一个可执行的 Go 程序的时候，所有的代码都会从这个入口函数开始运行</strong>这段代码的第一行声明了一个名为 main 的、没有任何参数和返回值的函数。如果某天你需要给函数声明参数的话，那么就必须把它们放置在圆括号 () 中。</p><p>另外，那对花括号{}被用来标记函数体，Go 要求所有的函数体都要被花括号包裹起来。按照惯例，我们推荐把左花括号与函数声明置于同一行并以空格分隔。Go 语言内置了一套 Go 社区约定俗称的代码风格，并随安装包提供了一个名为 Gofmt 的工具，这个工具可以帮助你将代码自动格式化为约定的风格。</p><p>Gofmt 是 Go 语言在解决规模化（scale）问题上的一个最佳实践，并成为了 Go 语言吸引其他语言开发者的一大卖点。很多其他主流语言也在效仿 Go 语言推出自己的 format 工具，比如：Java formatter、Clang formatter、Dartfmt 等。因此，作为 Go 开发人员，请在提交你的代码前使用 Gofmt 格式化你的 Go 源码。</p><p>好，回到正题，我们再来看一看 main 函数体中的代码：</p><p><code>fmt.Println("hello, world")</code></p><p>注意点 1：标准 Go 代码风格使用 Tab 而不是空格来实现缩进的，当然这个代码风格的格式化工作也可以交由 gofmt 完成</p><p>注意点 2：我们调用了一个名为 Println 的函数，这个函数位于 Go 标准库的 fmt 包中。为了在我们的示例程序中使用 fmt 包定义的 Println 函数，我们其实做了两步操作。</p><ul><li><p>import “fmt” 一行中“fmt”代表的是包的导入路径（Import），它表示的是标准库下的 fmt 目录，整个 import 声明语句的含义是导入标准库 fmt 目录下的包；</p></li><li><p>fmt.Println 函数调用一行中的“fmt”代表的则是包名</p></li></ul><p>通常导入路径的最后一个分段名与包名是相同的，这也很容易让人误解 import 声明语句中的“fmt”指的是包名，其实并不是这样的。</p><p>main 函数体中之所以可以调用 fmt 包的 Println 函数，还有最后一个原因，那就是 Println 函数名的首字母是大写的。在 Go 语言中，只有首字母为大写的标识符才是导出的（Exported），才能对包外的代码可见；如果首字母是小写的，那么就说明这个标识符仅限于在声明它的包内可见。</p><p>另外，在 Go 语言中，main 包是不可以像标准库 fmt 包那样被导入（Import）的，如果导入 main 包，在代码编译阶段你会收到一个 Go 编译器错误：import “xx/main” is a program, not an importable package。</p><p>注意点 3：我们还是回到 main 函数体实现上，把关注点放在传入到 Println 函数的字符串“hello, world”上面。你会发现，我们传入的字符串也就是我们执行程序后在终端的标准输出上看到的字符串。</p><p>这种“所见即所得”得益于 Go 源码文件本身采用的是 Unicode 字符集，而且用的是 UTF-8 标准的字符编码方式，这与编译后的程序所运行的环境所使用的字符集和字符编码方式是一致的。</p><p>这里，即便我们将代码中的”hello, world”换成中文字符串“你好，世界”，像下面这样：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"你好，世界"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最后，不知道你有没有发现，我们整个示例程序源码中，都没有使用过分号来标识语句的结束，这与 C、C++、Java 那些传统编译型语言好像不太一样呀？</strong></p><p>不过，其实 Go 语言的正式语法规范是使用分号“;”来做结尾标识符的。那为什么我们很少在 Go 代码中使用和看到分号呢？这是因为，大多数分号都是可选的，常常被省略，不过在源码编译时，Go 编译器会自动插入这些被省略的分号。</p><p>我们给上面的“hello，world”示例程序加上分号也是完全合法的，是可以直接通过 Go 编译器编译并正常运行的。不过，gofmt 在按约定格式化代码时，会自动删除这些被我们手工加入的分号的。</p><p>在分析完这段代码结构后，我们来讲一下 Go 语言的编译。虽然刚刚你应该已经运行过“hello, world”这个示例程序了，在这过程中，有一个重要的步骤——编译，现在我就带你来看看 Go 语言中程序是怎么进行编译的。</p><h1 id="Go-语言中程序是怎么编译的"><a href="#Go-语言中程序是怎么编译的" class="headerlink" title="Go 语言中程序是怎么编译的?"></a>Go 语言中程序是怎么编译的?</h1><p>你应该也注意到了，刚刚我在运行”hello, world”程序之前，输入了 go build 命令，还有它附带的源文件名参数来编译它：</p><p><code>$go build main.go</code></p><p>假如你曾经有过 C/C++ 语言的开发背景，那么你就会发现这个步骤与 gcc 或 clang 编译十分相似。一旦编译成功，我们就会获得一个二进制的可执行文件。在 Linux 系统、macOS 系统，以及 Windows 系统的 PowerShell 中，我们可以通过输入下面这个 ls 命令看到刚刚生成的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ls</span>main*    main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面显示的文件里面有我们刚刚创建的、以.go 为后缀的源代码文件，还有刚生成的可执行文件（Windows 系统下为 main.exe，其余系统下为 main）。</p><p>如果你之前更熟悉某种类似于 Ruby、Python 或 JavaScript 之类的动态语言，你可能还不太习惯在运行之前需要先进行编译的情况。Go 是一种编译型语言，这意味着只有你编译完 Go 程序之后，才可以将生成的可执行文件交付于其他人，并运行在没有安装 Go 的环境中。</p><p>而如果你交付给其他人的是一份.rb、.py 或.js 的动态语言的源文件，那么他们的目标环境中就必须要拥有对应的 Ruby、Python 或 JavaScript 实现才能解释执行这些源文件。</p><p>当然，Go 也借鉴了动态语言的一些对开发者体验较好的特性，比如基于源码文件的直接执行，Go 提供了 run 命令可以直接运行 Go 源码文件，比如我们也可以使用下面命令直接基于 main.go 运行：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">$<span class="token keyword">go</span> run main<span class="token punctuation">.</span><span class="token keyword">go</span>hello<span class="token punctuation">,</span> world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然像 go run 这类命令更多用于开发调试阶段，真正的交付成果还是需要使用 go build 命令构建的。</p><p>但是在我们的生产环境里，Go 程序的编译往往不会像我们前面，基于单个 Go 源文件构建类似“hello，world”这样的示例程序那么简单。越贴近真实的生产环境，也就意味着项目规模越大、协同人员越多，项目的依赖和依赖的版本都会变得复杂。</p><p>那在我们更复杂的生产环境中，go build 命令也能圆满完成我们的编译任务吗？我们现在就来探讨一下。</p><h1 id="复杂项目下-Go-程序的编译是怎样的"><a href="#复杂项目下-Go-程序的编译是怎样的" class="headerlink" title="复杂项目下 Go 程序的编译是怎样的"></a>复杂项目下 Go 程序的编译是怎样的</h1><p>我们还是直接上项目吧，给 go build 一个机会，看看它的复杂依赖管理到底怎么样。</p><p>现在我们创建一个新项目“hellomodule”，在新项目中我们将使用两个第三方库，zap 和 fasthttp，给 go build 的构建过程增加一些难度。和“hello，world”示例一样，我们通过下面命令创建“hellomodule”项目：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cd</span> ~/goprojects<span class="token variable">$mkdir</span> hellomodule<span class="token variable">$cd</span> hellomodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着，我们在“hellomodule“下创建并编辑我们的示例源码文件：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"github.com/valyala/fasthttp"</span>  <span class="token string">"go.uber.org/zap"</span><span class="token punctuation">)</span><span class="token keyword">var</span> logger <span class="token operator">*</span>zap<span class="token punctuation">.</span>Logger<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> zap<span class="token punctuation">.</span><span class="token function">NewProduction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">fastHTTPHandler</span><span class="token punctuation">(</span>ctx <span class="token operator">*</span>fasthttp<span class="token punctuation">.</span>RequestCtx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"hello, go module"</span><span class="token punctuation">,</span> zap<span class="token punctuation">.</span><span class="token function">ByteString</span><span class="token punctuation">(</span><span class="token string">"uri"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">RequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fasthttp<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8081"</span><span class="token punctuation">,</span> fastHTTPHandler<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例创建了一个在 8081 端口监听的 http 服务，当我们向它发起请求后，这个服务会在终端标准输出上输出一段访问日志。</p><p>你会看到，和“hello，world“相比，这个示例显然要复杂许多。但不用担心，你现在大可不必知道每行代码的功用，你只需要我们在这个稍微有点复杂的示例中引入了两个第三方依赖库，zap 和 fasthttp 就可以了。</p><p>我们尝试一下使用编译“hello，world”的方法来编译“hellomodule”中的 main.go 源文件，go 编译器的输出结果是这样的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.gomain.go:4:2: no required module provides package github.com/valyala/fasthttp: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span>main.go:5:2: no required module provides package go.uber.org/zap: go.mod <span class="token function">file</span> not found <span class="token keyword">in</span> current directory or any parent directory<span class="token punctuation">;</span> see <span class="token string">'go help modules'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看这结果，这回我们运气似乎不佳，main.go 的编译失败了！</p><p>从编译器的输出来看，go build 似乎在找一个名为 go.mod 的文件，来解决程序对第三方包的依赖决策问题。</p><p><strong>好了，我们也不打哑谜了，是时候让 Go module 登场了！</strong></p><p>Go module 构建模式是在 Go 1.11 版本正式引入的，为的是彻底解决 Go 项目复杂版本依赖的问题，在 Go 1.16 版本中，Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制。</p><p>Go Module 的核心是一个<strong>名为go.mod 的文件</strong>，在这个文件中存储了这个 module 对第三方依赖的全部信息。接下来，我们就通过下面命令为“hello，module”这个示例程序添加 go.mod 文件：</p><p><code>go mod init</code>  <strong>后面的名称，可以自己随意定义，跟本地文件没有关系，使用 github.com/… 作为 module path 是因为多数实用级 module 多是上传到 github 上的。这样是为了便于后续与真实生产接驳。但对于本地开发使用的简单示例程序而言，可以随意命名</strong></p><p><strong>go mod init后面的路径就是go.mod中module后面的路径，代表的是module path。</strong></p><p><strong>go mod init命令的实际行为就是在当前目录下创建一个go.mod，而这个go.mod将当前目录转换为一个go module。</strong></p><p><strong>go module是一个逻辑概念。文中也说了，它更像一个命名空间的概念。它与文件夹名称无关。有了go.mod后，这个文件夹下的各个包就算是这个go module下面的包了。包的导入路径也是以module path为前缀的。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod init github.com/bigwhite/hellomodulego: creating new go.mod: module github.com/bigwhite/hellomodulego: to <span class="token function">add</span> module requirements and sums:  go mod tidy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，go mod init 命令的执行结果是在当前目录下生成了一个 go.mod 文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$cat</span> go.modmodule github.com/bigwhite/hellomodulego <span class="token number">1.16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其实，一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。go.mod 所在的目录被我们称为它声明的 module 的根目录。</p><p>不过呢，这个时候的 go.mod 文件内容还比较简单，第一行内容是用于声明 module 路径（module path）的。而且，module 隐含了一个命名空间的概念，module 下每个包的导入路径都是由 module path 和包所在子目录的名字结合在一起构成。</p><p>比如，如果 hellomodule 下有子目录 pkg/pkg1，那么 pkg1 下面的包的导入路径就是由 module path（github.com/bigwhite/hellomodule）和包所在子目录的名字（pkg/pkg1）结合而成，也就是 github.com/bigwhite/hellomodule/pkg/pkg1。</p><p>另外，go.mod 的最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的。</p><p><strong>有了 go.mod 后，是不是我们就可以构建 hellomodule 示例了呢？</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">$<span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> no required module provides <span class="token keyword">package</span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>valyala<span class="token operator">/</span>fasthttp<span class="token punctuation">;</span> to add it<span class="token punctuation">:</span>  <span class="token keyword">go</span> get github<span class="token punctuation">.</span>com<span class="token operator">/</span>valyala<span class="token operator">/</span>fasthttpmain<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span> no required module provides <span class="token keyword">package</span> <span class="token keyword">go</span><span class="token punctuation">.</span>uber<span class="token punctuation">.</span>org<span class="token operator">/</span>zap<span class="token punctuation">;</span> to add it<span class="token punctuation">:</span>  <span class="token keyword">go</span> get <span class="token keyword">go</span><span class="token punctuation">.</span>uber<span class="token punctuation">.</span>org<span class="token operator">/</span>zap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会看到，Go 编译器提示源码依赖 fasthttp 和 zap 两个第三方包，但是 go.mod 中没有这两个包的版本信息，我们需要按提示手工添加信息到 go.mod 中。</p><p>这个时候，除了按提示手动添加外，我们也可以使用 go mod tidy 命令，让 Go 工具自动添加：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> mod tidy       go: downloading go.uber.org/zap v1.18.1go: downloading github.com/valyala/fasthttp v1.28.0go: downloading github.com/andybalholm/brotli v1.0.2<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果中，我们看到 Go 工具不仅下载并添加了 hellomodule 直接依赖的 zap 和 fasthttp 包的信息，还下载了这两个包的相关依赖包。go mod tidy 执行后，我们 go.mod 的最新内容变成了这个样子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/bigwhite/hellomodulego <span class="token number">1.16</span>require <span class="token punctuation">(</span>  github.com/valyala/fasthttp v1.28.0  go.uber.org/zap v1.18.1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候，go.mod 已经记录了 hellomodule 直接依赖的包的信息。不仅如此，hellomodule 目录下还多了一个名为 go.sum 的文件，这个文件记录了 hellomodule 的直接依赖和间接依赖包的相关版本的 hash 值，用来校验本地包的真实性。在构建的时候，如果本地依赖包的 hash 值与 go.sum 文件中记录的不一致，就会被拒绝构建。</p><p>有了 go.mod 以及 hellomodule 依赖的包版本信息后，我们再来执行构建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go</span> build main.go<span class="token variable">$ls</span>go.mod    go.sum    main*    main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这次我们成功构建出了可执行文件 main，运行这个文件，新开一个终端窗口，在新窗口中使用 curl 命令访问该 http 服务：curl localhost:8081/foo/bar，我们就会看到服务端输出如下日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./main<span class="token punctuation">{</span><span class="token string">"level"</span><span class="token builtin class-name">:</span><span class="token string">"info"</span>,<span class="token string">"ts"</span>:1626614126.9899719,<span class="token string">"caller"</span><span class="token builtin class-name">:</span><span class="token string">"hellomodule/main.go:15"</span>,<span class="token string">"msg"</span><span class="token builtin class-name">:</span><span class="token string">"hello, go module"</span>,<span class="token string">"uri"</span><span class="token builtin class-name">:</span><span class="token string">"/foo/bar"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这下，我们的“ hellomodule”程序可算创建成功了。我们也看到使用 Go Module 的构建模式，go build 完全可以承担其构建规模较大、依赖复杂的 Go 项目的重任。还有更多关于 Go Module 的内容，我会在第 7 节课再详细跟你讲解。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到这里，我们终于亲手编写完成了 Go 语言的第一个程序“hello, world”，我们终于知道一个 Go 程序长成啥样子了，这让我们在自己的 Go 旅程上迈出了坚实的一步！</p><p>在这一节课里，我们通过 helloworld 示例程序，了解了一个 Go 程序的源码结构与代码风格自动格式化的约定。</p><ul><li><p>Go 包是 Go 语言的基本组成单元。一个 Go 程序就是一组包的集合，所有 Go 代码都位于包中；</p></li><li><p>Go 源码可以导入其他 Go 包，并使用其中的导出语法元素，包括类型、变量、函数、方法等，而且，main 函数是整个 Go 应用的入口函数；</p></li><li><p>Go 源码需要先编译，再分发和运行。如果是单 Go 源文件的情况，我们可以直接使用 go build 命令 +Go 源文件名的方式编译。不过，对于复杂的 Go 项目，我们需要在 Go Module 的帮助下完成项目的构建。</p></li><li><p>最后，我们结合 hellomodule 示例初步学习了一个基于 Go Module 构建模式编写和构建更大规模 Go 程序的步骤并介绍了 Go Module 涉及到的各种概念。而且，Go Module 机制日渐成熟，我希望你学会基于 Go Module 构建 Go 应用。关于 Go Module 构建模式，我们还会在后面的讲解中详细介绍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cd 命令的使用</title>
      <link href="/2022/08/23/cd-ming-ling-de-shi-yong/"/>
      <url>/2022/08/23/cd-ming-ling-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>cd : Change Directory 切换路径</strong></p><ul><li><p><code>cd /</code> 回到根目录</p></li><li><p><code>cd ..</code> 回到上一层目录</p></li><li><p>进入任意目录</p></li></ul><p>方法一：</p><ol><li><p>直接输入 [该目录所在盘区]:    进入该盘区目录</p></li><li><p>然后输入 cd [在盘区下相对路径]   进入该目录</p><p><img src="https://img-blog.csdnimg.cn/20190806125049779.PNG" alt="在这里插入图片描述"></p></li></ol><p>方法二:</p><p><code>cd /d [对应目录]</code></p><p><img src="https://img-blog.csdnimg.cn/2019080612540499.PNG" alt="在这里插入图片描述"></p><ul><li>显示 cd 帮助及用法</li></ul><p><code>cd/?</code></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 的安装问题</title>
      <link href="/2022/08/23/go-de-an-zhuang-wen-ti/"/>
      <url>/2022/08/23/go-de-an-zhuang-wen-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前安装过 go ，版本为 go1.18</p><p>安装路径设置不正确，没有设置为 Go 文件夹，而是直接安装到了 D:\ 路径下。</p><p>配置环境变量, GOROOT</p>]]></content>
      
      
      <categories>
          
          <category> 开发问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配好环境：选择一种最适合你的Go安装方法</title>
      <link href="/2022/08/23/pei-hao-huan-jing-xuan-ze-yi-chong-zui-gua-he-ni-de-go-an-zhuang-fang-fa/"/>
      <url>/2022/08/23/pei-hao-huan-jing-xuan-ze-yi-chong-zui-gua-he-ni-de-go-an-zhuang-fang-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装-Go"><a href="#安装-Go" class="headerlink" title="安装 Go"></a>安装 Go</h1><h2 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h2><p>Go 几乎支持 Linux 所有的主流发行版操作系统，常见的包括 Ubuntu、CentOS（Redhat 企业版 Linux 的社区开源版）、Fedora、SUSE 等等，Go 在这些主流的 Linux 发行版操作系统上的安装方法都是一样的（当然某个发行版也可能会利用其软件安装管理器提供仅属于其自己的安装方法）。你可以参考下面这样的安装步骤。</p><p>首先，我们需要下载并解压 Go Linux 安装包：</p><p><code>$wget -c https://golang.google.cn/dl/go1.16.5.linux-amd64.tar.gz</code></p><p>这里有个小提醒：虽然 Go 官方下载站点是 golang.org/dl，但我们可以用针对中国大陆的镜像站点 golang.google.cn/dl 来下载，在中国大陆地区使用大陆镜像站点可以大幅缩短下载时间。</p><p>第二步，将下载完毕的 Go 安装包解压到安装目录中：</p><p><code>$tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz</code></p><p>执行完上面解压缩命令后，我们将在 /usr/local 下面看到名为 go 的目录，这个目录就是 Go 的安装目录，也是 Go 官方推荐的 Go 安装目录。我们执行下面命令可以查看该安装目录下的组成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ls</span> -F /usr/local/goAUTHORS          CONTRIBUTORS  PATENTS    SECURITY.md  api/  doc/         lib/   pkg/        src/CONTRIBUTING.md  LICENSE       README.md  VERSION      bin/  favicon.ico  misc/  robots.txt  test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过呢，为了可以在任意路径下使用 go 命令，我们需要将 Go 二进制文件所在路径加入到用户环境变量 PATH 中（以用户使用 bash 为例），具体操作是将下面这行环境变量设置语句添加到 $HOME/.profile 文件的末尾：</p><p><code>export PATH=$PATH:/usr/local/go/bin</code></p><p>然后执行下面命令使上述环境变量的设置立即生效：</p><p><code>$source ~/.profile</code></p><p>最后，我们可以通过下面命令验证此次安装是否成功：</p><p><code>go version</code></p><h2 id="Mac-安装"><a href="#Mac-安装" class="headerlink" title="Mac 安装"></a>Mac 安装</h2><p><strong>与linux 几乎没有差别</strong></p><h2 id="Window-安装"><a href="#Window-安装" class="headerlink" title="Window 安装"></a>Window 安装</h2><p>在 Windows 上，我们最好的安装方式就是采用图形界面引导下的 Go 安装方法。</p><p>我们打开Go 包的下载页面&lt;<a href="https://golang.google.cn/dl/">Downloads - The Go Programming Language (google.cn)</a>&gt;，在页面上找到 Go 1.16.5 版本的 Windows msi 安装包（AMD64 架构下的）：go1.16.5.windows-amd64.msi，通过浏览器自带的下载工具它下载到本地任意目录下。</p><p>双击打开已下载的 go1.16.5.windows-amd64.msi 文件，我们就能看到下面这个安装引导界面：</p><p><img src="https://static001.geekbang.org/resource/image/68/2a/686e669aefbbe3ae35e37b0929b9722a.png?wh=618x483"></p><p>和所有使用图形界面方式安装的 Windows 应用程序一样，我们只需一路点击“继续（next）”就可完成 Go 程序的安装了，安装程序默认会把 Go 安装在 C:\Program Files\Go 下面，当然你也可以自己定制你的安装目录。</p><p>除了会将 Go 安装到你的系统中之外，Go 安装程序还会自动为你设置好 Go 使用所需的环境变量，包括在用户环境变量中增加 GOPATH，它的值默认为 C:\Users[用户名]\go，在系统变量中也会为 Path 变量增加一个值：C:\Program Files\Go\bin，这样我们就可以在任意路径下使用 Go 了。</p><h1 id="安装多个-Go-版本"><a href="#安装多个-Go-版本" class="headerlink" title="安装多个 Go 版本"></a>安装多个 Go 版本</h1><h2 id="重新设置-PATH-环境变量"><a href="#重新设置-PATH-环境变量" class="headerlink" title="重新设置 PATH 环境变量"></a>重新设置 PATH 环境变量</h2><p>你只需要将不同版本的 Go 安装在不同路径下，然后将它们的 Go 二进制文件的所在路径加入到 PATH 环境变量中就可以了。</p><p>我们以 Linux 环境为例，在前面介绍 Go 标准安装方法的时候，我们已经将 Go 1.16.5 版本安装到了 /usr/local/go 下面，也将 /usr/local/go/bin 这个路径加入到了 PATH 路径下了，当前状态我们在任意路径下敲入 go，执行的都是 Go 1.16.5 版本对应的 Go 二进制文件。</p><p>那这个时候，如果我们想再安装一个 Go 1.15.13 版本要怎么办呢？首先，你需要按照标准步骤将 Go 1.15.13 安装到事先建好的 /usr/local/go1.15.13 路径下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$mkdir</span> /usr/local/go1.15.13<span class="token variable">$wget</span> -c https://golang.google.cn/dl/go1.15.13.linux-amd64.tar.gz<span class="token variable">$tar</span> -C /usr/local/go1.15.13 -xzf go1.15.13.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来，我们来设置 PATH 环境变量，将原先 $HOME/.profile 中的 PATH 变量的值由：</p><p><code>export PATH=$PATH:/usr/local/go/bin</code></p><p>改为:</p><p><code>export PATH=$PATH:/usr/local/go1.15.13/go/bin</code></p><h2 id="go-get-命令"><a href="#go-get-命令" class="headerlink" title="go get 命令"></a>go get 命令</h2><p><strong>这种方法有一个前提，那就是当前系统中已经通过标准方法安装过某个版本的 Go 了。</strong></p><p>我们还以 Linux 环境为例，假设目前环境中已经存在了采用标准方法安装的 Go 1.16.5 版本，我们接下来想再安装一个 Go 1.15.13 版本。按照 Go 官方方法，我们可以这样来做：</p><p>首先，将 $ HOME/go/bin 加入到 PATH 环境变量中并生效，即便这个目录当前不存在也没关系：</p><p><code>export PATH=$PATH:/usr/local/go/bin:~/go/bin</code></p><p>然后，我们要执行下面这个命令安装 Go 1.15.13 版本的下载器：</p><p><code>$go get golang.org/dl/go1.15.13</code></p><p>这个命令会将名为 Go 1.15.13 的可执行文件安装到 $HOME/go/bin 这个目录下，它是 Go 1.15.13 版本的专用下载器，下面我们再来执行 Go 1.15.13 的下载安装命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 downloadDownloaded   <span class="token number">0.0</span>% <span class="token punctuation">(</span>    <span class="token number">16384</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded   <span class="token number">1.8</span>% <span class="token punctuation">(</span>  <span class="token number">2129904</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded  <span class="token number">84.9</span>% <span class="token punctuation">(</span><span class="token number">102792432</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">..</span>.Downloaded <span class="token number">100.0</span>% <span class="token punctuation">(</span><span class="token number">121120420</span> / <span class="token number">121120420</span> bytes<span class="token punctuation">)</span>Unpacking /root/sdk/go1.15.13/go1.15.13.linux-amd64.tar.gz <span class="token punctuation">..</span>.Success. You may now run <span class="token string">'go1.15.13'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们看到这个命令下载了 go1.15.13.linux-amd64.tar.gz 安装包，也将它安装到 $HOME/sdk/go1.15.13 下面了。下载安装结束后，我们就可以利用带有版本号的 go 命令来使用特定版本的 Go 了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 versiongo version go1.15.13 linux/amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$go1</span>.15.13 <span class="token function">env</span> GOROOT/root/sdk/go1.15.13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="go-get-命令安装非稳定版本"><a href="#go-get-命令安装非稳定版本" class="headerlink" title="go get 命令安装非稳定版本"></a>go get 命令安装非稳定版本</h2><p>其实，除了 Go 团队正式发布的稳定版本 (stable version)，像前面安装的 Go 1.16.5 或 Go 1.15.13，我们还可以通过 go get 的方法安装 Go 团队正在开发的非稳定版本 (Unstable Version)，包括每个稳定版发布前的 beta 版本或当前最新的 tip 版本，这些非稳定版本可以让 Go 开发人员提前体验到即将加入到稳定版本中的新特性。</p><p>但是，通过 go get 安装不同 Go 版本的方法在中国大陆地区会因网络问题而失败。如果你已经克服了网络问题，那安装非稳定版本的步骤其实和上面的步骤一样。现在，我们以 Go 1.17beta1 和 Go Tip 版本为例，带你体验一下它们的安装步骤和验证方法。</p><p>首先我们来看 Go 1.17beta1：</p><h1 id="配置-Go"><a href="#配置-Go" class="headerlink" title="配置 Go"></a>配置 Go</h1><p>其实 Go 在安装后是开箱即用的，这也意味着我们在使用 Go 之前无需做任何配置。但为了更好地了解和学习 Go，我们还是要认识一些 Go 自带的常用配置项。Go 的配置项是以环境变量的形式存在的，我们可以通过下面这个命令查看 Go 的这些配置项：</p><p><code>go env</code></p><p><img src="https://static001.geekbang.org/resource/image/ba/96/ba6990798fb17fc18386749f9cce2c96.jpg?wh=1080x1192"></p><p>如果你还要了解更多关于 Go 配置项的说明，你可以通过 go help environment 命令查看。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好了，到这里我们的 Go 安装配置方法就讲解完毕了，选好你要使用的 Go 安装方法了吗？在这一节课中我们首先讲解了三种 Go 版本的选择策略：</p><ul><li><p>一种，也是我们推荐的一种，那就是使用 Go 最新的版本，这样你可以体验到 Go 的最新语言特性，应用到标准库的最新 API 以及 Go 工具链的最新功能，并且很多老版本中的 bug 在最新版本中都会得到及时修复；</p></li><li><p>如果你还是对最新版本的稳定性有一丝担忧，你也可以选择使用次新版；</p></li><li><p>最后，如果你要考虑现存生产项目或开源项目，那你按照需要选择，与项目策略保持一致就好了。</p></li></ul><p>确定完 Go 版本后，我们就可以来安装这个 Go 版本了。这一节课我们也详细介绍了在三个主流操作系统上安装 Go 稳定版本的方法。</p><p>对于使用 Windows 或 macOS 操作系统的开发者，使用基于图形界面的安装方式显然是最方便、最简洁的；对于使用 Linux 操作系统的开发者，使用自解压的安装包，或者是通过操作系统自带安装工具来进行 Go 安装比较普遍。</p><p>如果你是要在本地开发环境安装多个 Go 版本，或者是要抢先体验新版 Go，我们还讲解了两种在本地安装多个 Go 版本的方法。这里再强调一下，通过 go get 方式安装最新的 Go tip 版本存在失败的可能性哦！</p><p>最后，我们讲解了 Go 的一些常用配置项的功用，对于中国地区的 Go 开发者而言，你在真正使用 Go 构建应用之前，唯一要做的就是配置 GOPROXY 这个 Go 环境变量。</p><p>有了 Go 开发环境，我们就有了编写和构建 Go 代码的基础，在下一讲中我们就将开始学习如何编写 Go 代码。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言的设计哲学是怎么一回事</title>
      <link href="/2022/08/23/go-yu-yan-de-she-ji-zhe-xue-shi-zen-me-yi-hui-shi/"/>
      <url>/2022/08/23/go-yu-yan-de-she-ji-zhe-xue-shi-zen-me-yi-hui-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>设计哲学之于编程语言，就好比一个人的价值观之于这个人的行为</strong></p><h1 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h1><p>知名 Go 开发者戴维·切尼（Dave Cheney）曾说过：“大多数编程语言创建伊始都致力于成为一门简单的语言，但最终都只是满足于做一个强大的编程语言”。</p><p>而 Go 语言是一个例外。Go 语言的设计者们在语言设计之初，就拒绝了走语言特性融合的道路，选择了“做减法”并致力于打造一门简单的编程语言。</p><p>选择了“简单”，就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。</p><p>其实，Go 语言也没它看起来那么简单，自身实现起来并不容易，但这些复杂性被 Go 语言的设计者们“隐藏”了，所以 Go 语法层面上呈现了这样的状态：</p><ul><li><p>仅有 25 个关键字</p></li><li><p>内置垃圾收集</p></li><li><p>首字母大小写决定可见性，无需通过额外关键字修饰</p></li><li><p>变量初始为类型零值</p></li><li><p>内置数组边界检查</p></li><li><p>内置并发支持，简化并发程序设计</p></li><li><p>内置接口类型，为组合的设计哲学奠定基础</p></li><li><p>原生提供完善的工具链，开箱即用</p></li><li><p>……</p></li></ul><p>看，我说的没错吧，确实挺简单的。当然了，任何的设计都存在着权衡与折中。我们看到 Go 设计者选择的“简单”，其实是站在巨人肩膀上，去除或优化了以往语言中，已经被开发者证明为体验不好或难以驾驭的语法元素和语言机制，并提出了自己的一些创新性的设计。比如，首字母大小写决定可见性、变量初始为类型零值、内置以 go 关键字实现的并发支持等。</p><p>Go 这种有些“逆潮流”的“简单哲学”并不是一开始就能得到程序员的理解的，但在真正使用 Go 之后，我们才能真正体会到这种简单所带来的收益：简单意味着可以使用更少的代码实现相同的功能；简单意味着代码具有更好的可读性，而可读性好的代码通常意味着更好的可维护性以及可靠性。</p><p>总之，在软件工程化的今天，这些都意味着对生产效率提升的极大促进，<strong>我们可以认为简单的设计哲学是 Go 生产力的源泉。</strong></p><h1 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h1><p>在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么，这与 C 语言的“信任程序员”原则完全不同，因此你需要以显式的方式通过转型统一参与计算各个变量的类型。</p><p>除此之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用了显式的基于值比较的错误处理方案，函数 / 方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误的处理。</p><p>这种有悖于“主流语言潮流”的错误处理机制还一度让开发者诟病，社区也提出了多个新错误处理方案，但或多或少都包含隐式的成分，都被 Go 开发团队一一否决了，这也与显式的设计哲学不无关系。</p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>这个设计哲学和我们各个程序之间的耦合有关，Go 语言不像 C++、Java 等主流面向对象语言，我们在 Go 中是找不到经典的面向对象语法元素、类型体系和继承机制的，Go 推崇的是组合的设计哲学。</p><p>在诠释组合之前，我们需要先来了解一下 Go 在语法元素设计时，是如何为“组合”哲学的应用奠定基础的。</p><p>在 Go 语言设计层面，Go 设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括：</p><ul><li><p>Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念</p></li><li><p>每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的</p></li><li><p>实现某个接口时，无需想 java 那样采用特定关键字修饰</p></li><li><p>包之间是相对独立的，没有子包的概念</p></li></ul><p>我们可以看到，无论是包、接口还是一个个具体的类型定义，Go 语言其实是为我们呈现了这样的一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。那么现在摆在面前的工作，就是在这些孤岛之间以最适当的方式建立关联，并形成一个整体。<strong>而 Go 选择采用的组合方式，也是最主要的方式。</strong></p><p>Go 语言为支撑组合的设计提供了<strong>类型嵌入（Type Embedding）</strong>。通过类型嵌入，我们可以将已经实现的功能嵌入到新类型中，以快速满足新类型的功能需求，这种方式有些类似经典面向对象语言中的“继承”机制，但在原理上却与面向对象中的继承完全不同，这是一种 Go 设计者们精心设计的“语法糖”。</p><p>被嵌入的类型和新类型两者之间没有任何关系，甚至相互完全不知道对方的存在，更没有经典面向对象语言中的那种父类、子类的关系，以及向上、向下转型（Type Casting）。通过新类型实例调用方法时，方法的匹配主要取决于方法名字，而不是类型。<strong>这种组合方式，我称之为垂直组合</strong>，即通过类型嵌入，快速让一个新类型“复用”其他类型已经实现的能力，实现功能的垂直扩展。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/sync/pool.go</span><span class="token keyword">type</span> poolLocal <span class="token keyword">struct</span> <span class="token punctuation">{</span>    private <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>       shared  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    Mutex   <span class="token comment">//类型嵌入              </span>    pad     <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口</span><span class="token comment">// $GOROOT/src/io/io.go</span><span class="token keyword">type</span> ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>    Reader    Writer<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>垂直组合本质上是一种“能力继承”，采用嵌入方式定义的新类型继承了嵌入类型的能力。Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。</p><p>Go 语言中的接口是一个创新设计，它只是方法集合，并且它与实现者之间的关系无需通过显式关键字修饰，它让程序内部各部分之间的耦合降至最低，同时它也是连接程序各个部分之间“纽带”。</p><p>水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码段所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// $GOROOT/src/io/ioutil/ioutil.go</span><span class="token keyword">func</span> <span class="token function">ReadAll</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token comment">// $GOROOT/src/io/io.go</span><span class="token keyword">func</span> <span class="token function">Copy</span><span class="token punctuation">(</span>dst Writer<span class="token punctuation">,</span> src Reader<span class="token punctuation">)</span><span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起了，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。类似的水平组合“模式”还有点缀器、中间件等，这里我就不展开了，在后面讲到接口类型时再详细叙述。</p><p>此外，我们还可以将 Go 语言内置的并发能力进行灵活组合以实现，比如，通过 goroutine+channel 的组合，可以实现类似 Unix Pipe 的能力。</p><p>总之，组合原则的应用实质上是塑造了 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。并且，组合也让遵循“简单”原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>好，前面我们已经看过 3 个设计哲学了，紧接着我带你看的是第 4 个：并发。</p><p>“并发”这个设计哲学的出现有它的背景，你也知道 CPU 都是靠提高主频来改进性能的，但是现在这个做法已经遇到了瓶颈。主频提高导致 CPU 的功耗和发热量剧增，反过来制约了 CPU 性能的进一步提高。2007 年开始，处理器厂商的竞争焦点从主频转向了多核。</p><p>在这种大背景下，Go 的设计者在决定去创建一门新语言的时候，果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，<strong>Go 放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程</strong>，Go 将之称为 goroutine。</p><p>goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的栈空间仅 2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。而且，所有的 Go 代码都在 goroutine 中执行，哪怕是 go 运行时的代码也不例外。</p><p>在提供了开销较低的 goroutine 的同时，Go 还在语言层面内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。相较于传统复杂的线程并发模型，Go 对并发的原生支持将大大降低开发人员在开发并发程序时的心智负担。</p><p>此外，并发的设计哲学不仅仅让 Go 在语法层面提供了并发原语支持，其对 Go 应用程序设计的影响更为重要。并发是一种程序结构设计的方法，它使得并行成为可能。采用并发方案设计的程序在单核处理器上也是可以正常运行的，也许在单核上的处理性能可能不如非并发方案。但随着处理器核数的增多，并发方案可以自然地提高处理性能。</p><p>而且，并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel+select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言也更适应现代计算环境。</p><h1 id="面向工程"><a href="#面向工程" class="headerlink" title="面向工程"></a>面向工程</h1><p>最后，我们来看一下 Go 的最后一条设计哲学：面向工程。</p><p>Go 语言设计的初衷，就是<strong>面向解决真实世界中 Google 内部大规模软件开发存在的各种问题</strong>，为这些问题提供答案，这些问题包括：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。</p><p>很多编程语言设计者和他们的粉丝们认为这些问题并不是一门编程语言应该去解决的，但 Go 语言的设计者并不这么看，他们在 Go 语言最初设计阶段就将解决工程问题作为 Go 的设计原则之一去考虑 Go 语法、工具链与标准库的设计，这也是 Go 与其他偏学院派、偏研究型的编程语言在设计思路上的一个重大差异。</p><p>语法是编程语言的用户接口，它直接影响开发人员对于这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心的打磨。比如：</p><ul><li><p>重新设计编译单元和目标文件格式，实现 Go 源码快速构建，让大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；</p></li><li><p>如果源文件导入它不使用的包，则程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的。这也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；</p></li><li><p>去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；</p></li><li><p>包路径是唯一的，而包名不必唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的”这个约定，大大降低了开发人员给包起唯一名字的心智负担；</p></li><li><p>故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；</p></li><li><p>增加类型别名（type alias），支持大规模代码库的重构。</p></li></ul><p>在标准库方面，Go 被称为“自带电池”的编程语言。如果说一门编程语言是“自带电池”，则说明这门语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库，Go 语言恰恰就是这类编程语言。</p><p>由于诞生年代较晚，而且目标比较明确，Go 在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto、encoding等包充分迎合了云原生时代的关于 API/RPC Web 服务的构建需求，Go 开发者可以直接基于标准库提供的这些包实现一个满足生产要求的 API 服务，从而减少对外部第三方包或库的依赖，降低工程代码依赖管理的复杂性，也降低了开发人员学习第三方库的心理负担。</p><p>而且，开发人员在工程过程中肯定是需要使用工具的，Go 语言就提供了足以让所有其它主流语言开发人员羡慕的工具链，工具链涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪等方方面面。</p><p>这里值得重点介绍的是 gofmt，它统一了 Go 语言的代码风格，在其他语言开发者还在为代码风格争论不休的时候，Go 开发者可以更加专注于领域业务中。同时，相同的代码风格让以往困扰开发者的代码阅读、理解和评审工作变得容易了很多，至少 Go 开发者再也不会有那种因代码风格的不同而产生的陌生感。Go 的这种统一代码风格思路也在开始影响着后续新编程语言的设计，并且一些现有的主流编程语言也在借鉴 Go 的一些设计。</p><p>在提供丰富的工具链的同时，Go 在标准库中提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> <strong>Go 语言的设计哲学：简单、显式、组合、并发和面向工程</strong></p><ul><li><p>简单是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；</p></li><li><p>显式是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；</p></li><li><p>组合是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；</p></li><li><p>并发是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；</p></li><li><p>面向工程是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前世今生：你不得不了解的Go的历史和现状</title>
      <link href="/2022/08/23/qian-shi-jin-sheng-ni-bu-de-bu-liao-jie-de-go-de-li-shi-he-xian-zhuang/"/>
      <url>/2022/08/23/qian-shi-jin-sheng-ni-bu-de-bu-liao-jie-de-go-de-li-shi-he-xian-zhuang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Go-语言是怎样诞生的"><a href="#Go-语言是怎样诞生的" class="headerlink" title="Go 语言是怎样诞生的?"></a>Go 语言是怎样诞生的?</h1><p>Go 语言的创始人有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson），Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike），以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）。</p><p>在罗伯·派克的心目中，“go”这个单词短小、容易输入并且在组合其他字母后便可以用来命名 Go 相关的工具，比如编译器（goc）、汇编器（goa）、链接器（gol）等（go 的早期版本曾如此命名 go 工具链，但后续版本撤销了这种命名方式，仅保留 go 这一统一的工具链名称 ）。</p><p>这里我还想澄清一个误区，很多 Go 语言初学者经常称这门语言为 Golang，其实这是不对的：“Golang”仅应用于命名 Go 语言官方网站，而且当时没有用 go.com 纯粹是这个域名被占用了而已。</p><p>在 Go 语言项目开源后，Go 语言也迎来了自己的“吉祥物”，是一只由罗伯·派克夫人芮妮·弗伦奇（Renee French）设计的地鼠，从此地鼠（gopher）也就成为了世界各地 Go 程序员的象征，Go 程序员也被昵称为 Gopher，在后面的课程中，我会直接使用 Gopher 指代 Go 语言开发者。</p><p><img src="https://static001.geekbang.org/resource/image/75/ab/756c7093c15eb32b5f9476b9fc5fcfab.png?wh=245x300"></p><h1 id="Go-是否值得我们学习？"><a href="#Go-是否值得我们学习？" class="headerlink" title="Go 是否值得我们学习？"></a>Go 是否值得我们学习？</h1><p>时间已经来到了 2021 年。经过了十余年的打磨与优化，如今的 Go 语言已经逐渐成为了云计算时代基础设施的编程语言。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、Istio、CockroachDB、InfluxDB、Terraform、Etcd、Consul 等等。当然，这个列表还在持续增加，可见 Go 语言的影响力已经十分强大。</p><p>Go 除了在云计算基础设施领域，拥有上面这些杀手级应用之外，Go 语言的用户数量也在近几年快速增加。Go 语言项目技术负责人罗斯·考克斯甚至还专门写过一篇文章，来估算全世界范围的 Gopher 数量。按照他的估算结果，全世界范围的 Gopher 数量从 2017 年年中的最多 100 万，增长到 2019 年 11 月的最多 196 万，大概两年半翻了一番。庞大的 Gopher 基数为 Go 未来的发展提供持续的增长潜力和更大的想象空间。</p><h1 id="Go-语言前景究竟如何，值不值得投入学习呢"><a href="#Go-语言前景究竟如何，值不值得投入学习呢" class="headerlink" title="Go 语言前景究竟如何，值不值得投入学习呢?"></a>Go 语言前景究竟如何，值不值得投入学习呢?</h1><p>从 Go 本身的发展来看，和多数编程语言一样，Go 语言在诞生后，度过了一个较长的“技术萌芽期”。然后，实现了自举，而且对 GC 延迟进行了大幅优化的 Go 1.5 版本，成为了 Go 语言演化过程中的第一个“引爆点”，推动 Go 语言进入“技术膨胀期”。</p><p>也正是在这段时间内，Go 语言以迅雷不及掩耳盗铃之势推出了以 Docker、Kubernetes 为典型代表的“杀手级应用”，充分展现了实力，在世界范围收获了百万粉丝，迸发出极高的潜力和持续的活力。</p><p>Go 开源于 2009 年末，如果从那时算起，Go 才 11 岁。但在 Go 核心开发团队眼中，Go 的真正诞生年份是 2007 年，距今已 13 个年头有余了。</p><p>回顾一下计算机编程语言的历史，我们会发现，绝大多数主流编程语言，都将在其 15 至 20 年间大步前进。Java、Python、Ruby、JavaScript 和许多其他编程语言都是这样。如今 Go 语言也马上进入自己的黄金 5～10 年，从前面的技术成熟度曲线分析也可以印证这一点：Go 已经重新回到“稳步爬升的光明期”。对于开发人员来说，Go 语言学习的最佳时刻已经到来了！</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言第一课</title>
      <link href="/2022/08/23/go-yu-yan-di-yi-ke/"/>
      <url>/2022/08/23/go-yu-yan-di-yi-ke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择-Go-语言的三大理由"><a href="#选择-Go-语言的三大理由" class="headerlink" title="选择 Go 语言的三大理由"></a>选择 Go 语言的三大理由</h1><ul><li><p>对初学者足够友善，能够快速上手</p><ul><li>Go 是一种非常简单的语言，静态语言</li></ul></li><li><p>生产力与性能的最佳结合</p></li><li><p>快乐又有”钱景“</p><ul><li><p>简单的语法</p></li><li><p>得心应手的工具链</p></li><li><p>丰富和健壮的标准库</p></li></ul></li></ul><h1 id="五个阶段"><a href="#五个阶段" class="headerlink" title="五个阶段"></a>五个阶段</h1><p><img src="https://static001.geekbang.org/resource/image/fc/9d/fcf857acac0ec2512de6f9dd77b1a69d.jpg?wh=1920x1080"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本架构：一个键值数据库包含什么?</title>
      <link href="/2022/08/23/ji-ben-jia-gou-yi-ge-jian-zhi-shu-ju-ku-bao-han-shi-me/"/>
      <url>/2022/08/23/ji-ben-jia-gou-yi-ge-jian-zhi-shu-ju-ku-bao-han-shi-me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>Redis 支持的 value 类型包括了 String、哈希表、列表、集合等</p></li><li><p>数据的基本操作</p><ul><li><p>PUT</p></li><li><p>GET</p></li><li><p>DELETE</p></li><li><p>SCAN，根据一段 key 的范围返回对应的 value 值</p></li></ul></li><li><p>键值对保存在内存</p></li></ul><p><strong>键值数据库的基本结构</strong></p><p><img src="https://static001.geekbang.org/resource/image/ec/d5/ec18bf4b8afef2fa8b99af252d95a2d5.jpg?wh=2360*3791"></p><h2 id="采用什么访问模式"><a href="#采用什么访问模式" class="headerlink" title="采用什么访问模式"></a>采用什么访问模式</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这样学Redis</title>
      <link href="/2022/08/23/zhe-yang-xue-redis/"/>
      <url>/2022/08/23/zhe-yang-xue-redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Reids 知识全景图</strong></p><p><img src="https://static001.geekbang.org/resource/image/79/e7/79da7093ed998a99d9abe91e610b74e7.jpg?wh=2001*1126"></p><p><strong>Redis问题画像图</strong></p><p><img src="https://static001.geekbang.org/resource/image/70/b4/70a5bc1ddc9e3579a2fcb8a5d44118b4.jpeg?wh=2048*1536"></p><p><strong>课程大纲</strong></p><p><img src="https://static001.geekbang.org/resource/image/13/7e/13946f7543f9eea58c9bd2b877826b7e.jpg?wh=750*4458"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习和使用</title>
      <link href="/2022/08/22/git-xue-xi-he-shi-yong/"/>
      <url>/2022/08/22/git-xue-xi-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git分布式版本控制工具</p><p><strong>git 命令总结</strong></p><h2 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h2><ul><li><p>了解 Git 基本概念</p></li><li><p>概述 Git 工作流程</p></li><li><p>使用 Git 常用命令</p></li><li><p>熟悉 Git 代码托管服务</p></li><li><p>能够使用 idea 操作 Git</p></li></ul><h1 id="2、概述"><a href="#2、概述" class="headerlink" title="2、概述"></a>2、概述</h1><h2 id="2-1、开发中的实际场景"><a href="#2-1、开发中的实际场景" class="headerlink" title="2.1、开发中的实际场景"></a>2.1、开发中的实际场景</h2><ul><li><p>备份，及时进行备份，防止丢失修改</p></li><li><p>代码还原，可以进行代码还原，记录修改记录</p></li><li><p>协同开发，创建分支，可以多人协同开发，进行合并</p></li><li><p>追溯问题代码的编写人和编写时间。可以查看日志，进行问题查看.</p></li></ul><h2 id="2-2、版本控制器的方式"><a href="#2-2、版本控制器的方式" class="headerlink" title="2.2、版本控制器的方式"></a>2.2、版本控制器的方式</h2><ul><li><p>集中式版本控制工具</p><p>集中式版本控制工具，版本库是集中存放在中央服务器中，团队里的成员从中央服务器下载代码，是必须联网才能工作，个人修改后然后提交到中央版本库。</p><p>  举例：SVN和CVS</p></li><li><p>分布式版本控制工具</p><p>分布式版本控制系统没有”中央服务器“，每个人的电脑上都是一个完整的版本库，这样工作的时候，不需要联网。多人协作只需要各自的修改推送给对方，就能相互看到对方的修改了。</p></li></ul><h2 id="2-3、Git工作流程图"><a href="#2-3、Git工作流程图" class="headerlink" title="2.3、Git工作流程图"></a>2.3、Git工作流程图</h2><h1 id="3、Git安装与常用命令"><a href="#3、Git安装与常用命令" class="headerlink" title="3、Git安装与常用命令"></a>3、Git安装与常用命令</h1><h2 id="3-1、Git-环境配置"><a href="#3-1、Git-环境配置" class="headerlink" title="3.1、Git 环境配置"></a>3.1、Git 环境配置</h2><h3 id="3-1-1-下载与安装"><a href="#3-1-1-下载与安装" class="headerlink" title="3.1.1 下载与安装"></a>3.1.1 下载与安装</h3><p>下载地址：<a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p>安装完成后，在桌面或者是文件夹，点击鼠标右键，可以看到两个图标</p><ul><li><p>Git GUI Here: 图形界面工具</p></li><li><p>Git Bash: Git 提供的命令行工具</p></li></ul><h3 id="3-1-2-基本配置"><a href="#3-1-2-基本配置" class="headerlink" title="3.1.2 基本配置"></a>3.1.2 基本配置</h3><ul><li>设置用户名称和email地址<ol><li><p>打开Git Bash</p></li><li><p>设置用户信息</p></li></ol></li></ul><p>git config –global user.name “zzu”</p><p>git config –global user.email “”</p><h3 id="3-1-3-为常用指令配置别名"><a href="#3-1-3-为常用指令配置别名" class="headerlink" title="3.1.3 为常用指令配置别名"></a>3.1.3 为常用指令配置别名</h3><ol><li><p>打开用户目录，创建 .bashrc 文件</p><p><code>touch ~/.bashrc</code></p></li><li><p>在 .bashrc文件中输入你想要设置的命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">一些linux的命令都可以在这里使用<span class="token comment">#用于输出git提交日志</span><span class="token builtin class-name">alias</span> git-log<span class="token operator">=</span><span class="token string">'git log --pretty=online --all --graph --abbrev-commit'</span><span class="token comment">#用于输出当前目录所有文件和基本信息</span><span class="token builtin class-name">alias</span> <span class="token assign-left variable">ll</span><span class="token operator">=</span><span class="token string">'ls -al'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>打开 gitBash, 执行 source ~/.bashrc</p><p><code>source ~/.bashrc</code></p></li></ol><h3 id="3-1-4-解决-GitBash-乱码问题"><a href="#3-1-4-解决-GitBash-乱码问题" class="headerlink" title="3.1.4 解决 GitBash 乱码问题"></a>3.1.4 解决 GitBash 乱码问题</h3><ol><li><p>打开 GitBash 执行下面命令</p><p><code>git config --global core.quotepath false</code></p></li><li><p>. ${git_home}/etc/bash.bashrc 文件最后加入下面两行</p><p><strong>Linux export 命令用于设置或显示环境变量。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span><span class="token string">"zh_CN.UTF-8"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="3-2、获取本地仓库"><a href="#3-2、获取本地仓库" class="headerlink" title="3.2、获取本地仓库"></a>3.2、获取本地仓库</h2><ol><li><p>选择一个空目录作为我们的本地仓库</p></li><li><p>进入这个目录，点击右键打开Git Bash Here窗口</p></li><li><p>执行命令 git init, 初始化仓库</p></li><li><p>创建成功后出现隐藏目录.git</p></li></ol><h2 id="3-3、基础操作命令"><a href="#3-3、基础操作命令" class="headerlink" title="3.3、基础操作命令"></a>3.3、基础操作命令</h2><p><strong>Git 会对仓库中的文件进行状态记录，每一个文件都会有几个状态</strong></p><ol><li><p>git add (工作区 –&gt; 暂存区)</p></li><li><p>git commit (暂存区 –&gt; 本地仓库)</p></li><li><p>git status 查看修改的状态</p></li><li><p>git add . 使用通配符，将工作区的多个文件的修改添加到暂存区</p></li><li><p>git commit -m ‘注释内容’</p></li><li><p>git log [option] 查看提交记录</p><ul><li>options<ul><li><p>-all 显示所有分支</p></li><li><p>–pretty=oneline 将提交信息显示为一行</p></li><li><p>–abbrev-commit 输出结果更加简短</p></li><li><p>–graph 以图的形式显示</p></li></ul></li></ul></li><li><p>git reset –hard commmitID 版本回退，进行版本切换</p><ul><li><p>commmitID 可以使用 git log 指令查看</p></li><li><p>如何查看已经删除的记录</p><ul><li>git reflog</li></ul></li></ul></li></ol><h2 id="3-4、编辑-gitignore文件"><a href="#3-4、编辑-gitignore文件" class="headerlink" title="3.4、编辑 .gitignore文件"></a>3.4、编辑 .gitignore文件</h2><p>并不是所有的文件都需要 git 的管理，比如日志文件，还有编译过程中生成的临时文件等。在这种情况下，我们可以创建一个 .gitignore 文件，列出要忽略的文件模式。</p><pre class="line-numbers language-none"><code class="language-none">HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**### STS ###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5、分支"><a href="#3-5、分支" class="headerlink" title="3.5、分支"></a>3.5、分支</h2><p>几乎所有的版本控制系统都已某种形式支持分支。使用分支意味着你可以把你的工作从主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><h3 id="3-5-1、查看本地分支"><a href="#3-5-1、查看本地分支" class="headerlink" title="3.5.1、查看本地分支"></a>3.5.1、查看本地分支</h3><ul><li>git branch</li></ul><h3 id="3-5-2、创建本地分支"><a href="#3-5-2、创建本地分支" class="headerlink" title="3.5.2、创建本地分支"></a>3.5.2、创建本地分支</h3><ul><li>git branch 分支名</li></ul><h3 id="3-5-3、切换分支"><a href="#3-5-3、切换分支" class="headerlink" title="3.5.3、切换分支"></a>3.5.3、切换分支</h3><ul><li><p>git checkout 分支名</p></li><li><p>git checkout -b 分支名 (切换到一个不存在的分支，创建并切换)</p></li></ul><h3 id="3-5-4、合并分支"><a href="#3-5-4、合并分支" class="headerlink" title="3.5.4、合并分支"></a>3.5.4、合并分支</h3><ul><li>git merge 分支名 (合并到当前分支)</li></ul><h3 id="3-5-5、删除分支"><a href="#3-5-5、删除分支" class="headerlink" title="3.5.5、删除分支"></a>3.5.5、删除分支</h3><p><strong>不能删除当前分支，只能删除其他分支</strong></p><ul><li><p>git branch -d 分支名 (删除分支时，需要做各种检查)</p></li><li><p>git branch -D 分支名 (不做任何检查，强制删除)</p></li></ul><h3 id="3-5-6、解决冲突"><a href="#3-5-6、解决冲突" class="headerlink" title="3.5.6、解决冲突"></a>3.5.6、解决冲突</h3><p><strong>不同的分支对同一个文件进行修改，在进行合并时，可能会存在冲突，这个时候需要手动解决冲突</strong></p><ol><li><p>处理文件冲突的地方,进行文件编辑，选择你想要留下的修改</p></li><li><p>将文件加入暂存区(add)</p></li><li><p>提交到仓库(commit)</p></li></ol><h3 id="3-5-7、开发中分支使用的原则和流程"><a href="#3-5-7、开发中分支使用的原则和流程" class="headerlink" title="3.5.7、开发中分支使用的原则和流程"></a>3.5.7、开发中分支使用的原则和流程</h3><ul><li><p>master 生产分支</p></li><li><p>develop 开发分支</p></li><li><p>feature/xxxx分支</p></li><li><p>hotfix/xxxx分支</p></li><li><p>test分支</p></li><li><p>pre分支</p></li></ul><h1 id="4、Git远程仓库"><a href="#4、Git远程仓库" class="headerlink" title="4、Git远程仓库"></a>4、Git远程仓库</h1><h2 id="4-1、常见的远程仓库"><a href="#4-1、常见的远程仓库" class="headerlink" title="4.1、常见的远程仓库"></a>4.1、常见的远程仓库</h2><ul><li><p>github <a href="https://github.com/">https://github.com/</a>是一个面向开源及私有软件项目的托管平台，只支持 Git 作为唯一的版本库格式进行托管。服务器在国外，访问不稳定。</p></li><li><p>码云 <a href="https://gitee.com/">https://gitee.com/</a> 是国内的一个代码托管平台，由于服务器在国内，访问快，稳定。</p></li><li><p>GitLab <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> 是一个用于仓库管理系统的开源项目， 一般用于在企业、学校等内部网络搭建 git 私服。</p></li></ul><h2 id="4-2、注册码云"><a href="#4-2、注册码云" class="headerlink" title="4.2、注册码云"></a>4.2、注册码云</h2><ul><li>注册码云账号 <a href="https://gitee.com/signup">注册 - Gitee.com</a></li></ul><h2 id="4-3、创建远程仓库"><a href="#4-3、创建远程仓库" class="headerlink" title="4.3、创建远程仓库"></a>4.3、创建远程仓库</h2><p><strong>仓库创建后可以查看仓库的地址</strong></p><h2 id="4-4、配置SSH公钥"><a href="#4-4、配置SSH公钥" class="headerlink" title="4.4、配置SSH公钥"></a>4.4、配置SSH公钥</h2><ol><li><p>打开 Git Bash Here ，生成 SSH 公钥</p><ul><li><p>ssh-keygen -t rsa</p></li><li><p>不断回车</p><ul><li>如果公钥已经存在，则自动覆盖</li></ul></li></ul></li><li><p>Gitee 设置账户公钥</p><ul><li>获取公钥<ul><li>cat ~/.ssh/id_rsa.pub</li></ul></li></ul></li><li><p>验证是否配置成功</p><ul><li>ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a></li></ul></li></ol><h2 id="4-5、操作远程仓库"><a href="#4-5、操作远程仓库" class="headerlink" title="4.5、操作远程仓库"></a>4.5、操作远程仓库</h2><h3 id="4-5-1、添加远程仓库"><a href="#4-5-1、添加远程仓库" class="headerlink" title="4.5.1、添加远程仓库"></a>4.5.1、添加远程仓库</h3><p><strong>需要先创建一个本地仓库，然后与远程仓库进行连接</strong></p><ul><li>命令：git remote add &lt;远端名称&gt; &lt;仓库路径&gt;<ul><li><p>远端名称，默认是 origin,取决于远端服务器设置</p></li><li><p>仓库路径，从远端服务器获取此 URL</p></li><li><p><code>git remote add origin https://gitee.com/z1397543194/reggie_take_out.git</code></p></li></ul></li></ul><h3 id="4-5-2、查看远程仓库"><a href="#4-5-2、查看远程仓库" class="headerlink" title="4.5.2、查看远程仓库"></a>4.5.2、查看远程仓库</h3><ul><li>命令：git remote</li></ul><h3 id="4-5-3、推送到远程仓库"><a href="#4-5-3、推送到远程仓库" class="headerlink" title="4.5.3、推送到远程仓库"></a>4.5.3、推送到远程仓库</h3><ul><li>命令：git push [-f] [–set-upstream] [远端名称 [本地分支名][:远端分支名]]<ul><li><p><code>git push origin master</code> 如果远程分支名和本地分支名称统统，则可以只写本地分支</p></li><li><p>-f 表示强制覆盖</p></li><li><p>–set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</p><ul><li><code>git push --set-upstream origin master</code></li></ul></li><li><p>如果当前分支已经和远端分支关联,则可以省略分支名和远端名</p><ul><li>git push 将master分支推送到已关联的远端分支</li></ul></li></ul></li></ul><h3 id="4-5-4、查看本地分支与远程分支的关联关系"><a href="#4-5-4、查看本地分支与远程分支的关联关系" class="headerlink" title="4.5.4、查看本地分支与远程分支的关联关系"></a>4.5.4、查看本地分支与远程分支的关联关系</h3><ul><li>命令：<code>git branch -vv</code></li></ul><h3 id="4-5-5、从远程仓库克隆"><a href="#4-5-5、从远程仓库克隆" class="headerlink" title="4.5.5、从远程仓库克隆"></a>4.5.5、从远程仓库克隆</h3><ul><li>命令： git clone &lt;仓库路径&gt; [本地目录]<ul><li>本地目录可以省略，会自动生成一个目录</li></ul></li></ul><h3 id="4-5-6、从远程仓库中抓取和拉取"><a href="#4-5-6、从远程仓库中抓取和拉取" class="headerlink" title="4.5.6、从远程仓库中抓取和拉取"></a>4.5.6、从远程仓库中抓取和拉取</h3><ul><li><p>抓取命令：<code>git fetch [remote name] [branch name]</code></p><ul><li><p>将仓库里的更新都抓取到本地，不会进行合并</p></li><li><p>如果不指定远端名称和分支名，则抓取所有分支</p></li></ul></li><li><p>拉取命令：<code>git pull [remote name] [branch name]</code></p><ul><li><p>将远端仓库的修改拉到本地并自动进行合并，==&gt;fetch + merge</p></li><li><p>如果不指定远端名称和分支名，则抓取并更新所有分支</p></li></ul></li></ul><h3 id="4-5-7、解决合并冲突"><a href="#4-5-7、解决合并冲突" class="headerlink" title="4.5.7、解决合并冲突"></a>4.5.7、解决合并冲突</h3><p>在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。<br>A用户在本地修改代码后优先推送到远程仓库，此时B用户在本地修订代码，提交到本地仓库后，也需要推送到远程仓库，此时B用户晚于A用户，故需要先拉取远程仓库的提交，经过合并后才能推送到远端分支,如下图所示。</p><h1 id="5、在-Idea-中使用-Git"><a href="#5、在-Idea-中使用-Git" class="headerlink" title="5、在 Idea 中使用 Git"></a>5、在 Idea 中使用 Git</h1><h2 id="5-1、在-Idea-中配置-Git"><a href="#5-1、在-Idea-中配置-Git" class="headerlink" title="5.1、在 Idea 中配置 Git"></a>5.1、在 Idea 中配置 Git</h2><h2 id="5-2、操作-Git"><a href="#5-2、操作-Git" class="headerlink" title="5.2、操作 Git"></a>5.2、操作 Git</h2><h3 id="5-2-1、创建远程仓库，使用码云"><a href="#5-2-1、创建远程仓库，使用码云" class="headerlink" title="5.2.1、创建远程仓库，使用码云"></a>5.2.1、创建远程仓库，使用码云</h3><h3 id="5-2-2、初始化本地仓库"><a href="#5-2-2、初始化本地仓库" class="headerlink" title="5.2.2、初始化本地仓库"></a>5.2.2、初始化本地仓库</h3><ul><li><p>在 idea 中创建</p></li><li><p>在目录中，执行 git init</p></li></ul><h3 id="5-2-3、设置远程仓库-或者克隆仓库"><a href="#5-2-3、设置远程仓库-或者克隆仓库" class="headerlink" title="5.2.3、设置远程仓库,或者克隆仓库"></a>5.2.3、设置远程仓库,或者克隆仓库</h3><h3 id="5-2-4、Git-的操作"><a href="#5-2-4、Git-的操作" class="headerlink" title="5.2.4、Git 的操作"></a>5.2.4、Git 的操作</h3><p><strong>git pull + merge / git add + commit / git push</strong></p><ul><li><p>更新项目 Ctrl + T</p></li><li><p>提交 Ctrl + K</p></li><li><p>推送 Ctrl + Shift + K</p></li></ul><h3 id="5-2-5、分支操作"><a href="#5-2-5、分支操作" class="headerlink" title="5.2.5、分支操作"></a>5.2.5、分支操作</h3><h3 id="5-2-6、解决冲突"><a href="#5-2-6、解决冲突" class="headerlink" title="5.2.6、解决冲突"></a>5.2.6、解决冲突</h3><ol><li><p>修改出现冲突的文件</p></li><li><p>add</p></li><li><p>commit</p></li><li><p>git push</p></li></ol><h2 id="5-3、IDEA常用-Git-操作入口"><a href="#5-3、IDEA常用-Git-操作入口" class="headerlink" title="5.3、IDEA常用 Git 操作入口"></a>5.3、IDEA常用 Git 操作入口</h2><h1 id="6、注意事项"><a href="#6、注意事项" class="headerlink" title="6、注意事项"></a>6、注意事项</h1><ul><li><p>切换分支前先提交本地的修改</p></li><li><p>代码写完后，要及时提交</p></li></ul><h2 id="6-1、window-查看隐藏文件-bashrc、-gitignore"><a href="#6-1、window-查看隐藏文件-bashrc、-gitignore" class="headerlink" title="6.1、window 查看隐藏文件(.bashrc、.gitignore)"></a>6.1、window 查看隐藏文件(.bashrc、.gitignore)</h2><h2 id="6-2、window-下创建-bashrc、-gitignore文件"><a href="#6-2、window-下创建-bashrc、-gitignore文件" class="headerlink" title="6.2、window 下创建.bashrc、.gitignore文件"></a>6.2、window 下创建.bashrc、.gitignore文件</h2><ul><li><p>打开git bash here</p></li><li><p><code>touch .gitignore</code></p></li></ul><h2 id="6-3、IDEA集成-GitBash-作为-Terminal"><a href="#6-3、IDEA集成-GitBash-作为-Terminal" class="headerlink" title="6.3、IDEA集成 GitBash 作为 Terminal"></a>6.3、IDEA集成 GitBash 作为 Terminal</h2><p><strong>可以作为git 的命令行，直接输入命令进行操作</strong></p><h1 id="7、学习资源推荐"><a href="#7、学习资源推荐" class="headerlink" title="7、学习资源推荐"></a>7、学习资源推荐</h1><ul><li><p>菜鸟教程 [菜鸟教程](<a href="https://www.runoob.com/git/git-tutorial.html">Git 教程 | 菜鸟教程 (runoob.com)</a>)</p></li><li><p>在线练习网站 [Git](<a href="https://oschina.gitee.io/learn-git-branching/">Learn Git Branching (gitee.io)</a>)</p></li><li><p>廖雪峰教程 [Git](<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a>)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window 如何打开终端</title>
      <link href="/2022/08/22/window-ru-he-da-kai-zhong-duan/"/>
      <url>/2022/08/22/window-ru-he-da-kai-zhong-duan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Window 如何打开命令行</strong></p><p>命令行工具有两种 cmd 和 powershell。老一代命令行工具cmd.exe及Windows新一代命令行工具Windows powershell工具，允许管理人员通过命令行的方式来管理计算机。只是相对cmd.exe，powershell的功能要强大的多，可以让管理员更容易地控制系统管理和加速自动化。powershell 是 cmd 的升级版、补充版,增加了很多命令。</p><h2 id="1-通过运行对话框打开"><a href="#1-通过运行对话框打开" class="headerlink" title="1. 通过运行对话框打开"></a>1. 通过运行对话框打开</h2><ul><li><p>win + R 打开运行对话框</p></li><li><p>输入 cmd / powershell</p></li></ul><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-20-58-image.png"></p><h2 id="2-通过开始菜单打开"><a href="#2-通过开始菜单打开" class="headerlink" title="2.通过开始菜单打开"></a>2.通过开始菜单打开</h2><ul><li><p>win + x ，或者在“开始”菜单上右键</p></li><li><p>选择命令提示符 / powershell</p></li></ul><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-21-16-image.png"></p><h1 id="3-在指定目录下打开"><a href="#3-在指定目录下打开" class="headerlink" title="3.在指定目录下打开"></a>3.在指定目录下打开</h1><h3 id="3-1-输入-cmd"><a href="#3-1-输入-cmd" class="headerlink" title="3.1 输入 cmd"></a>3.1 输入 cmd</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-26-52-image.png"></p><h3 id="3-2-shift-鼠标右键"><a href="#3-2-shift-鼠标右键" class="headerlink" title="3.2 shift + 鼠标右键"></a>3.2 shift + 鼠标右键</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-28-03-image.png"></p><h2 id="4-以管理员的身份打开"><a href="#4-以管理员的身份打开" class="headerlink" title="4.以管理员的身份打开"></a>4.以管理员的身份打开</h2><h3 id="4-1-搜索"><a href="#4-1-搜索" class="headerlink" title="4.1 搜索"></a>4.1 搜索</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-29-53-image.png"></p><h3 id="4-2-win-x"><a href="#4-2-win-x" class="headerlink" title="4.2 win + x"></a>4.2 win + x</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-30-24-image.png"></p><h3 id="4-3-在开始菜单中查找-cmd"><a href="#4-3-在开始菜单中查找-cmd" class="headerlink" title="4.3 在开始菜单中查找 cmd"></a>4.3 在开始菜单中查找 cmd</h3><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-18-23-33-25-image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Window </tag>
            
            <tag> 终端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 学习</title>
      <link href="/2022/08/22/markdown-xue-xi/"/>
      <url>/2022/08/22/markdown-xue-xi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1.语法</strong><br>**1.1 标题 **<br># 一级标题<br>## 二级标题<br>**1.2 列表 **</p><ul><li>无序列表使用 * 或 + 或 -</li><li>有序列表使用数字加.标识，例如：1.</li><li>无序列表<ul><li>二级列表项</li><li>二级列表项<ul><li>三级列表项，按TAB缩进即可</li></ul></li></ul></li><li>有序列表<ol><li>第一项</li><li>第二项<br><strong>1.3 链接</strong><br><strong>快捷键 Ctrl + k</strong><br><strong>1.3.1 文字超链接</strong><br>[显示的名字](网站)<br><a href="http://www.baidu.com/" title="百度一下">百度</a><br><strong>1.3.2 图像超链接</strong><br>![找不到图像文件时显示的文本](图像路径）<br><strong>1.3.3 索引超链接</strong><br>[显示名称][索引]<br>[索引]:对应的网站<br><a href="http://www.baudu.com/">百度官网</a></li></ol></li></ul><p><strong>1.3.4 自动链接</strong><br>直接用一对尖括号包围即可<br>&lt;网站&gt;<br>电子邮件地址也可以这样做<br><a href="mailto:1397543199@qq.com">1397543199@qq.com</a><br><strong>1.4 代码</strong><br><strong>1.4.1 代码片段</strong><br><strong>段落上的一个函数或片段的代码可以用反引号(<code>切换为英文输入法，在键盘的左上角) 把它包起来，例如：**</code>print(“你好”)`<br>**1.4.2 代码区块**<br>**用三个```或者三个~~~都可以定义代码区块，还可以选择语言种类，对代码进行高亮显示，不过应该不能补全提示，所以建议在ide中编写完成后，复制粘贴</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>1.5 文本</strong></p><pre class="line-numbers language-none"><code class="language-none">文本分段，前后至少保留一个空行即可。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>1.5.1 加粗或斜体</strong><br><strong>加粗</strong> ** **<br><em>斜体</em> _ _<br><em><strong>粗斜体</strong></em> *** ***<br><em><strong>粗斜体</strong></em> ___ ___</p><ul><li><p>快捷键：Ctrl + B,可以快速添加加粗效果<br><strong>1.5.2 线条</strong></p></li><li><p>水平线：三个—,在这里不知道为什么加载不出来，别的编辑器可以<br>你好</p></li><li><p>删除线：前后各两个~~ ~~</p><p><del>原价:100</del></p></li><li><p>下划线：和HTML的标签相同，，在这里不知道为什么加载不出来，别的编辑器可以</p><p><u>你好</u></p></li></ul><p><strong>1.5.3 符号或图标</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c168c88c2a94b6fbd6761bc91a7fc62~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8256891606e4821a28dd7a244d1381c~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9506a3b069cb4cf48d98fc1f1a60cf15~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14bca78a45b64fc28bd8059be12b9b36~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbd904891c74d9299d542c9a2fb9b7d~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p>更多图标写法可参考: <a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><p><strong>1.5.4 转义字符</strong></p><p>使用反斜杠\插入语法中用到的特殊符号。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d6fafb83a74ff5919539f4aa5dc8d2~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p>例如，如果你需要插入反斜杠，就连续输入两个\即可。<br>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p><p><strong>1.5.5 数学公式</strong></p><p>这个我平时很少使用，就不在这记录了，需要的时候在网上查找</p><p><strong>1.5.6 脚注</strong></p><p>脚注是对文本的补充说明<br>Markdown 脚注的格式如下:</p><p>[^要说明的文本]</p><p><strong>eg</strong></p><p>创建脚注格式类似这样<a href="%E4%BD%A0%E5%A5%BD%EF%BC%81%EF%BC%81%EF%BC%81">^hello</a>。</p><p><strong>1.6 引用</strong></p><p>区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号</p><blockquote><p>冬天来了，春天还会远吗?</p></blockquote><p><strong>1.7 表格</strong></p><p>表格使用 | 来分割不同的单元格，使用 - 来分割表头和其他行</p><table><thead><tr><th>姓名</th><th>年龄</th><th>性别</th></tr></thead><tbody><tr><td>张三</td><td>19</td><td>男</td></tr><tr><td>李四</td><td>18</td><td>女</td></tr></tbody></table><p><strong>1.8 样式</strong></p><p>  Markdown 标记语言出现的目的不是替代 HTML，也不是发明一种更便捷的插入HTML标签的方式。它对应的只是HTML标签的一个很小的子集。</p><p><strong>1.8.1 空格标记</strong></p><p>HTML提供好几种空格实体，它们拥有不同的宽度，非断行空格(&nbsp;)是常规空格的宽度，可运行于所有的主流浏览器。</p><ul><li>&nbsp; 不换行空格，全称No-Break Space。</li><li>  半角空格，全称En Space,占据的宽度正好是1/2个中文宽度，而且基本上不受字体的影响。</li><li>  全角空格，全称Em Space,占据的宽度正好是1个中文宽度，而且基本上不受字体的影响。</li><li>&amp;thsisp; 窄空格，全称Thin Space。占据的宽度比较小。</li><li>‌ 零宽不连字，全称Zero Width Non Joiner,是一个不打印字符,抑制本来会发生的连字。</li><li>‍ 零宽连字，全称Zero Width Joiner,产生连字的效果。</li></ul><p><strong>1.8.2 特殊样式，颜色</strong></p><p>【样式的写法】</p><p>不知道为什么，这里也没有效果</p><p>红色的文字</p><p><strong>1.10 图形</strong></p><p><strong>1.10.1 流程图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDStart <span class="token arrow operator">--&gt;</span> Stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDA<span class="token text string">[模块A]</span> <span class="token arrow operator">--&gt;</span><span class="token label property">|A1|</span> B<span class="token text string">(模块B)</span>B <span class="token arrow operator">--&gt;</span> C<span class="token text string">{判断条件C}</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C1|</span> D<span class="token text string">&gt;模块D]</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C2|</span> E<span class="token text string">((模块E))</span>C <span class="token arrow operator">--&gt;</span><span class="token label property">|条件C3|</span> F<span class="token text string">["模块F(引号可转义特殊字符)"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.10.2 时序图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">sequenceDiagram</span>Alice<span class="token arrow operator">-&gt;&gt;</span>John<span class="token operator">:</span> Hello John, how are you?John<span class="token arrow operator">--&gt;&gt;</span>Alice<span class="token operator">:</span> Great!Alice<span class="token arrow operator">-)</span>John<span class="token operator">:</span> See you later!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.10.3 甘特图</strong></p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">gantt</span>title A Gantt DiagramdateFormat  YYYY-MM-DDsection SectionA task           <span class="token operator">:</span>a1, 2014-01-01, 30dAnother task     <span class="token operator">:</span>after a1  , 20dsection AnotherTask in sec      <span class="token operator">:</span>2014-01-12  , 12danother task      <span class="token operator">:</span> 24d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13292f82dd1d45f59c1138fe1bd34dc0~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><strong>2 使用的软件</strong></p><p><strong>2.1 Typora</strong></p><p>之前是免费的，界面简洁，功能强大，现在是收费的。</p><p><strong>2.2 MarkText</strong></p><p>开源免费，支持多个平台。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cd9a9cb609241cbba108653769e7959~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><p><strong>2.3 ide插件</strong></p><p>VS Code, idea 等软件可以安装Markdown的插件。</p><p>学习使用Markdown<br>草稿箱<br>theme: juejin</p><hr>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 常用命令和命令别名快捷设置</title>
      <link href="/2022/08/22/hexo-chang-yong-ming-ling-he-ming-ling-bie-ming-kuai-jie-she-zhi/"/>
      <url>/2022/08/22/hexo-chang-yong-ming-ling-he-ming-ling-bie-ming-kuai-jie-she-zhi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>每次更新完博客后，都需要执行更新操作，命令较多，所以可以使用别名来减少输入</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><p><code>hexo clean </code>清理缓存</p></li><li><p><code>hexo g</code>  生成静态网页    hexo generate</p></li><li><p><code>hexo s</code>  本地预览            hexo server  默认为4000端口 -p 端口号</p></li><li><p><code>hexo d </code> 部署到 Github, 或者是服务器   hexo deploy</p></li><li><p><code>hexo n "postname"</code>  新建文章   hexo new “”</p></li><li><p><code>hexo n [layout] &lt;title&gt;</code> </p><ul><li>layout 不同，文件保存位置不同</li></ul></li></ul><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><ul><li><p><code>hexo init</code> 文件夹名称  初始化 hexo</p></li><li><p><code>npm update hexo -g</code>  升级</p></li><li><p><code>npm install hexo -g</code>   安装</p></li><li><p><code>node -v</code></p></li><li><p><code>npm -v</code></p></li><li><p><code>git --version</code></p></li><li><p><code>hexo -v</code></p></li><li><p><code>hexo publish [layout] &lt;title&gt;</code> 将草稿移动到 _posts 文件夹中</p><ul><li>草稿默认不会显示在页面中，您可在执行时加上&nbsp;<code>--draft</code>&nbsp;参数，或是把&nbsp;<code>render_drafts</code>&nbsp;参数设为&nbsp;<code>true</code>&nbsp;来预览草稿。</li></ul></li></ul><h1 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h1><p><code>$ hexo new photo "My Gallery"</code></p><p>在执行这行指令时，Hexo 会尝试在&nbsp;<code>scaffolds</code>&nbsp;文件夹中寻找&nbsp;<code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td></tr><tr><td><code>title</code></td><td>标题</td></tr><tr><td><code>date</code></td><td>文件建立日期</td></tr></tbody></table><h1 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h1><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了&nbsp;<code>hexo-renderer-marked</code>&nbsp;和&nbsp;<code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了&nbsp;<code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从&nbsp;<code>md</code>&nbsp;改成&nbsp;<code>ejs</code>，Hexo 就会使用&nbsp;<code>hexo-renderer-ejs</code>&nbsp;渲染这个文件，其他格式同理。</p><p><strong>参考链接：</strong>&lt;<a href="https://hexo.io/zh-cn/docs/writing">写作 | Hexo</a>&gt;</p><h1 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h1><ol><li><p>打开 Git 的文件夹</p></li><li><p>找到 \Git\etc\bash.bashrc 文件,添加别名</p></li><li><pre><code class="bash">alias hs='hexo clean &amp;&amp; hexo g &amp;&amp; hexo s'alias hd='hexo clean &amp;&amp; hexo g &amp;&amp; hexo d'alias gp='git add . &amp;&amp; git commit -m "update" &amp;&amp; git push -f'</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github、Git 设置代理</title>
      <link href="/2022/08/22/github-git-she-zhi-dai-li/"/>
      <url>/2022/08/22/github-git-she-zhi-dai-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitHub-、Git设置和取消代理"><a href="#GitHub-、Git设置和取消代理" class="headerlink" title="GitHub 、Git设置和取消代理"></a>GitHub 、Git设置和取消代理</h1><h2 id="主要是加速-git-clone-操作"><a href="#主要是加速-git-clone-操作" class="headerlink" title="主要是加速 git clone 操作"></a>主要是加速 git clone 操作</h2><ul><li>git 设置代理</li></ul><p><code>git config --global http.proxy http:127.0.0.1:[10810 这里面是你代理的端口号]</code></p><ul><li>git 取消代理</li></ul><p><code>git config --global --unset http.proxy</code></p><ul><li>针对 github.com 设置代理</li></ul><p><code>git config --global http.https://github.com.proxy http://127.0.0.1:[端口号]</code></p><ul><li>取消 github.com 代理</li></ul><p><code>git config --global --unset http.https://github.com.proxy</code></p><p><strong>注意</strong>：设置代理需要科学上网，可以在软件上查看，也可以在设置里查看</p><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-21-09-36-20-image.png"></p><p><img src="C:\Users\13975\AppData\Roaming\marktext\images\2022-08-21-09-36-29-image.png"></p><h2 id="ssh-连接-github-失败问题"><a href="#ssh-连接-github-失败问题" class="headerlink" title="ssh 连接 github 失败问题"></a>ssh 连接 github 失败问题</h2><p>设置公钥后，连接失败，显示22端口拒绝,更换为 443 端口</p><p><code>ssh git@github.com</code></p><p><code>ssh: connect to host github.com port 22: Connection refused</code></p><ol><li><p>在任意位置打开 Git Bash Here</p></li><li><p>创建 config 文件</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.ssh/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>在里面添加</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com Hostname ssh.github.com Port <span class="token number">443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
